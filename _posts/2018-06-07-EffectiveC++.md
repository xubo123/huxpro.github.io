---
layout:     post
title:      "Effective C++"
subtitle:   "Effective C++"
date:       2018-06-07 15:00:00
author:     "Xu"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - Effective C++
---

# Effective C++

## 1.让自己习惯C++
## 2.构造/析构/赋值运算
## 3.资源管理
## 4.设计与声明
## 5.实现
## 6.继承与面向对象设计
## 7.模型与泛型编程
## 8.定制new与delete
## 9.杂项讨论


## 1.让自己习惯C++

### 条款1:视C++为一个语言联邦

我们要知道C++不只是所有的语言遵循一个规范，C++是多套语言机制融合起来形成的语言联邦，它可以接受多套编程模式，更灵活，功能更强大：

1. C语言：C++完全融合C语言，以C作为基础，C++实际上就是C 的高级解法
2. Object-Oriented C++：面向对象的C＋＋，结合面向对象的思想，编译器实现面向对象中的classs,封装，继承，多态，虚函数等等
3. Template C++:泛型编程
4. STL：是在模版的基础上，封装出一系列标准数据结构容器，算法，迭代器，函数对象供编程人员更方便的使用

C++是一个四个次语言组成的联邦政府，每个次语言都有自己的规约。

### 条款2:尽量以const,enum,inline替换#define

"宁可多让编译器多做一点工作，不让预处理器做过多工作"
#### const替换#define
对于#define 在预处理阶段直接进行替换：#define ASPECT_RATIO 1.653 

* 在编译器开始编译阶段，ASPECT_RATIO就已经被预处理器移走了，该名称并**没有进入记号表**内。
* 当你使用该常量导致错误时，并不知道是ASPECT_RATIO引发的错误，导致**错误追踪困难**
* 还有可能导致目标码1.653**重复出现**多份

解决方法：用const替换#define

const doublei AspectRatio = 1.653;

#### enum
* 如果有的编译器不允许"static整型class常量"在类内完成**初值设定**，可以改用"the enum hack"的替代做法。
* “一个属于枚举类型的数值可以权充ints被使用”
* enum行为某方面更像#define而不像const
    - 和#define一样，取enum的地址就不合法
    - 实用主义，模版元编程的基础

#### inline替换宏

我们知道用#define来定义宏会有很多麻烦，但是这种方式效率很高，为了实现这种效率又要保证函数的可预料行为及类型安全检查，我们可以用内联函数inline来替换宏

#### 总结

1. 对于单纯常量，最好用const对象或enums替换#defines
2. 对于形似函数的宏，最好改用inline函数替换#defines

### 条款3:尽可能使用const

const最具有威力的用法是面对函数声明时的应用，在一个函数声明式内，const可以和函数返回值、各参数、函数自身产生关联

* 令函数返回一个const常量值,可以降低客户错误而造成的意外

```
class Rational{...};
const Rational operator*(const Rational &lhs,const Rational& rhs);

Rational a,b,c;

(a*b) = c;//在a*b的返回值上进行赋值操作。可能是因为单纯的打字错误(a*b) == c;
```

#### const 成员函数

使用const作用于成员函数的两个目的：

1. 便于理解
2. 可以操作const对象

并且两个成语函数可以根据参数是否具有**const特性而进行重载**

一个成员函数是const目前有两个流行的概念：

1. **bitwise constess**:该const成员函数**不允许有**任何对象进行**修改**
2. **logical constess**:该const成员函数**可以修改**它所处理的non-static对象内的某些bits.

**编译器**往往采用的是**bitwise constess**的概念，但现实编程过程往往需要实现logical const的概念，所以我们使用**mutable来释放掉non-static成员变量的bitwise constess约束**

#### const和non-const成员函数中避免重复

因为往往一个函数可能针对是否是const有**两个重载版本**，但这两个重载版本中可能会有重复的步骤：边界检验，日志数据访问，检验数据完整性等等。。为了避免这些**重复代码的生成，并影响编译的效率**。我们往往采用如下做法：

* non-const调用用const版本的函数，const版本实现这些必要的相同步骤，掉用过程中会做**两次相应的转换操作**
    - non_const调用const传入的参数**添加const属性，使用static_cast**<const >
    - const函数返回值**去掉const属性 const_cast**<T&>;
* 为什么不是const调用non_const?
    - 因为non_const不能保证参数是否被修改，从而影响了const成员函数对对象不做改动的承诺

#### 总结

1. 将const作用于任何作用域内的对象、函数参数、函数返回类型、成员函数本体可以检测到某些错误的用法
2. 编译器强行实施bitwise ，但编写程序时应该使用“概念上的常量性”
3. 当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可以避免重复

### 条款4:确定对象被使用前已被初始化

读取未初始化的值会导致不明确的行为，在某些平台上，仅仅是读取未初始化的值就可能让你的程序终止运行。更可能的情况是读入一些"半随机"的bits,污染正在读取的那个对象，导致不可测知的程序行为

按对象类型进行划分：

* 内置类型：永远在使用对象之前进行初始化
* 类类型：初始化责任在于构造函数，确保每一饿构造函数都将对象的每一个成员初始化
    - 对象的成员变量初始化发生在进入构造函数本体之前
    - 先调用**构造函数**再调用**拷贝赋值函数**的效率比只调用一次**拷贝构造函数**的效率低
    - 成员变量初始化的顺序和声明顺序一致

不同编译单元内定义之non-local static对象的初始化顺序，现在我们关心一个问题：

* 当有两个源码文件是，每一个源码文件至少一个non-local static对象，真正的问题是：
    - 如果一个源码文件内的某个non-local static对象的初始化动作**使用**了另一个原文件中的non-local static对象。
    - 但是C++对于“定义于不同编译单元内的non-local static对象”的**初始化顺序并没有明确定义**，所以初始化过程就会出现问题

{% highlight c++ %}
//源文件1
class FileSystem{
    public:
    ...
    std::size_t numDisk() const;
    ...
};
extern FileSystem tfs;//non-local static对象

//源文件2
class Directory{
    public:
        Directory(params);
        ...
};

Directory::Directory(params){
    ...
    std::size_t disks = tfs.numDisks();//使用源文件1中的non-local static对象tfs
    ...
}
{% endhighlight %}


* 解决方案：设计模式中的单例模式
    - 将该non-local static对象设置为local static，即放入到一个**函数**中去，该函数返回该**对象的引用**
    - 另一个源文件调用该对象时，要通过**调用该函数得到该对象的引用**。
    - 这是因为：C++保证，函数内的 **local static**对象会在 **"该函数被调用期间"**和 **“首次遇到该对象之定义式”**时被初始化

{% highlight c++ %}

/源文件1
class FileSystem{
    public:
    ...
    std::size_t numDisk() const;
    ...
};
//将该non-local对象放到函数内部
FileSystem& tfs(){
    static FileSystem fs;//local static对象
    return fs;
}

//源文件2
class Directory{
    public:
        Directory(params);
        ...
};

Directory::Directory(params){
    ...
    std::size_t disks = tfs().numDisks();//使用源文件1中的全局函数tfs获取local static变量fs
    ...
}
{% endhighlight %}

这种结构下的reference-returning函数非常简单，往往第一行定义一个local static变量，第二行返回该对象。这样的函数的简单的性质非常使用成为inline函数

### 总结

1. 为内置对象进行手工初始化，因为c++不保证初始化他们
2. 构造函数最好使用成员初始化列表，不要在构造函数本体内部使用赋值函数
3. 为“免除跨编译单元之初始化次序”问题，请以local static对象替换non-local static对象


## 2.构造/析构/赋值运算

### 条款05：了解C++默默编写并调用哪些函数

* C++的一个对象会在你没有声明拷贝控制成员（构造，拷贝构造，拷贝赋值，析构，移动）时，会自动合成这些成员并且仅在这些函数被需要（被调用，它们才会被编译器创建出来）

* 当一个类对象中含有**引用&或const成员**时，编译器将会**拒绝编译**拷贝赋值函数，因为引用不能改指不同的对象，且const成员不能被修改

* 如果某个基类将拷贝赋值操作符声明为private,编译器将会拒绝为其派生类合成拷贝赋值函数，因为派生类的拷贝赋值函数需要调用基类的拷贝赋值函数

### 条款06:若不想使用编译器自动生成的函数，就该明确拒绝

有些类代表的对象天生就是独一无二的，拷贝显得不合常理，为了阻止编译器自动合成这些拷贝赋值函数有如下几种做法：

1. 将对应的**成员函数设置为private**,外界不能调用拷贝控制成员，但是内部成员函数还是可以调用
2. 使用Uncopyable这样的基类，**阻止**编译器为其**派生类**合成拷贝控制成员
3. 使用delete明确删除？

```c++

class Uncopyable{
    protected:
        Uncopyable(){}
        ~Uncopyable(){}
    private:
        Uncopyable(const Uncopyable&);//将拷贝函数设置为private,派生类无法自动合成
        Uncopyable& operator=(const Uncopyable&);
}；

```

### 条款07:为多态基类声明virtual析构函数

当我们实现**多态**时，往往用一个**基类指针指向派生类**，然后调用该指针指向对象的析构函数时，如果该基类的析构函数不是一个虚函数，则析构部分只会析构基类的部分，派生类的数据并没有被析构，这就导致**“局部销毁”**，形成资源泄漏。

解决思路：
* 为每一个实现**多态用途**的类声明一个虚析构函数，如果class带有任何虚函数，它就应该拥有一个虚析构函数
* Class的设计目的如果不是为了作为**基类**使用，或不是为了具备**多态性**，就不该声明虚析构函数

### 条款08:别让异常逃离析构函数

为什么析构函数中不能抛出异常？

解答：

* 因为我们的**异常处理流程是栈展开**的模式来处理异常
* 在函数栈展开的过程中要**销毁局部对象**
* 当这些局部对象被析构的过程当中，若再次抛出异常，使得程序中有**两个异常同时存在**，此时程序若不是**结束执行**，就是导致**不明确的行为**

但是我们的析构函数部分需要执行可能抛出异常的步骤时怎么办，如关闭数据库连接：

解决办法：

1. 设计一个**接口**让客户自行处理可能抛出异常的操作，析构函数部分只需要检测步骤是否成功执行，若没有再执行该步骤（关闭数据库连接）
2. 当析构函数部分发生异常时，阻止该异常抛出
    - try catch获取异常后，调用abort()强迫程序结束，抢先阻止"不明确行为的发生"
    - try catch获取异常后，不做处理，吞掉该异常，防止该异常抛出

#### 总结
1. 析构函数不要抛出异常，如果发生异常，应该**结束程序或直接吞掉异常**
2. 如果客户需要多某个操作函数运行期间的异常做出反应，class应该设计**对应的接口**执行该操作（而不是在析构函数中）

### 条款09:绝不在构造和析构函数中调用virtual函数

#### 构造函数
在构造函数中调用虚函数：

* 假设有一个class继承体系，基类的构造函数中调用虚函数
* 当派生类开始构造时，首先调用的是基类的构造函数
* 此时**虚函数表指针**还是指向基类的虚函数表，调用的虚函数也是基类版本的虚函数,显然不是我们想要的。（因为既然是虚函数，我们自然希望调用的时候调用的是各派生类不同的版本）
* 基类的构造期间virtual函数绝不会下降到derived classed阶层

为什么要这么设计？

1. 因为在基类的构造期间，派生类中的**成员变量尚未初始化**，若调用派生类版的虚函数绝对要使用派生类中未初始化的成员，这会导致**不明确行为**的发生
2. 派生类对象在基类的构造期间，对象的类型是base class而不是derived class,不只是虚函数调用的是基类的版本，使用**运行期类型信息**typeid或dynamic_cast都会视为基类类型

#### 析构函数

和构造函数的原理类似，因为调用派生类的析构函数，先**释放派生类中的成员变量**，然后调用基类的析构函数，此时对象已经成为一个**基类对象**,调用的虚函数也是基类版本的虚函数。

且如果该虚函数在基类中是一个**纯虚函数**，基类的构造函数和析构函数调用这个虚函数会报出**连接错误**，这个虚函数**必须有定义**。

#### 解决办法：

将该虚函数改为**非虚函数**，然后调用派生类的构造函数或析构函数的时候传递参数（相关信息）到该非虚函数中去。

#### 总结

1. 在base class构造和析构期间调用的virtual函数**不可下降至**derived class
2. 在析构和构造期间**不要调用virtual**函数，因为这类调用**不会下降**到derived class

### 条款10:令operator=返回一个reference to *this

为了实现“连锁赋值”，赋值操作符必须返回一个reference，这个协议不仅适用于标准的赋值形式，也适用于所有赋值相关运算：+=,-=,*=

### 条款11:在operator=中处理自我赋值

```c++
class Bitmap{...};
class Widget{
    ...
    private:
    Bitmap * pb;
};
```

#### 自我赋值可能出现问题的赋值实现：

```c++
Widget&
Widget::operator=(const Widget& rhs){
    delete pb;
    pb = new Bitmap(*rhs.pb);
    return *this;
}

```
分析：当pb和传入进来的rhs.pb指向**同一个对象Bitmap**时,delete会将该Bitmap对象删除掉，导致new Bitmap的过程中pb指向一个被删除的对象。这就会发生错误。

解决办法：添加证同测试

#### 证同测试
```c++
Widget &Widget::operator=(const Widget& rhs){
    if(this == &rhs) return *this;//如果是自我赋值，则直接返回

    delete pb;
    pb = new Bitmap(*rhs.pb);
    return *this;
}
```

异常安全性往往可以自动获得“自我赋值安全”的回报。因为自我赋值的过程中出现错误也会发生异常：

#### 考虑异常安全的实现版本

```c++
Widget &Widget::operator=(const Widget& rhs){
    Bitmap * pOrig = pb;
    pb = new Bitmap(*rhs.pb);
    delete pOrig;
    return *this;

}

```

分析：

* 即使new Bitmap过程中发生异常，本对象的pb依然指向原对象。
* 当发生自我赋值时，先不删除pb所指的对象，而是保留一个指针副本pOrig，然后pb指向一个新的Bitmap后再对本对象进行删除操作

#### 考虑异常安全的copy and swap技术

**by reference版本**
```c++
class Widget{
    ...
    void swap(Widget &rhs);//交换*this和rhs的数据
    ...
}；

Widget& Widget::operator=(const Widget& rhs){
    Widget temp(rhs);//创建一个临时对象
    swap(temp);//将该临时对象和本对象进行交换，局部变量会自动销毁
    return *this;
}

```

**by value版本**

```c++

Widget& Widget::operator=(Widget rhs){
    //不用创建一个临时对象，因为rhs参数本身就是一个拷贝副本
    swap(temp);//将该临时对象和本对象进行交换，局部变量会自动销毁
    return *this;
}
```

#### 总结
1. 保证自我赋值安全和异常安全
2. 利用**语句顺序**或by reference和by value的**swap and copy**技术来保证异常安全和自我赋值安全

### 条款12:复制对象时勿忘其每一个成分

1. 拷贝函数（拷贝构造和拷贝赋值）应该确保复制**“对象内每一个成员变量”**及**“所有base class的成分”**
2. 不要尝试在一个拷贝函数（如拷贝构造）调用另一个拷贝函数（拷贝赋值）。应该将共同机能的**重复代码放入第三个成员函数中**供两个拷贝函数调用。

## 3.资源管理

### 条款13:以对象管理资源(智能指针对象)

资源管理可能出现的问题：当一个工厂函数创建一个我们想要获取的资源对象时，该工厂函数内部会进行**动态内存分配**，所以我们需要手工对该资源进行**释放delete操作**。但可能因为某种异常的发生或提前return函数，导致该资源**没有被回收**造成资源泄漏。

解决的思路：

* 把资源放入对象中进行管理，将释放资源的部分放入析构函数中处理，然后依赖C++的**析构函数**自动调用机制确保资源被释放。（只要函数调用结束，局部变量的对象都会自动调用析构函数）
* 利用智能指针auto_ptr，指向资源对象，当智能指针被销毁时，会调用对象的析构函数进行资源释放

资源管理的两个重要思路：

1. 获得资源后立刻放进**管理对象(智能指针)**内部：工厂函数createInvestment()返回的资源被当作管理对象，智能指针的初值。这种“以对象管理资源”的观念被称为“资源取得时机便是初始化时机（RAII）”
2. 管理对象运用**析构函数确保资源被释放**

智能指针的问题：

* 对于auto_ptr指针指向的对象，不允许**有多个auto_ptr**同时指向一个对象，auto_pte通过拷贝构造函数和拷贝赋值函数复制它们，会进行**管理权的移交，原auto_ptr将会指向空**
    
    ```c++
    std::auto_ptr<Investment> pInv1(createInvestment());
    std::auto_ptr<Investment> pInv2(pInv1);//发生拷贝构造，此时pInv1指向null
    pInv1 = pInv2;//发生拷贝赋值，此时pInv2指向null
    ```
* 为发生正常的复制行为，引入“计数型智慧指针RCSP”。如shared_ptr
* createInvestment()工厂函数返回的“未加工指针”，简直是对资源泄漏的一个明显的漏洞，因为调用者极其容器忘记对这个指针调用delete。我们将在条款18中对这个接口进行修改

### 总结

1. 为防止资源泄漏，请使用**RAII 对象，它们在构造函数中获得资源，并在析构函数中分配资源**
2. 两个常用的**RAII对象**为：管理对象shared_ptr和auto_ptr，其区别主要在于拷贝的过程。

### 条款14:在资源管理类中注意copying的行为

* 并不是所有的资源都是基于堆的（动态内存分配）的资源。这些资源是可以直接使用指针指向它们。所以可以直接使用智能指针进行管理即可,因为智能指针的析构函数**默认调用delete**。
* 有些资源如锁，我们需要**设计一个RAII类**对锁资源进行管理,同样满足RAII规范,在构造过程中获得锁，在析构过程中释放锁(不是通过delete释放的)

```c++
class Lock{
    public:
        explicit Lock(Mutex *pm):mutexPtr(pm){
            lock(mutexPtr);//构造函数中获得锁
        };
        ~Lock(){ 
            unloc(mutexPtr);//析构函数中释放锁
        }
    private:
    Mutex * mutexPtr;
}
```

当一个RAII的对象被复制时会发生什么？

1. **禁止复制**：实现方式见条款6，因为许多RAII对象被复制并不合理
2. 对底层资源使用**“引用计数法”**：实际资源不做拷贝，只递增引用计数，如shared_ptr就是如此。当引用计数为0时删除所指资源。

```c++
    class Lock{
        public:
            explicit Lock(Mutex):mutexPtr(pm,unlock){
                lock(mutexPtr.get());
            }
        private: 
            std::tr1::shared_ptr<Mutex> mutexPtr;//使用shared_ptr
    }

```

这里使用shared_ptr指向锁资源，并传入释放锁的析构函数unlock:

* 所以该类Lock不需要实现析构函数
* 复制mutexPtr时也只是增加锁资源的引用计数而已


* **复制底部资源**：有时候我们需要复制的不是一个指向资源的shared_ptr，只增加其引用计数，而是需要**复制实际的资源**，同时得到一个新的shared_ptr指向该新的资源副本。这属于**深度拷贝**
* **转移底部资源控制权：**同shared_ptr,只不过**底层用auto_ptr**实现，复制时即进行控制权的交接

### 条款15:在资源管理类中提供对原始资源的的访问

**C APIs往往要求访问原始资源（被RAII对象所管理的原始资源），所以每一个RAII class应该提供一个“取得其所管理之资源”的办法**

两个办法：

* 显式转换（不方便，但安全）：为RAII class提供一个get()接口直接返回其管理资源指针
* 隐式转换（方便使用，不安全）：
    - 概念：   
        + 转换构造函数：将其他类型数据隐式转换成本类类型对象
            * 格式：构造函数只有一个参数
        + 隐式转换函数：将本类类型对象转换为指定类型的数据
            * 格式：operator 类型（）｛｝
    - 在对应场景，RAII会隐式转换为原始资源的数据。

### 条款16:成对使用new和delete时要采取相同的形式

new和 delete成对使用，new［］和delete［］成对使用：

* 如果你调用**new**的时候，使用**delete[]**释放内存，由于delete[]寻找数组元素个数的机制为**cookies机制**，配置一块额外的字来存放数大小，再根据该大小来逐个析构元素。但若只有一个元素，delete则有可能**获取到一个未知的数字当作数组大小从而造成不可预知的错误**
* 如果你调用 **new[]**的时候，使用**delete**来释放内存，最后有可能只析构该元素的**第一个元素**，并释放第一个元素的内存而已，其它元素都没有释放

### 条款17:以独立语句将newed对象置入智能指针。

考虑一个对象Widget,我们想要使用智能指针管理这歌对象，并传入到processWidget函数中去，该函数有两个参数，一个就是智能指针，另一个则是优先级。

```c++
processWidget(std::tr1::shared_ptr<Widget> pw,int priority);
//调用该函数
processWidget(std::tr1::shared_ptr<Widget>（new Widget）,priority());
```

C++和java以及C#不同，那两种语言总是以特定次序完成函数参数的计算，C++则不一定，所以C++有三种可能的参数计算顺序：

* 第一种
    - new Widget
    - tr1::shared_ptr构造函数
    - 调用priority()
* 第二种：
    - 调用priority()
    - new Widget
    - tr1::shared_ptr构造函数
* 第三种
    - new Widget
    - 调用priority()
    - tr1::shared_ptr构造函数

对于第三种顺序：

* 当new一个对象时返回一个原生指针
* 然后调用priority（）函数
* 如果发生异常，则原生指针可能丢失，发生内存泄漏。因为此时还没有存入智能指针进行管理

解决办法：使用**单独的语句**将newed的对象放入到智能指针对象管理

```c++
std::tr1::shared_ptr<Widget> pw(new Widget);

processWidget(pw,priority());
```
## 4.设计与声明

### 条款18:让接口容易被正确使用，不易被误用

* 保证接口的**一致性**：如C++ STL容器都提供size()返回容器大小，但是Java和.Net对于不同容器大小接口可能不同，这会增加使用负担
* 保证和内置类型的行为兼容
* 尽量少的**要求用户去记住**执行某种操作，减少使用的过程中出现遗漏等错误：如createInvestment()**返回一个原生指针**，就要求用户去记得delete该指针，这就很容易出现用户没有删除指针，或删除两次相同的指针这些错误
    - 所以正确的接口createInvestment（）的设计应该直接返回智能指针，不需要用户操心指针删除的操作
* **阻止误用**的办法包括：建立新类型，限制类型上的操作，束缚对象值，以及消除客户的资源管理责任

### 条款19:设计class犹如设计type

在设计class时，下列问题将导致class你的设计规范：

* 新type的对象应该如何被创建和销毁？
    - 构造函数、析构函数
    - 内存分配和释放函数：new,new[],delete,delete[]
* 对象的**初始化**和对象的**赋值**该有什么样的差别？
* 新type的对象如果被passed by value，意味着什么？
    - 拷贝构造函数定义passed by value的方式
* 什么是新type的“合法值”？
* 你的新type需要配合某个继承体系吗？
* 你的新type需要什么样的转换？
    - 隐式转换和显示转换的设计
    - 转换构造函数和类型转换函数的设计
* 什么样的操作符和函数对此新type而言是合理的？
    - 成员函数的设计
* 什么样的标准函数应该驳回？
* 谁该取用新type的成员？
* 什么是新type的“未声明接口”？
* 你的新type有多么一般化？
    - 是否应该使用template使得该type更具一般化
* 你真的需要一个新type吗？

### 条款20:宁以pass-by-reference-to-const替换pass-by-value

用pass-by-value进行参数传递有两个弊端：

1. 需要创建临时变量，并调用**拷贝构造函数**，代价昂贵
2. 可能发生**对象切割**问题，当pass-by-value的方式进行参数传递时，如果参数格式是要求一个**基类对象**，而实际的传递过程中传递的是一个**派生类对象**，在调用拷贝构造的过程中，会将该派生类视为基类对象，从而只拷贝基类部分的数据，导致对象切割。使用引用或指针则不会

#### 总结

* 尽量以pass-by-reference-to-const替换pass-by-value,前者通常比较高校，并且可以避免切割问题
* 以上规则并不适用于内置类型以及STL的迭代器和函数对象，对它们而言pass-by-value往往比较适当

### 条款21:必须返回对象时别妄想返回其reference

* 当某些函数的的确确在执行的过程中**创建了新的对象**，该新的对象就是我们函数的执行结果的返回值，如果我们仅仅返回的是该新结果对象的引用时，由于它是**局部变量**，会在函数 **退出时销毁**，这会导致返回的引用指向的是一个已经被析构的对象

思考：

* 假设我们函数内部，在**heap结构**上分配并构造了一个新的结果对象，然后返回该结果对象的引用

```c++
const Rational & operator*(const Rational &lhs,const Rational &rhs){
    Rational * result = new Rational(lhs.n*ths.n,lhs.d*rhs.d);
    return *result;
}
```

* 上述代码，会引起内存泄漏
    - 假设我们执行： 
        
        ```
        Rational w,x,y,z;
        w = x*y*z;
        ```
    - x*y会产生一个新对象，(x*y)*z又会产生一个新的对象，但之前产生的**新的对象的原生指针已经丢失(局部变量自动销毁)**，却没有进行delete从而导致内存泄漏。

#### 总结

* 绝对不要返回pointer 或reference指向一个**local stack**对象，或返回reference指向一个**heap-allocated**对象，或返回一个pointer或reference指向**local static**对象。
* 当需要**返回一个新对象**作为结果时，直接pass-by-value返回该对象即可

### 条款22:将成员变量设置为private

* 将成员变量声明为private:
    - 可以赋予客户**访问数据的一致性**
    - 可细微划分**访问控制**（可读可写）
    - 允许变量的**约束条件**获得保证（不能随意设置变量为任意值）
    - 并使得class设计者有充分的**实现弹性**，因为内部数据对用户是透明的,用户不用了解接口的实现方式。
* protected并不比public更具有封装性

### 条款23:宁以non-member、non-friend替换member函数

设计原则：类中的成员函数只保留那些直接和数据进行交互的基础数据操作部分的函数，那些**间接通过调用其他成员函数**而实现某种特定功能的成员函数(类似于**工具函数**)，完全可以使用非成员(non-member)函数来替换

* 原因：提高类中数据的封装性，当可以访问类中private部分数据的**代码（成员函数和友元函数就可以访问）越少，封装性越高**。
* 一般的实现模式是将这些工具函数用non-member函数的形式实现，然后和该类放在**同一个namespace**下。
    - 因为**namespace 可以跨越多个源码文件**而class不能
    - 意味着客户可以**轻松扩展**这一组和class相关的便利工具函数
* 不一定非是非成员函数，可以是**其它类的成员函数**,比如我们设计一个**工具类**，在该工具类中的成员函数实现对该class的相关操作，一样可以保证这个class的封装性

#### 总结
宁可拿“non-member non-friend”函数替换member函数，这样做可以增加封装性、包裹弹性和机能扩充性

### 条款24:若所有参数皆需类型转换，请为此采用non-member函数

* 如果一个函数的**所有参数**都可能涉及到**隐式类型转换**，为了实现**混合式运算**，我们应该将这个函数设计为non-member函数。
    - 因为只有当**参数被列于参数列（parameter list）内**，这个参数才是隐式类型转换的**合格参与者**
    - 成员函数：只有位于类对象的**右边部分的数据**才在成员函数的参数列表内部，才能进行隐式类型转换，左边则不行
    - 
    ```
    如operator*()是Rational成员函数：
    Ration x;
    x＊3;//合法
    3＊x;//不合法
    ```
    - **非成员函数**，则没有方向，**两边都在该函数的参数列表**内，都可以进行隐式类型转换。

#### 总结
* 如果你需要为某个函数的所有参数进行类型转换，那么这个函数必须是non-member

### 条款25:考虑写出一个不抛异常的swap函数

* 为什么我们要讨论swap函数：
    - 因为swap是异常安全性编程的脊柱，见条款29
    - 也是处理自我赋值可能性的一个常见机制，见条款11

* 分析STL提供的标准程序库中swap算法，实现如下：

```
namespace std{
    template<typename T>
    void swap(T &a,T &b){
        T temp(a);
        a = b;
        b = temp;
    }
}
```
* 该函数只对支持coping操作的类使用，并且要经过**三次拷贝或赋值**的操作，对于那些底层数据是由一个**指向实际数据的指针**所维护时，这样的操作就显得**效率很低**，因为理论上，我们只需要将两个类中的**指针进行交换**即可。

为此出于效率的考虑，我们尝试一下几种方案：

* 对于class，设计**全特化版本**的swap函数，当遇到该类（**底层用指针维护数据的类**）时，直接交换指针即可
    - 由于非成员函数**不能访问类的private 指针数据**，所以我们需要为该类添加一组swap**成员函数**
    - 成员函数利用指针数据，再**调用**标准版的swap函数
    - 所以特化版本调用成员函数，再调用标准版本进行指针交换
* 当如果是一个**template**，而不是class时，我们不能再为该template设计一个特化版的swap，因为对于**模版函数(function template)，C++规定只能进行全特化，不能进行偏特化**，不同于class template
    - 所以我们只能直接提供一个**重载版本**的swap模版函数，但**std是一个特殊的空间，不可以添加新的template到std**
        + 所以我们需要将该class temlate和重载版本的swap模版放到一个**新的namespace**中去，成为**专属**的swap版本函数

* **最后的实现方案**就是：为该class或template添加一个**专属**版本的swap函数，该函数调用一个**成员函数**，该成语函数结合指针数据**调用标准swap函数**进行指针交换：
    - 对于class,在**std命名空间**内添加一个**全特化版本**的swap函数，调用成员函数，成员函数调用标准swap函数进行指针交换
    - 对于template,在**新的命名空间**添加一个**重载版本**的swap函数，同样调用成员函数，成员函数调用标准swap函数进行指针交换

* 所以swap函数可能有**三个版本**：
    - std既有的**一般swap**版本
    - std中为class设计的**全特化**swap版本
    - 为template设计的**专属swap版本**，可能栖身在某个命名空间中
    - C++的**名称查找法则**会找到最适合的swap版本

* **成员版的swap**绝不可以抛出异常，因为swap的一个最好的应用就是帮助class提供**异常安全性**
* 对非成员版的swap没有这个约束条件


## 5.实现

这一章将就如下几个实现上可能出现的问题进行解释：

1. **太快定义变量**可能造成效率上的拖延
2. **过度使用转型**可能导致代码变慢又难以维护
3. 返回对象“**内部数据之号码牌**”可能会破坏封装并留给客户虚吊号码牌
4. 未考虑**异常**带来的冲击导致资源泄漏或数据败坏
5. 过度热心的使用**inlining**可能引起代码膨胀
6. **过度耦合**则可能导致令人不满意的冗长build时间

### 条款26:尽可能延后变量定义式出现的时间

此条款在对象模型中有提到过：[对象的构造和析构](http://blog.xbblfz.site/2018/04/21/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B#对象的构造和析构)

* 一个带有构造函数和析构函数变量对象，不要**过早定义**，因为很有可能在该对象还没有被使用之前，该函数就已经**提前退出**，这样就会导致**没有必要的对象构造和析构过程**。
* 并且通过"**default构造函数构造出一个对象然后对它赋值**"比“**直接在构造时指定初值**”效率差
* 所以我们应该尽可能**延后变量的定义**，不仅仅是非得使用该变量的前一刻为止，甚至应该延后到这份定义直到**能够可以指定给它初值实参**为止。这样可以**避免无意义的default** 构造行为



## 6.继承与面向对象设计
## 7.模型与泛型编程
## 8.定制new与delete
## 9.杂项讨论
---
layout:     post
title:      "Effective C++"
subtitle:   "Effective C++"
date:       2018-06-07 15:00:00
author:     "Xu"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - Effective C++
---

# Effective C++

## 1.让自己习惯C++
## 2.构造/析构/赋值运算
## 3.资源管理
## 4.设计与声明
## 5.实现
## 6.继承与面向对象设计
## 7.模型与泛型编程
## 8.定制new与delete
## 9.杂项讨论


## 1.让自己习惯C++

### 条款1:视C++为一个语言联邦

我们要知道C++不只是所有的语言遵循一个规范，C++是多套语言机制融合起来形成的语言联邦，它可以接受多套编程模式，更灵活，功能更强大：

1. C语言：C++完全融合C语言，以C作为基础，C++实际上就是C 的高级解法
2. Object-Oriented C++：面向对象的C＋＋，结合面向对象的思想，编译器实现面向对象中的classs,封装，继承，多态，虚函数等等
3. Template C++:泛型编程
4. STL：是在模版的基础上，封装出一系列标准数据结构容器，算法，迭代器，函数对象供编程人员更方便的使用

C++是一个四个次语言组成的联邦政府，每个次语言都有自己的规约。

### 条款2:尽量以const,enum,inline替换#define

"宁可多让编译器多做一点工作，不让预处理器做过多工作"
#### const替换#define
对于#define 在预处理阶段直接进行替换：#define ASPECT_RATIO 1.653 

* 在编译器开始编译阶段，ASPECT_RATIO就已经被预处理器移走了，该名称并**没有进入记号表**内。
* 当你使用该常量导致错误时，并不知道是ASPECT_RATIO引发的错误，导致**错误追踪困难**
* 还有可能导致目标码1.653**重复出现**多份

解决方法：用const替换#define

const doublei AspectRatio = 1.653;

#### enum
* 如果有的编译器不允许"static整型class常量"在类内完成**初值设定**，可以改用"the enum hack"的替代做法。
* “一个属于枚举类型的数值可以权充ints被使用”
* enum行为某方面更像#define而不像const
    - 和#define一样，取enum的地址就不合法
    - 实用主义，模版元编程的基础

#### inline替换宏

我们知道用#define来定义宏会有很多麻烦，但是这种方式效率很高，为了实现这种效率又要保证函数的可预料行为及类型安全检查，我们可以用内联函数inline来替换宏

#### 总结

1. 对于单纯常量，最好用const对象或enums替换#defines
2. 对于形似函数的宏，最好改用inline函数替换#defines

### 条款3:尽可能使用const

const最具有威力的用法是面对函数声明时的应用，在一个函数声明式内，const可以和函数返回值、各参数、函数自身产生关联

* 令函数返回一个const常量值,可以降低客户错误而造成的意外

```
class Rational{...};
const Rational operator*(const Rational &lhs,const Rational& rhs);

Rational a,b,c;

(a*b) = c;//在a*b的返回值上进行赋值操作。可能是因为单纯的打字错误(a*b) == c;
```

#### const 成员函数

使用const作用于成员函数的两个目的：

1. 便于理解
2. 可以操作const对象

并且两个成语函数可以根据参数是否具有**const特性而进行重载**

一个成员函数是const目前有两个流行的概念：

1. **bitwise constess**:该const成员函数**不允许有**任何对象进行**修改**
2. **logical constess**:该const成员函数**可以修改**它所处理的non-static对象内的某些bits.

**编译器**往往采用的是**bitwise constess**的概念，但现实编程过程往往需要实现logical const的概念，所以我们使用**mutable来释放掉non-static成员变量的bitwise constess约束**

#### const和non-const成员函数中避免重复

因为往往一个函数可能针对是否是const有**两个重载版本**，但这两个重载版本中可能会有重复的步骤：边界检验，日志数据访问，检验数据完整性等等。。为了避免这些**重复代码的生成，并影响编译的效率**。我们往往采用如下做法：

* non-const调用用const版本的函数，const版本实现这些必要的相同步骤，掉用过程中会做**两次相应的转换操作**
    - non_const调用const传入的参数**添加const属性，使用static_cast**<const >
    - const函数返回值**去掉const属性 const_cast**<T&>;
* 为什么不是const调用non_const?
    - 因为non_const不能保证参数是否被修改，从而影响了const成员函数对对象不做改动的承诺

#### 总结

1. 将const作用于任何作用域内的对象、函数参数、函数返回类型、成员函数本体可以检测到某些错误的用法
2. 编译器强行实施bitwise ，但编写程序时应该使用“概念上的常量性”
3. 当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可以避免重复

### 条款4:确定对象被使用前已被初始化

读取未初始化的值会导致不明确的行为，在某些平台上，仅仅是读取未初始化的值就可能让你的程序终止运行。更可能的情况是读入一些"半随机"的bits,污染正在读取的那个对象，导致不可测知的程序行为

按对象类型进行划分：

* 内置类型：永远在使用对象之前进行初始化
* 类类型：初始化责任在于构造函数，确保每一饿构造函数都将对象的每一个成员初始化
    - 对象的成员变量初始化发生在进入构造函数本体之前
    - 先调用**构造函数**再调用**拷贝赋值函数**的效率比只调用一次**拷贝构造函数**的效率低
    - 成员变量初始化的顺序和声明顺序一致

不同编译单元内定义之non-local static对象的初始化顺序，现在我们关心一个问题：

* 当有两个源码文件是，每一个源码文件至少一个non-local static对象，真正的问题是：
    - 如果一个源码文件内的某个non-local static对象的初始化动作**使用**了另一个原文件中的non-local static对象。
    - 但是C++对于“定义于不同编译单元内的non-local static对象”的**初始化顺序并没有明确定义**，所以初始化过程就会出现问题

{% highlight c++ %}
//源文件1
class FileSystem{
    public:
    ...
    std::size_t numDisk() const;
    ...
};
extern FileSystem tfs;//non-local static对象

//源文件2
class Directory{
    public:
        Directory(params);
        ...
};

Directory::Directory(params){
    ...
    std::size_t disks = tfs.numDisks();//使用源文件1中的non-local static对象tfs
    ...
}
{% endhighlight %}


* 解决方案：设计模式中的单例模式
    - 将该non-local static对象设置为local static，即放入到一个**函数**中去，该函数返回该**对象的引用**
    - 另一个源文件调用该对象时，要通过**调用该函数得到该对象的引用**。
    - 这是因为：C++保证，函数内的 **local static**对象会在 **"该函数被调用期间"**和 **“首次遇到该对象之定义式”**时被初始化

{% highlight c++ %}

/源文件1
class FileSystem{
    public:
    ...
    std::size_t numDisk() const;
    ...
};
//将该non-local对象放到函数内部
FileSystem& tfs(){
    static FileSystem fs;//local static对象
    return fs;
}

//源文件2
class Directory{
    public:
        Directory(params);
        ...
};

Directory::Directory(params){
    ...
    std::size_t disks = tfs().numDisks();//使用源文件1中的全局函数tfs获取local static变量fs
    ...
}
{% endhighlight %}

这种结构下的reference-returning函数非常简单，往往第一行定义一个local static变量，第二行返回该对象。这样的函数的简单的性质非常使用成为inline函数

### 总结

1. 为内置对象进行手工初始化，因为c++不保证初始化他们
2. 构造函数最好使用成员初始化列表，不要在构造函数本体内部使用赋值函数
3. 为“免除跨编译单元之初始化次序”问题，请以local static对象替换non-local static对象


## 2.构造/析构/赋值运算

### 条款05：了解C++默默编写并调用哪些函数

* C++的一个对象会在你没有声明拷贝控制成员（构造，拷贝构造，拷贝赋值，析构，移动）时，会自动合成这些成员并且仅在这些函数被需要（被调用，它们才会被编译器创建出来）

* 当一个类对象中含有**引用&或const成员**时，编译器将会**拒绝编译**拷贝赋值函数，因为引用不能改指不同的对象，且const成员不能被修改

* 如果某个基类将拷贝赋值操作符声明为private,编译器将会拒绝为其派生类合成拷贝赋值函数，因为派生类的拷贝赋值函数需要调用基类的拷贝赋值函数

### 条款06:若不想使用编译器自动生成的函数，就该明确拒绝

有些类代表的对象天生就是独一无二的，拷贝显得不合常理，为了阻止编译器自动合成这些拷贝赋值函数有如下几种做法：

1. 将对应的**成员函数设置为private**,外界不能调用拷贝控制成员，但是内部成员函数还是可以调用
2. 使用Uncopyable这样的基类，**阻止**编译器为其**派生类**合成拷贝控制成员
3. 使用delete明确删除？

```c++

class Uncopyable{
    protected:
        Uncopyable(){}
        ~Uncopyable(){}
    private:
        Uncopyable(const Uncopyable&);//将拷贝函数设置为private,派生类无法自动合成
        Uncopyable& operator=(const Uncopyable&);
}；

```

### 条款07:为多态基类声明virtual析构函数

当我们实现**多态**时，往往用一个**基类指针指向派生类**，然后调用该指针指向对象的析构函数时，如果该基类的析构函数不是一个虚函数，则析构部分只会析构基类的部分，派生类的数据并没有被析构，这就导致**“局部销毁”**，形成资源泄漏。

解决思路：
* 为每一个实现**多态用途**的类声明一个虚析构函数，如果class带有任何虚函数，它就应该拥有一个虚析构函数
* Class的设计目的如果不是为了作为**基类**使用，或不是为了具备**多态性**，就不该声明虚析构函数

### 条款08:别让异常逃离析构函数

为什么析构函数中不能抛出异常？

解答：

* 因为我们的**异常处理流程是栈展开**的模式来处理异常
* 在函数栈展开的过程中要**销毁局部对象**
* 当这些局部对象被析构的过程当中，若再次抛出异常，使得程序中有**两个异常同时存在**，此时程序若不是**结束执行**，就是导致**不明确的行为**

但是我们的析构函数部分需要执行可能抛出异常的步骤时怎么办，如关闭数据库连接：

解决办法：

1. 设计一个**接口**让客户自行处理可能抛出异常的操作，析构函数部分只需要检测步骤是否成功执行，若没有再执行该步骤（关闭数据库连接）
2. 当析构函数部分发生异常时，阻止该异常抛出
    - try catch获取异常后，调用abort()强迫程序结束，抢先阻止"不明确行为的发生"
    - try catch获取异常后，不做处理，吞掉该异常，防止该异常抛出

#### 总结
1. 析构函数不要抛出异常，如果发生异常，应该**结束程序或直接吞掉异常**
2. 如果客户需要多某个操作函数运行期间的异常做出反应，class应该设计**对应的接口**执行该操作（而不是在析构函数中）

### 条款09:绝不在构造和析构函数中调用virtual函数

#### 构造函数
在构造函数中调用虚函数：

* 假设有一个class继承体系，基类的构造函数中调用虚函数
* 当派生类开始构造时，首先调用的是基类的构造函数
* 此时**虚函数表指针**还是指向基类的虚函数表，调用的虚函数也是基类版本的虚函数,显然不是我们想要的。（因为既然是虚函数，我们自然希望调用的时候调用的是各派生类不同的版本）
* 基类的构造期间virtual函数绝不会下降到derived classed阶层

为什么要这么设计？

1. 因为在基类的构造期间，派生类中的**成员变量尚未初始化**，若调用派生类版的虚函数绝对要使用派生类中未初始化的成员，这会导致**不明确行为**的发生
2. 派生类对象在基类的构造期间，对象的类型是base class而不是derived class,不只是虚函数调用的是基类的版本，使用**运行期类型信息**typeid或dynamic_cast都会视为基类类型

#### 析构函数

和构造函数的原理类似，因为调用派生类的析构函数，先**释放派生类中的成员变量**，然后调用基类的析构函数，此时对象已经成为一个**基类对象**,调用的虚函数也是基类版本的虚函数。

且如果该虚函数在基类中是一个**纯虚函数**，基类的构造函数和析构函数调用这个虚函数会报出**连接错误**，这个虚函数**必须有定义**。

#### 解决办法：

将该虚函数改为**非虚函数**，然后调用派生类的构造函数或析构函数的时候传递参数（相关信息）到该非虚函数中去。

#### 总结

1. 在base class构造和析构期间调用的virtual函数**不可下降至**derived class
2. 在析构和构造期间**不要调用virtual**函数，因为这类调用**不会下降**到derived class

### 条款10:令operator=返回一个reference to *this

为了实现“连锁赋值”，赋值操作符必须返回一个reference，这个协议不仅适用于标准的赋值形式，也适用于所有赋值相关运算：+=,-=,*=

### 条款11:在operator=中处理自我赋值

```c++
class Bitmap{...};
class Widget{
    ...
    private:
    Bitmap * pb;
};
```

#### 自我赋值可能出现问题的赋值实现：

```c++
Widget&
Widget::operator=(const Widget& rhs){
    delete pb;
    pb = new Bitmap(*rhs.pb);
    return *this;
}

```
分析：当pb和传入进来的rhs.pb指向**同一个对象Bitmap**时,delete会将该Bitmap对象删除掉，导致new Bitmap的过程中pb指向一个被删除的对象。这就会发生错误。

解决办法：添加证同测试

#### 证同测试
```c++
Widget &Widget::operator=(const Widget& rhs){
    if(this == &rhs) return *this;//如果是自我赋值，则直接返回

    delete pb;
    pb = new Bitmap(*rhs.pb);
    return *this;
}
```

异常安全性往往可以自动获得“自我赋值安全”的回报。因为自我赋值的过程中出现错误也会发生异常：

#### 考虑异常安全的实现版本

```c++
Widget &Widget::operator=(const Widget& rhs){
    Bitmap * pOrig = pb;
    pb = new Bitmap(*rhs.pb);
    delete pOrig;
    return *this;

}

```

分析：

* 即使new Bitmap过程中发生异常，本对象的pb依然指向原对象。
* 当发生自我赋值时，先不删除pb所指的对象，而是保留一个指针副本pOrig，然后pb指向一个新的Bitmap后再对本对象进行删除操作

#### 考虑异常安全的copy and swap技术

**by reference版本**
```c++
class Widget{
    ...
    void swap(Widget &rhs);//交换*this和rhs的数据
    ...
}；

Widget& Widget::operator=(const Widget& rhs){
    Widget temp(rhs);//创建一个临时对象
    swap(temp);//将该临时对象和本对象进行交换，局部变量会自动销毁
    return *this;
}

```

**by value版本**

```c++

Widget& Widget::operator=(Widget rhs){
    //不用创建一个临时对象，因为rhs参数本身就是一个拷贝副本
    swap(temp);//将该临时对象和本对象进行交换，局部变量会自动销毁
    return *this;
}
```

#### 总结
1. 保证自我赋值安全和异常安全
2. 利用**语句顺序**或by reference和by value的**swap and copy**技术来保证异常安全和自我赋值安全

### 条款12:复制对象时勿忘其每一个成分

1. 拷贝函数（拷贝构造和拷贝赋值）应该确保复制**“对象内每一个成员变量”**及**“所有base class的成分”**
2. 不要尝试在一个拷贝函数（如拷贝构造）调用另一个拷贝函数（拷贝赋值）。应该将共同机能的**重复代码放入第三个成员函数中**供两个拷贝函数调用。

## 3.资源管理

### 条款13:以对象管理资源(智能指针对象)

资源管理可能出现的问题：当一个工厂函数创建一个我们想要获取的资源对象时，该工厂函数内部会进行**动态内存分配**，所以我们需要手工对该资源进行**释放delete操作**。但可能因为某种异常的发生或提前return函数，导致该资源**没有被回收**造成资源泄漏。

解决的思路：

* 把资源放入对象中进行管理，将释放资源的部分放入析构函数中处理，然后依赖C++的**析构函数**自动调用机制确保资源被释放。（只要函数调用结束，局部变量的对象都会自动调用析构函数）
* 利用智能指针auto_ptr，指向资源对象，当智能指针被销毁时，会调用对象的析构函数进行资源释放

资源管理的两个重要思路：

1. 获得资源后立刻放进**管理对象(智能指针)**内部：工厂函数createInvestment()返回的资源被当作管理对象，智能指针的初值。这种“以对象管理资源”的观念被称为“资源取得时机便是初始化时机（RAII）”
2. 管理对象运用**析构函数确保资源被释放**

智能指针的问题：

* 对于auto_ptr指针指向的对象，不允许**有多个auto_ptr**同时指向一个对象，auto_pte通过拷贝构造函数和拷贝赋值函数复制它们，会进行**管理权的移交，原auto_ptr将会指向空**
    
    ```c++
    std::auto_ptr<Investment> pInv1(createInvestment());
    std::auto_ptr<Investment> pInv2(pInv1);//发生拷贝构造，此时pInv1指向null
    pInv1 = pInv2;//发生拷贝赋值，此时pInv2指向null
    ```
* 为发生正常的复制行为，引入“计数型智慧指针RCSP”。如shared_ptr
* createInvestment()工厂函数返回的“未加工指针”，简直是对资源泄漏的一个明显的漏洞，因为调用者极其容器忘记对这个指针调用delete。我们将在条款18中对这个接口进行修改

### 总结

1. 为防止资源泄漏，请使用**RAII 对象，它们在构造函数中获得资源，并在析构函数中分配资源**
2. 两个常用的**RAII对象**为：管理对象shared_ptr和auto_ptr，其区别主要在于拷贝的过程。

### 条款14:在资源管理类中注意copying的行为

* 并不是所有的资源都是基于堆的（动态内存分配）的资源。这些资源是可以直接使用指针指向它们。所以可以直接使用智能指针进行管理即可,因为智能指针的析构函数**默认调用delete**。
* 有些资源如锁，我们需要**设计一个RAII类**对锁资源进行管理,同样满足RAII规范,在构造过程中获得锁，在析构过程中释放锁(不是通过delete释放的)

```c++
class Lock{
    public:
        explicit Lock(Mutex *pm):mutexPtr(pm){
            lock(mutexPtr);//构造函数中获得锁
        };
        ~Lock(){ 
            unloc(mutexPtr);//析构函数中释放锁
        }
    private:
    Mutex * mutexPtr;
}
```

当一个RAII的对象被复制时会发生什么？

1. **禁止复制**：实现方式见条款6，因为许多RAII对象被复制并不合理
2. 对底层资源使用**“引用计数法”**：实际资源不做拷贝，只递增引用计数，如shared_ptr就是如此。当引用计数为0时删除所指资源。

```c++
    class Lock{
        public:
            explicit Lock(Mutex):mutexPtr(pm,unlock){
                lock(mutexPtr.get());
            }
        private: 
            std::tr1::shared_ptr<Mutex> mutexPtr;//使用shared_ptr
    }

```

这里使用shared_ptr指向锁资源，并传入释放锁的析构函数unlock:

* 所以该类Lock不需要实现析构函数
* 复制mutexPtr时也只是增加锁资源的引用计数而已


* **复制底部资源**：有时候我们需要复制的不是一个指向资源的shared_ptr，只增加其引用计数，而是需要**复制实际的资源**，同时得到一个新的shared_ptr指向该新的资源副本。这属于**深度拷贝**
* **转移底部资源控制权：**同shared_ptr,只不过**底层用auto_ptr**实现，复制时即进行控制权的交接

### 条款15:在资源管理类中提供对原始资源的的访问

**C APIs往往要求访问原始资源（被RAII对象所管理的原始资源），所以每一个RAII class应该提供一个“取得其所管理之资源”的办法**

两个办法：

* 显式转换（不方便，但安全）：为RAII class提供一个get()接口直接返回其管理资源指针
* 隐式转换（方便使用，不安全）：
    - 概念：   
        + 转换构造函数：将其他类型数据隐式转换成本类类型对象
            * 格式：构造函数只有一个参数
        + 隐式转换函数：将本类类型对象转换为指定类型的数据
            * 格式：operator 类型（）｛｝
    - 在对应场景，RAII会隐式转换为原始资源的数据。

### 条款16:成对使用new和delete时要采取相同的形式

new和 delete成对使用，new［］和delete［］成对使用：

* 如果你调用**new**的时候，使用**delete[]**释放内存，由于delete[]寻找数组元素个数的机制为**cookies机制**，配置一块额外的字来存放数大小，再根据该大小来逐个析构元素。但若只有一个元素，delete则有可能**获取到一个未知的数字当作数组大小从而造成不可预知的错误**
* 如果你调用 **new[]**的时候，使用**delete**来释放内存，最后有可能只析构该元素的**第一个元素**，并释放第一个元素的内存而已，其它元素都没有释放

### 条款17:以独立语句将newed对象置入智能指针。

## 4.设计与声明
## 5.实现
## 6.继承与面向对象设计
## 7.模型与泛型编程
## 8.定制new与delete
## 9.杂项讨论
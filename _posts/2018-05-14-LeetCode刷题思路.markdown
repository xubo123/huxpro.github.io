---
layout:     post
title:      "LeetCode题目思路整理"
subtitle:   "LeetCode"
date:       2018-05-14 15:00:00
author:     "Xu"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - LeetCode
---
# LeetCode刷题思路

## 数据搜索及查找(哈希表，二分法)

### 题目1:如何找到两个排序数组的中位数？(LeetCode4:Median of Two Sorted Arrays)

* 描述：给定两个排序的数组a，b长度分别为m，n找出这两个数组的中位数，时间复杂度为O(log(m+n))

假定a,b长度分别大于k，现在选择第k个数（排序后第k个数），先将a的第k/2个元素（a[k/2-1]）和b的第k/2个数进行比较，存在以下三种情况：

1. a[k/2-1] == b[k/2-1],第k个数找到了，就是a[k/2-1]或b[k/2-1]
2. a[k/2-1] > b[k/2-1],第k大的数肯定不可能在b[0..k/2-1]之间，因为小于b[k/2-1]的数包括b[0..k/2-1]（k/2个）以及a[0..k/2-1]（小于k/2个）中的一部分
3. 同上，a[k/2-1] < b[k/2-1],第k大的数肯定不可能在a[0..k/2-1]之间

要是m,n其中有一个长度小于k/2,则取长度和k/2的较小值来进行切割。

## 题目十二：在翻转数组中查找指定数据（LeetCode33: Search in Rotated Sorted Array）

翻转数组在剑指offer中有相关描述，这题也是剑指offer面试题11的很好的延伸，思路利用二分法来进行数据搜索，需要注意的是，如何根据nums[mid]和查找目标target的大小关系进行范围的缩小，分为两种情况：

{% highlight c++ %}

class Solution {
public:
    int search(vector<int>& nums, int target) {
        if(nums.empty()){
            return -1;
        }
        int low = 0,high = nums.size()-1,mid = 0;
        while(low < high){
            mid = (low+high)/2;
            //情况1:中切节点后面的部分不为递增数列
            if(nums[mid]>nums[high]){
                if(nums[mid] > target){
                    if(target > nums[high]){
                        high = mid -1;
                    }else if((target < nums[high])){
                        low = mid + 1;
                    }else {
                        return high;
                    }     
                }else if(nums[mid] < target){
                    low = mid + 1;
                }else{
                    return mid;
                }
            }else if(nums[mid]<=nums[high] ){
            // 情况2:中切节点后面的部分为递增序列
                if(nums[mid] > target){
                    high = mid -1;
                }else if(nums[mid] < target){
                    if(target > nums[high]){
                        high = mid - 1;
                    }else if(target < nums[high]){
                        low = mid +1;
                    }else{
                        return high;
                    }

                }else{
                    return mid;
                }
            }
        }
        //确定最后一个元素是否等于target
        if(nums[low] == target)
            return low;
        
        return -1;
        
    }
};

{% endhighlight %}

### 题目十三：搜索一个数字在一个递增数组（允许数字重复）中出现的范围

返回出现的下标范围［start ，end］，如果不存在返回［-1,-1］

思路：二分法

{% highlight c++ %}
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int low = 0,high = nums.size()-1;
        int mid;
        int start = -1, end = -1;
        vector<int> result;
        if(nums.empty()){
            result.push_back(start);
            result.push_back(end);
            return result;
        }
        //开始二分查找，只要找到就返回
        while(low<high){
            mid = (low+high)/2;
            if(nums[mid] > target){
                high = mid -1;
            }else if(nums[mid] < target){
                low = mid + 1;
            }else{
                start = end = mid;
                break;
            }
        }
        //查看最后的位置是否即为目标数
        if(nums[low] == target){
            start = end = low;
        }
        //确定前后范围
        if(start >= 0){
            while(start>0){
                if(nums[start-1] == target)
                    start--;
                else
                    break;
            }
            
            while(end < nums.size()-1){
                if(nums[end+1] == target)
                    end++;
                else 
                    break;
            }
        }

        result.push_back(start);
        result.push_back(end);
        return result;
    }
};

{% endhighlight %}


### 题目十四： 判断数独二维数组是否合法

* 为什么要把这一题放到数据搜索及查找这一分类？因为判断一个数独数组是否合法可以分解为在纵向列，横向行，及每个子box中寻找重复的数字（1-9），只要有重复的数字就不合法，没有就合法。
* 而寻找重复的数字在剑指offer中有对应的题目：**面试题3，哈希表的思路**

我先介绍自己的思路：利用**三个map**保存每一行，每一列，每个子box是否有效，然后逐个字符来进行判断。

{% highlight c++ %}

class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        map<int,bool> row_map,column_map,box_map;//三个记录每行，每列，每个子 box是否合法的map
        set<char> test_set;
        
        //初始化
        for(int i = 0;i<9;i++){
            row_map.insert(make_pair(i,false));
            column_map.insert(make_pair(i,false));
            box_map.insert(make_pair(i,false));
        }
        //循环遍历二维数组中的每个元素
        for(int i = 0;i<9;i++){
            for (int j = 0;j<9;j++){
                
                //对于每一个元素，先测试所在行是否合法
                if (board[i][j]!='.'){
                    if(!column_map[i]){
                        //还没被测试过，开始测试，如果已经测试为真，则直接跳过
                        for(int k = j;k<9;k++){
                            if(board[i][k]!='.'){
                                if(test_set.count(board[i][k])){
                                    return false;
                                }else{
                                    test_set.insert(board[i][k]);
                                }
                            }
                        }
                        column_map[i] = true;
                    }
                    
                    test_set.clear();//清楚测试集，用于下一个测试

                    //开始测试所在列是否合法，若之前已经被测试过，则直接跳过
                    if(!row_map[j]){
                        //还没测试过，开始检查
                        for(int k = i;k<9;k++){
                            if(board[k][j]!='.'){
                                if(test_set.count(board[k][j])){
                                    return false;
                                }else{
                                    test_set.insert(board[k][j]);
                                }
                            }
                        }
                        row_map[j] = true;
                    }
                    
                    test_set.clear();
                    int index = (i/3)*3 + j/3;
                    //开始测试所在子box是否合法
                    if(!box_map[index]){
                        //开始检查
                        int start_col = (index/3)*3;
                        int start_row = (index%3)*3;
                        for(int col = start_col;col<start_col+3;col++){
                            for(int row = start_row;row<start_row+3;row++){
                                if(board[col][row]!='.'){
                                    if(test_set.count(board[col][row])){
                                        return false;
                                    }else{
                                        test_set.insert(board[col][row]);
                                    }
                                }
                            }
                        }
                        box_map[index] = true;
                    }
                    test_set.clear();
                }
                
            }
        }
        //当所有元素遍历检查结束后没出现不合法情况，则合法
        return true;
        
    }
};

{% endhighlight %}

**哈希表**的思路：分别创建用于测试行，列，子box的三个二维哈希表。

{% highlight c++ %}

class Solution
{
public:
    bool isValidSudoku(vector<vector<char> > &board)
    {
        int used1[9][9] = {0}, used2[9][9] = {0}, used3[9][9] = {0};//三个用于测试的哈希表，初始化为0
        
        for(int i = 0; i < board.size(); ++ i)
            for(int j = 0; j < board[i].size(); ++ j)
                if(board[i][j] != '.')
                {
                    int num = board[i][j] - '0' - 1, k = i / 3 * 3 + j / 3;
                    if(used1[i][num] || used2[j][num] || used3[k][num])
                    //所在位置出现重复，说明所在行，所在列或所在子box有重复的元素，不合法
                        return false;
                    used1[i][num] = used2[j][num] = used3[k][num] = 1;//之前没出现过则将该数值存放到行，列，子box三个哈希表中和数值相等的下标的位置上去。
                }
        
        return true;
    }
};


{% endhighlight %}

### 题目十六：找到第一个未出现的正数（Leetcode41: First Missing Positive）

* 描述：给出一个未排序的整型数组（元素可以重复），找出所有正数1,2,3...开始第一个没出现在该数组中的元素

如：
* \[ 1,2,0 \]:输出3
* \[ -1,3,4,1 \]:输出2

思路： 哈希表，将自身当作一个hash表，遍历这个数组，将每一个数放置到该数对应的下标上去
如果：

    - 出现该数对应的下标超出该数组的范围或者该数为非正数，则和尾部**第一个没有超出**数组大小的数进行互换，互换后尾部的数据则**不用考虑**，且**需要检测**的数组的大小也对应缩小
    - 该数对应的下标的位置上已经有正确的数(**重复**)，同样和数组尾部第一个没有超出数组大小的数进行互换，互换后尾部的数据则不用考虑，且需要检测的数组的大小也对应缩小

所有的数正确安排结束后，则开始从头开始遍历，第一个和下标不能一一对应的数就是第一个没有出现的正数，返回

{% highlight c++ %}

class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        if(nums.empty()){
            return 1;
        }
        int size = nums.size();
        int tmp;
        int end = size;
        for(int i = 0;i<end;i++){
            if(nums[i] != i+1){
                if(nums[i] <= 0||nums[i] > end|| nums[nums[i]-1] == nums[i]){//需要放置到尾部不予考虑
                    while(end-1 > i && nums[end-1] >= end){
                        end--;//在尾部找到第一个合法的数
                    }
                    if(end-1>i){
                        tmp = nums[end-1];
                        nums[end-1] = nums[i];
                        nums[i] = tmp;
                        i--;
                        end--;
                    }
                }else {
                //放置到正确的下标位置
                    tmp = nums[nums[i]-1];
                    nums[nums[i]-1] = nums[i];
                    nums[i] = tmp;
                    i--;
                }
            }
        }
        
        int k = 0;
        while(k<size && nums[k] == k+1){
            k++;//遍历得到第一个没有出现的正数
        }
        return k+1;
    }
};

{% endhighlight %}

## 动态规划

### 题目二：找到最长回文子字符串(LeetCode5:Longest Palindromic Substring)

* 描述：给出一个字符串，找出它的最长且为回文结构的子字符串：如：“babad”的最长子字符串且为回文的子串为"bab",或“aba”,而"cbbd"的最长子串为“bb”

思路1：暴力求解：找出所有可能的子字符串头i和尾j，然后判断是否为回文，复杂度O（N^3）

思路2: 动态规划，用一个二维数组arr记录子字符串是否为回文，横坐标纪录字符串开头i(i < s.zise()),纵坐标纪录结尾j(i<=j< s.size());然后二维数组中纪录的是从i到j的子字符串**是否为一个回文结构**。回文结构由以下三种情况

    * 由**一个字符**组成的回文字符串
    * 由**两个相同的字符**组成回文字符串
    * i到j字符串为回文字符串，则i+1到j也为回文字符串，且s[i] = s[j];

所以根据上述关系arr[i][j]和arr[i+1][j-1]的关系来做状态转换方程构建该二维数组。构建过程的复杂度为O(N^2),然后根据该二维数组找出最长子字符串。空间复杂度也为O(N^2)

思路3(中心扩展，时间复杂度O(N^2),空间复杂度O(1)): 回文结构其实就是以一个点为**中心**，向两边扩展，我们只要找到这**2n-1个中心**（n为字符串的长度）然后两边扩展即可得到回文长度即可。为什么是2n-1个中心，因为中心分为两种：

    * 以一个字符为中心
    * 以两个相同的字符为中心

{% highlight c++ %}
public String longestPalindrome(String s) {
    int start = 0, end = 0;
    for (int i = 0; i < s.length(); i++) {
        int len1 = expandAroundCenter(s, i, i);
        int len2 = expandAroundCenter(s, i, i + 1);
        int len = Math.max(len1, len2);
        if (len > end - start) {
            start = i - (len - 1) / 2;
            end = i + len / 2;
        }
    }
    return s.substring(start, end + 1);
}

private int expandAroundCenter(String s, int left, int right) {
    int L = left, R = right;
    while (L >= 0 && R < s.length() && s.charAt(L) == s.charAt(R)) {
        L--;
        R++;
    }
    return R - L - 1;
}
{% endhighlight %}

思路4（Manacher's Algorithm,O(N)）:

首先将每两个字符串中插入"#",确保每个回文字符串都是奇数形式，以一个字符为中心的回文字符串
```
＃1＃2＃2＃1＃2＃2＃
```
为了防止越界，我们还需要在首尾再加上非#号字符

遍历字符串，当遍历到第i字符时，我们需要在遍历过程中纪录回文串可以延伸到**最右端的端点下标max_right**,和以该端点作为结尾的回文字符串的**中心点ct**。还要纪录以该点为中心点的回文串的长度len[i]

* 假设当我们遍历到ct时，匹配后确定了以它为中心的回文串达到的**右端点为前面所有中心的回文串的最右端点**：max_right。
* 遍历下一个节点j = ct＋1时，len[j] = max_right < j ? min(p[2*ct-j],max_right - j):1;
    - 这个表达式的含义就是当这个下标还在我们前面遍历得到回文串的**最右端点的范围之内**时，根据回文串的映射关系：2*ct-j为j以ct为中心的**映射点**，在ct为中心的回文串范围中，j和2*ct-j的回文串长度应该保持一致，但是出了这个范围，就需要进一步匹配来确定:
    ![LeetCode_1.png](/img/LeetCode_1.png)
    - 遍历过程中需要纪录:回文串**最右端点及中心点**，最长回文字符串的**中心点及长度**。遍历一次更新一次
    - 代码参考：https://www.cnblogs.com/grandyang/p/4475985.html

### 题目三：字符串匹配“.*”(Leetcode10:Regular Expression Matching)
题目链接： https://leetcode.com/problems/regular-expression-matching/description/
描述：给定一个字符串匹配模式pattern，输入一个字符串判断是否与该pattern匹配。

1. '.'代表任意字符
2. 'a*'代表a可以出现0次，1次或任意次
3. '.*'带表任意长度（包括0）任意类型的字符串

思路1：递归

处理这三种匹配情况
1. 碰到字母或'.'时，只要相等就进行下个字符的匹配
2. 碰到*时分两种情况

    * 字符＋‘*’匹配0个字符，1个字符或多个重复字符
    * '.*'匹配0个字符，1个任意字符或多个任意长度的任意类型的字符

{% highlight c++ %}
bool match(string & str,string & pattern,int str_i,int pat_i){
        if(str_i == str.size() && pat_i == pattern.size()){
                return true;
        }
        if(str_i>str.size())
            return false;
        bool result = false;
        if(pattern[pat_i+1]!='*'){
        /*处理非*的情况*/
            if(str[str_i] == pattern[pat_i]||pattern[pat_i] == '.')
                return match(str, pattern, str_i+1, pat_i+1);
            return result;
        }else {
            if(pattern[pat_i] != '.'){
            /*处理字符＋‘*’的情况*/
                result = match(str, pattern, str_i, pat_i+2);//字符＋‘*’匹配0个字符串
                if(result)
                    return result;
                if(str[str_i] == pattern[pat_i])
                    result = match(str, pattern, str_i+1, pat_i+2)||match(str, pattern, str_i+1, pat_i);//字符＋‘*’匹配1个字符串或多个重复字符
                return result;
            }else{
            /*处理‘.*’的情况*/
                result = match(str, pattern, str_i, pat_i+2)||match(str, pattern, str_i+1, pat_i+2)||match(str, pattern, str_i+1, pat_i);;//‘.*’匹配0个字符，1个字符，任意长度的任意类型的字符
                return result;
            }
        }
    };
}
{% endhighlight %}

思路2: 动态规划

用一个二维数组memo[pat_i+1][str_j+1]来记录长度为str_j和长度为pat_i的模版是否匹配
1. 先进行初始化
2. 状态转换方程

    * 碰到pattern[pat_i]为字母或‘.’时
    * 碰到pattern[pat_i]为为‘*’时
        - pattern[pat_i－1]为普通字符时
        - pattern[pat_i-1]为‘.’时
3. 返回memo[pat_i+1][str_j+1]

{% highlight c++ %}

bool match_dp(string & str,string & pattern){
        int str_size = (int)str.size(),pat_size = (int)pattern.size();
        bool ** memo =new bool*[pat_size+1];//二维数组的创建
        for(int i =0;i<=pat_size;i++){
            memo[i] = new bool[str_size+1];
        }
        for(int i = 0;i<=pat_size;i++)
            for(int j = 0;j<=str_size;j++)
                memo[i][j] = false;
        //Initialize初始化
        memo[0][0] = true;
        if(str_size>0&&pat_size>0){
            if(str[0] == pattern[0]||pattern[0] == '.')
                memo[1][1] = true;
        }
        if(pat_size<2){
            return memo[pat_size][str_size];
        }
        //Dynamic Programming，开始进行遍历
        bool result = false;
        for(int i = 2;i<=pat_size;i++)
        {
            for(int j = 0;j<=str_size;j++){
                result = false;
                if(pattern[i-1] == '*'){
                    if(pattern[i-2]!='.'){
                        result =result||memo[i-2][j];//字母＋*匹配0个字符
                        if(str[j-1] == pattern[i-2])
                            result = result || memo[i-2][j-1]||memo[i][j-1];//字母＋*匹配1个字符或多个字符
                    }else{
                    /* 处理情况‘.*’  */
                        result = memo[i][j-1]||memo[i-2][j];//.*匹配一个或多个字符，.*匹配0个字符
                    }
                }else{
                /* 处理情况‘非*’*/
                    if(str[j-1] == pattern[i-1]||pattern[i-1] == '.'){
                        result = memo[i-1][j-1];
                    }
                }
                memo[i][j] = result;
            }
        }
        return memo[pat_size][str_size];
    }

{% endhighlight %}

### 题目十五：计数后用字符串表达（Leetcode38:Count and Say）

有一个字符串的序列，下一项为上一项的计数表达，从"1"开始计数

```
1. "1"
2. "11"  //1个1
3. "21"  //2个1
4. "1211"   //1个2，1个1
5. "111221"   //1个1，1个2，2个1
...
```

按照这个规律，求的第n项的字符串是什么

思路：动态规划，只需要一个字符串记录第n-1项字符串，然后开始计数后写入第n项字符串。

{% highlight c++ %}
class Solution {
public:
    string countAndSay(int n) {
        if(n<=0)
            return NULL;
        string record = "1";//用于记录上一项的字符串
        string tmp;//用于迭代得到本轮字符串
        int count;
        char num;
        if(n==1){
            return record;
        }
        for(int k = 1;k<n;k++){
            for(int i=0;i<record.size();i++){
                num = record[i];
                count = 0;
                while(i<record.size()&&record[i] == num){
                    count++;
                    i++;
                }
                i--;
                tmp.push_back(count+'0');
                tmp.push_back(num);
            }
            record = tmp;
            tmp.clear();
        }
        return record;
    }
};
{% endhighlight %}





## 递归

### 题目八：手机号码的字符串组合（LeetCode17:Letter Combinations of a Phone Numbe）
按手机输入法的格式，输入一串数字，得到所有可能的字符串:
![leetcode_phonenum.png](/img/leetcode_phonenum.png)

简单的递归思路：需要注意的点就是传入参数时，传入引用可以节省大部分运行时间

代码:
{% highlight c++ %}

class Solution {
public:
    map<int,string> num_map = { {2,"abc"},{3,"def"},{4,"ghi"},{5,"jkl"},{6,"mno"},{7,"pqrs"},{8,"tuv"},{9,"wxyz"} };//关联容器的初始化
    
    vector<string> letterCombinations(string digits) {
        string str;
        vector<string> vs;
        if(digits.size() == 0)
            return vs;
        vs = letterCombinations_x(digits,vs,str,0,digits.size());
        return vs;
    }
    vector<string> &letterCombinations_x(string &digits,vector<string> & vs,string &str,int n,int size) {
        if(n == size){
            vs.push_back(str);
            return vs;
        }
        string num_str = num_map[digits[n]-'0'];
        for(int i=0;i<num_str.size();i++){
            string str_tmp = str;
            str_tmp.push_back(num_str[i]);
            letterCombinations_x(digits,vs,str_tmp,n+1,size);//开始递归
        }
        return vs;
    }
};

{% endhighlight%}

## 位运算

### 题目十一：两个整型数做除法，不使用乘除运算符

给两个整数相除，得到除数，但不能使用乘除运算符

要求：

1. 除数和被除数都是32位的整型数
2. 除数不能为0
3. 整型数的范围为：**[-2^31,2^31-1]**,当相除后的结果溢出时，返回2^31-1

思路：使用位运算，逐个将结果中的每一位（二进制位）数求出。将除数向左<<逐个移位与被除数进行比较。

{% highlight c++ %}
class Solution {
public:
    int divide(int dividend, int divisor) {
        //处理边界问题
        long int_max = (2L<<30)-1,int_min = -(2L<<30);
        if(dividend == int_min && divisor == -1){
            return int_max;
        }
        
        long tmp ,res = 0,res_tmp = 0;
        //判断正负号
        bool positive = true;
        if((dividend > 0 && divisor<0)||(dividend < 0 && divisor > 0)){
            positive = false;
        }
        long divd = labs((long)dividend);
        long divs = labs((long)divisor);
        
        
        while(divd>=divs){
            tmp = divs;
            res_tmp = 1;
            while(divd >= (tmp <<= 1))
            {
                res_tmp <<= 1;
            }
            divd -= tmp >> 1;//循环一次，被除数减去一次移位后的除数
            res += res_tmp;
        }
        if(positive)
            return res;
        else
            return -res;
    }
};
{% endhighlight %}

## 其它

### 题目四 ：整型数反转(LeetCode7:Reverse Integer)

将一个整型数的高位和低位进行反转，负数不变号，如果一个整型数反转后溢出后则返回0:

例子：
* 123  ＝》321
* －12 ＝》－21
* －120 ＝》－21

注意点：

* 整型数的范围为 **[-2^31,2^31-1];所以可能出现－2^31在范围内，而它的绝对值却不在整型范围内**
* 要计算2^31次方：long upper = **(2L<<31);//L不能掉**

{% highlight c++ %}
class Solution {
public:
    int reverse(int x) {
        bool positive = true;
        long x2 = (long)x;
        long upper = (2L<<30)-1;
        //处理正负号
        if(x2<0){
            positive = false;
            upper = upper-1;
            x2 = labs(x2);//这里不能用abs，abs无法处理-2^31的绝对值，因为它处理整型数，转换过来的正数会溢出
        }
        if(x2 == 0)
            return 0;
        //处理末端为0的情况
        while(!(x2%10))
            x2 /= 10;
        vector<long> digit;
        while(x2>=10)
        {
            digit.push_back(x2%10);
            x2 = (x2-x2%10)/10;
        }
        digit.push_back(x2);
        long result = 0;
        for(int k = 0;k<digit.size();k++){
            result = result*10 + digit[k];
            if(result>upper){
                return 0;
            }
        }
        if(positive)
            return result;
        else
            return -result;
    }
};
{% endhighlight %}

### 题目五：装水最多的容器(LeetCode11:Container with most water)

描述：给定一个整型数组｛a1,a2,a3...an｝;这些点代表在坐标轴上的n个点，（i，ai）。根据这些点画出垂直于x轴的直线，这些直线中任取两条直线构成一个容器，求两条直线使得构成的容器可以装水的体积最大。

![container_water](/img/container_water.png)

如图灰色部分就是两条加粗的线构成容器的所装水的容量。

思路：两点法，从两端开始front =1 ,back = end,构成容器的大小为size,只要比较这两条直线的长度，在front和back的范围里想要**找到另一条线**和这两条线其中一条构成的容器大于size,则只能和**较长的一端**进行组合，所以我们将**较短的一端向中间移动**找到一条比它长的直线作为容器的一端，然后计算容器大小，如此循环移动直到front和back重合,在这个过程中**记录容器容量的最大值**。

[解法链接](https://leetcode.com/problems/container-with-most-water/solution/)

代码参考：

{% highlight c++%}

class Solution {
public:
    int maxArea(vector<int>& height) {
        if(height.empty()||height.size()==1){
            return 0;
        }
        int front = 0,back = height.size()-1;
        int max_size = (height[back]>height[front]?height[front]:height[back])*(back-front);
        //移动直到两端重合
        while(front<back){
            int front_tmp = front;
            int back_tmp = back;
            int h = 0;
            //向中间移动较短的一端
            if(height[front]>=height[back]){
            //将尾端向前移动
                while(height[back_tmp] >= height[back] && back>front)
                    back--;
                if(height[back_tmp]<height[back]){
                //计算容器大小，记录最大容器容量
                    h = height[back]>height[front]?height[front]:height[back];
                    max_size = h*(back-front)>max_size?h*(back-front):max_size;
                }
                    
            }else{
            //将首段向后移动
                while(height[front_tmp] >= height[front] && back>front)
                    front++;
                if(height[front_tmp] < height[front]){
                    h = height[back]>height[front]?height[front]:height[back];
                    max_size = h*(back-front)>max_size?h*(back-front):max_size;
                }
            }
            
        }
        
        return max_size;
        
    }
};
{% endhighlight %}


### 题目十七：计算容器可以装多少水

描述：给出一个整形数数组，每个数代表一个柱子，柱子的宽度为1，两根柱子之间可以装水，问该数组中的所有数字构成的所有柱子能装多少水？

![rainwatertrap](/img/rainwatertrap.png)

如上图，给出数组[0,1,0,2,1,0,1,3,2,1,2,1],输出：6（装水的容量）

我的解法：笨拙复杂，使用两个栈，一个栈记录高度，一个栈记录该减去的水的容量，其实和标准的使用栈解法的思路类似，只不过思路过于复杂。

* 我的思路和标准解法的思路都是求两根柱子，超出其他矮柱子的高度的部分装的水的容量，这部分的水就只和这两根柱子相关，和其他的柱子没有关系，所以就不会导致重复计算。
    - 但我的思路是先求两根柱子所能装的水的最大容量，然后减去两根柱子中间被其他柱子所影响的容量，这就比较复杂
    - 标准解法的思路就比较直接，直接求超出的高度，计算只与这两根柱子相关的水容量

{% highlight c++ %}
class Solution{
    public:
    int trap(vector<int>& height) {
        if(height.empty()||height.size()==1){
            return 0;
        }
        
        stack<pair<int, int>> height_stack;
        stack<int>  minus_stack;
        int water_tmp = 0,water_sum = 0,water_max = 0;
        int minus_tmp = 0;
        
        for(int i = 0;i< height.size();i++){
            if(height[i]!=0){
                if(height_stack.empty()){
                
                    height_stack.push(make_pair(height[i], i));
                    minus_stack.push(0);
                }else{
                    while(!height_stack.empty()){
                        pair<int, int> pair_tmp = height_stack.top();
                        if(pair_tmp.first > height[i]){
                            minus_tmp = minus_stack.top();
                            water_tmp = height[i]*(i-pair_tmp.second-1)-minus_tmp;
                            water_sum += water_tmp;
                            minus_tmp +=water_tmp;
                            minus_stack.pop();
                            minus_stack.push(minus_tmp);
                            break;
                        }
                        minus_tmp = minus_stack.top();
                        water_tmp = pair_tmp.first*(i-pair_tmp.second-1)-minus_tmp;//只与目前的两根柱子相关的水容量
                        water_max = water_tmp + minus_tmp;
                        water_sum += water_tmp;
                        height_stack.pop();
                        minus_stack.pop();
                        if(!height_stack.empty()){
                            minus_tmp = minus_stack.top();
                            minus_stack.pop();
                            minus_tmp = minus_tmp + water_max + pair_tmp.first;
                            minus_stack.push(minus_tmp);
                        }
                    }
                    height_stack.push(make_pair(height[i], i));
                    minus_stack.push(0);
                }
            }
        }
        
        return water_sum;
    }
};


{% endhighlight %}

* 思路1: 标准的栈解法：

{% highlight c++ %}

int trap(vector<int>& height)
{
    int ans = 0, current = 0;
    stack<int> st;
    while (current < height.size()) {
        while (!st.empty() && height[current] > height[st.top()]) {
            int top = st.top();
            st.pop();//当压入一个数时，会把所有小于该数的数全部弹出栈
            if (st.empty())
                break;
            int distance = current - st.top() - 1;
            int bounded_height = min(height[current], height[st.top()]) - height[top];//求超出的高度部分，必须有三个数参数，两个相邻的数是无法装水的
            ans += distance * bounded_height;//直接计算超出的高度部分所装的水容量
        }
        st.push(current++);
    }
    return ans;
}

{% endhighlight %}

* 思路2: 计算每一根柱子的顶部空间有多少会被淹没在水里，这样计算每根柱子顶部被淹没在顶部的空间，然后累加起来就是整个水的容量。

    - 解法1:暴力计算，为每根柱子计算左右两边的最高的高度，然后用左右最高高度中的较小者减去该柱子的高度，就是该柱子顶部被淹没的空间
    - 解法2:动态规划，先记录每根柱子的左右最高高度到两个vector中，这样可以避免重复计算。

{% highlight c++ %}
//解法1:
int trap(vector<int>& height)
{
    int ans = 0;
    int size = height.size();
    for (int i = 1; i < size - 1; i++) {
        int max_left = 0, max_right = 0;
        for (int j = i; j >= 0; j--) { //Search the left part for max bar size
            max_left = max(max_left, height[j]);
        }//计算左边的最高高度
        for (int j = i; j < size; j++) { //Search the right part for max bar size
            max_right = max(max_right, height[j]);
        }//计算右边的最高高度
        ans += min(max_left, max_right) - height[i];//累加每根柱子顶部别淹没的空间
    }
    return ans;
}

//解法2:

int trap(vector<int>& height)
{
    if(height == null)
        return 0;
    int ans = 0;
    int size = height.size();
    vector<int> left_max(size), right_max(size);
    left_max[0] = height[0];
    for (int i = 1; i < size; i++) {
        left_max[i] = max(height[i], left_max[i - 1]);
    }//记录每根柱子左边的最高高度到left_max
    right_max[size - 1] = height[size - 1];
    for (int i = size - 2; i >= 0; i--) {
        right_max[i] = max(height[i], right_max[i + 1]);
    }//记录每根柱子右边的最高高度到right_max
    for (int i = 1; i < size - 1; i++) {
        ans += min(left_max[i], right_max[i]) - height[i];//累加每根柱子顶部被淹没的部分
    }
    return ans;
}
{% endhighlight %}

思路三：两点法，从两端找到左边最大的和右边最大的，然后两端向中间移动，遇到短的就可以计算水的容量。https://leetcode.com/problems/trapping-rain-water/solution/

{% highlight c++ %}
int trap(vector<int>& height)
{
    int left = 0, right = height.size() - 1;
    int ans = 0;
    int left_max = 0, right_max = 0;
    while (left < right) {
        if (height[left] < height[right]) {
            height[left] >= left_max ? (left_max = height[left]) : ans += (left_max - height[left]);
            ++left;
        }
        else {
            height[right] >= right_max ? (right_max = height[right]) : ans += (right_max - height[right]);
            --right;
        }
    }
    return ans;
}

{% endhighlight %}

### 题目六：罗马数转化为整数（Leetcode13:Roman to Integer）

```
Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```
如上所示，罗马表示数字的字符一一对应，数字规则如下：

* 规则1:较小字符可以放在较大字符前面构成一个数：如IX(10-1 = 9),XLC(100-50-10 = 40)
* 规则2:将一串罗马字符串根据规则1得到若干数字然后进行相加如：“MCMXCIV”,得到数字： M=1000,CM=900,XC=90,IV=4。最后相加结果为：1000+900+90+4 ＝ 1994

思路1：从正面将所有数字分开，然后再一个个相加

{% highlight c++%}
class Solution {
public:
    int romanToInt(string s) {
        if(s.empty())
            return 0;
        int result = 0;
        map<char,int> roman;
        roman['I'] = 1;
        roman['V'] = 5;
        roman['X'] = 10;
        roman['L'] = 50;
        roman['C'] = 100;
        roman['D'] = 500;
        roman['M'] = 1000;
        
        int num = roman[s[0]];
        int size = s.size();
        for(int i = 1;i<size;i++){
            //分割字符串得到数字
            while(i < size && roman[s[i]] >= roman[s[i-1]]){
                if(roman[s[i]] == roman[s[i-1]]){
                    num += roman[s[i]];
                }else{
                    num = roman[s[i]] - num;
                }
                i++;
            }
            //将得到的数字相加
            result+=num;
            num = 0;
            
            if(i<size){
                num = roman[s[i]];
            }
        }
        if(num != 0)
            result+=num;
        return result;
    }
};
{% endhighlight %}

思路2:从反方向来进行遍历，因为字符串构成数字的方向也是从后到前构成的：只有当后面的字符大于前面时才能构成一个数字。
{% highlight c++%}
int romanToInt(string s) 
{
    unordered_map<char, int> T = { { 'I' , 1 },
                                   { 'V' , 5 },
                                   { 'X' , 10 },
                                   { 'L' , 50 },
                                   { 'C' , 100 },
                                   { 'D' , 500 },
                                   { 'M' , 1000 } };
                                   
   int sum = T[s.back()];
   //从后向前遍历即可
   for (int i = s.length() - 2; i >= 0; --i) 
   {
       if (T[s[i]] < T[s[i + 1]])
       {
           sum -= T[s[i]];
       }
       else
       {
           sum += T[s[i]];
       }
   }
   
   return sum;
}
{% endhighlight %}

### 题目七：三个数相加为0(LeetCode15:3Sum)

给定一个数组，从中找到所有可能的三元组，使得这三个加起来的总和为0。

思路1（暴力求解）:首先将数组进行排序，然后**三次循环**遍历确定找到使和为0的三元组。
    - 优化：最后一次循环可以用**关联容器**来确定，将所有的数据放到一个关联容器multiset,在前两次循环后，三元组中的第三个数也就可以确定下来，我们可以直接判断该数是否在multiset存在

**代码见Leetcode15.3Sum**


思路2（O(N^2)）:同样需要先将数组进行排序，然后确定三元组中的**第一个元素**（一次循环），然后我们可以知道后两个元素的和，然后利用**两点法（见剑指offer面试题57:和为s的数字）**,来确定后两个元素的值。

代码（Java）:
{% highlight java%}
public List<List<Integer>> threeSum(int[] num) {
    Arrays.sort(num);
    List<List<Integer>> res = new LinkedList<>(); 
    for (int i = 0; i < num.length-2; i++) {
        if (i == 0 || (i > 0 && num[i] != num[i-1])) {
            int lo = i+1, hi = num.length-1, sum = 0 - num[i];
            while (lo < hi) {
                if (num[lo] + num[hi] == sum) {
                    res.add(Arrays.asList(num[i], num[lo], num[hi]));
                    while (lo < hi && num[lo] == num[lo+1]) lo++;
                    while (lo < hi && num[hi] == num[hi-1]) hi--;
                    lo++; hi--;
                } else if (num[lo] + num[hi] < sum) lo++;
                else hi--;
           }
        }
    }
    return res;
}
{% endhighlight %}

### 题目九:产生所有可能的有效括号组合（Generate Parentheses）

题目描述：给定一个数字n，给出n个括号所有有效的组合方式。如给定3，则输出结果是：

```
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```

回溯法：见剑指offer中机器人的运动范围，这个题目也可以用一样的思路来考虑:

![tracing_back.png](/img/tracing_back.png)

和机器人走格子类似，横坐标是'('的已使用个数，纵坐标是')'的已使用个数，机器人走到的每一个格子都必须满足横坐标x>=纵坐标y。求有多少条路径满足从start走到end格子。

回溯法和递归的区别：

* 回溯不断调用自身，调用到最后即得到问题的答案。(将问题不断深入，穷尽每一种可能)
* 递归则是不断调用自身，直到最小问题得到解决后，在通过**不断返回**解决大问题，返回到第一次调用的函数才得到答案。（将问题不断分解，解决最小问题，再逐个解决大问题，最后得到整个问题的答案。）

本题代码：
{% highlight c++ %}

class Solution {
public:
    vector<string> generateParenthesis(int n) {
        string str = "(";
        vector<string> result;
        generateParenthesis_x(result,n-1,n,str);
        return result;
        
    }
    
    void generateParenthesis_x(vector<string> & vec,int s_count,int e_count,string &str){
        if(s_count<e_count&&s_count>0){//两个方向
            string tmp1 = str;
            tmp1.push_back('(');
            generateParenthesis_x(vec,s_count-1,e_count,tmp1);
            string tmp2 = str;
            tmp2.push_back(')');
            generateParenthesis_x(vec,s_count,e_count-1,tmp2);
            return;
        }else if(s_count<e_count&&s_count==0){//一个方向
            string tmp3 = str;
            tmp3.push_back(')');
            generateParenthesis_x(vec,s_count,e_count-1,tmp3);
        }else if(s_count==e_count&&s_count>0){//一个方向
            string tmp4 = str;
            tmp4.push_back('(');
            generateParenthesis_x(vec,s_count-1,e_count,tmp4);
        }else{
            vec.push_back(str);//走到end
        }
        
    }
};

{% endhighlight %}

## 题目十：合并k个排序链表（Leetcode23: Merge k Sorted Lists）

将k个排序链表合并成一个排序链表：

```
Input:
[
  1->4->5,
  1->3->4,
  2->6
]
Output: 1->1->2->3->4->4->5->6
```
解决方法：https://leetcode.com/problems/merge-k-sorted-lists/solution/

思路1：用优先级队列，或红黑树实现的multimap结构保存每条链表的第一个元素，然后从这些元素中获取最小值（基于multimap或优先级队列很容易实现）插入新的链表。

PS:注意当创建来的链表为空时的处理

代码：

{% highlight c++ %}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        multimap<int,ListNode*> first_map;
        ListNode* new_list = NULL;
        ListNode* cur= NULL;
        ListNode* cur_ptr = NULL;
        for(int i=0;i<lists.size();i++){
            if(lists[i]!=NULL)
                first_map.insert(make_pair(lists[i]->val,lists[i]));
        }
        //初始化链表头
        if(!first_map.empty()){
            auto iter0 = first_map.begin();
            new_list = cur = new ListNode(iter0->first);
            cur_ptr = iter0->second;
            first_map.erase(iter0);
            if(cur_ptr->next!=NULL){
                first_map.insert(make_pair(cur_ptr->next->val,cur_ptr->next));
        }
        //每获取一个最小值，需要将对应链表下一个最小值添加到map中来
        while(!first_map.empty()){
            auto iter = first_map.begin();
            ListNode *tmp = new ListNode(iter->first);
            cur->next = tmp;
            cur = tmp;
            cur_ptr = iter->second;
            first_map.erase(iter);
            if(cur_ptr->next!=NULL){
                first_map.insert(make_pair(cur_ptr->next->val,cur_ptr->next));
            }
            
        }
        }
        
        return new_list;
    }
};
{% endhighlight %}

思路2:暴力求解，逐个将两条链表合并成一条，直到所有链表都被合并

思路3:归并法，将所有链表分为两两一组，然后合并之后，继续分组合并。。直到最后合并成一条链表


---
layout:     post
title:      "计算机操作系统"
subtitle:   "操作系统的精髓和原理"
date:       2018-03-25 15:00:00
author:     "Xu"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - 计算机操作系统
---
# 第一章、计算机系统概述

## 1.基本构成
计算机四大组件：

* 处理器
* 内存
* 输入/输出模块
* 系统总线

![four_component](/img/four_component.png)

* PC = 程序计数器
* IR = 指令寄存器
* MAR = 内存地址寄存器
* MBR = 内存缓存寄存器
* I/O AR = 输入／输出地址寄存器
* I/O BR = 输入/输出缓存寄存器

## 2.指令的执行

指令周期分为两步：

* 取指阶段
* 执行阶段

![cmd_exe](/img/cmd_exe.png)

PC->IR:程序计数器PC保存每个指令的地址，每执行完一个指令，程序递增，指到下一条指令。取出该指令后寄存到指令寄存器IR。

指令（16位）：4位操作码＋12位数据地址；指令主要分为四类

* 处理器<－>存储器
* 处理器<->I/O
* 数据逻辑计算处理
* 控制指令，改变指令执行顺序

## 3.中断

目的：用于提高处理器效率的手段，防止一个设备或程序垄断CPU资源。

分类：
* 程序中断：指令执行的过程引起的中断，如算法溢出，除数为0等
* 时钟中断：处理器内部的计时器产生，允许操作系统定时执行某个函数
* I/O中断：I/O控制器产生
* 硬件失效中断

当加入中断时，指令周期将会添加一个步骤：中断阶段

![cmd_exe2](/img/cmd_exe2.png)

## 4.中断处理

中断处理流程：

1. 设备－>处理器发送中断信号
2. 处理器结束当前执行的指令
3. 处理器向设备发送确认信号，允许设备取消中断信号
4. 处理器将控制权移交到中断处理程序，并保存当前程序的信息（程序状态字PSW和程序计数器PC）。
5. 将中断处理程序的入口地址压入到程序计数器PC

6. 除了PSW和PC，还需要保存其它的一些信息如**寄存器**等
7. 中断处理程序开始处理中断
8. 中断处理结束，保存的寄存器的值进行恢复
9. 恢复PSW和PC的值，回到之前的程序

![interrupt](/img/interrupt.png)

被中断程序的信息保存包括程序状态字，程序计数器，寄存器信息等保存到**控制栈**中去。
 
![interrupt_save](/img/interrupt_save.png)

### 多个中断

处理多个中断同时发生时处理办法有两种：

1. 当正在处理一个中断时，禁止发生其它中断
2. 定义中断优先级，允许高优先级的中断打断低优先级的中断

![multi_interrupt](/img/multi_interrupt.png)

## 5.存储结构

![storage](/img/storage.png)

从上往下：

* 价格递减
* 容量递增
* 存取时间递增
* 处理器访问存储器频率递减

## 6.高速缓存
高速缓存是为了解决**处理器速度和内存速度严重不匹配**的问题，使得处理器的速度尽量不受到存储周期的影响。所以利用**局部性原理**来提升处理器速度

![cache](/img/cache.png)

上图中的高速缓存通常会多级使用，分为一级缓存L1，二级缓存L2，三级缓存L3

* 速度：L1>L2>L3
* 容量：L1<L2<L3

为了方便缓存到内存的映射:

![cache_memory](/img/cache_memory.png)

* 内存可视为有一个个固定大小的**块（block）**组成。每个块包含有K个字。
* 高速缓存则可视为由一个个**槽（slots）**组成，每个槽中有K个字
* 一个槽映射一个块，但这个映射关系是为变动的，所以每个槽有一个**标签**标示当前存储的是哪个块,标签通常是地址的较高的若干位，**表示以这些位开始的地址**。

高速缓存读取操作：
![cache_read](/img/cache_read.png)

针对高速缓存的设计有一系列问题需要解决：

* 尺寸问题：高速缓存大小和块大小
* 映射函数：内存中的块要存放在高速缓存中的哪个单元
* 置换算法：若高速缓存中的所有存储槽满后，新块到来时该置换掉哪个块（例如LRU最近最少使用算法）
* 写策略：当缓存中的数据别修改时，如何将其写回内存。

## 直接内存存取DMA

执行I/O操作有三种方式：

当处理器执行程序需要I/O操作时，要给相应I/O模块发送指令

* **可编程I/O操作**：I/O模块执行请求的动作并设置I/O的状态，不会通知处理器，处理器需要不断询问I/O操作是否完成,由**I/O模块完成数据传输**
* **中断驱动I/O**:当I/O模块准备好与处理器交换数据时，它将打断处理器的执行并请求服务，然后由**处理器来执行数据传送**
* **直接内存存取**：处理器给DMA模块产生一条命令，发送读写相关的信息，然后**DMA和存储器直接交互完成数据传输**，每次传送一个字。数据传输结束后，DMA将给处理器**发送一个中断信号**提示传输结束 ,相较于前两种处理器需要控制传输过程方法，DMA**不需要处理器去干预**数据传输的过程，只有在数据传输开始和结束时，处理器才会参与


# 第二章、操作系统概述

## 目标和功能
操作系统是**控制应用程序执行的程序，是应用程序和计算机硬件间的接口**,操作系统可以**理解为资源的统一抽象表示**,他有三个目标：

1. 方便： 使计算机更方便使用
2. 有效：以更有效的方式使用计算机资源
3. 扩展能力：有效开发、测试、引入新的系统功能

操作系统的基本职责是控制进程的执行，包括交替执行的方式和给进程分配资源
## 操作系统的发展

1. 串行处理：每个程序都需要人工装载
2. 简单批处理系统，计算机操作员将一批任务组合在一起交给计算机处理，计算机处理完一个任务后会自动装在下个用户程序
3. 多道批处理：当处理器处理一个任务时，发生中断需要等待I/O操作，当内存空间可以容纳两个甚至多个用户程序时，这时可以将处理器切换到另一个用户程序执行。
4. 分时系统，将时间分成时间片，每个时间片分给不同的用户使用，使得多个用户可以同时通过中断使用处理器

## 现代操作系统

* **微内核**体系结构：只给内核分配一些**最基本的功能，包括地址空间，进程间通信和基本的调度**，其它的操作系统服务则由允许在**用户模式**且与其它应用程序类似的进程提供（对应**大内核**，包括调度，文件系统，网络，设备管理器，存储管理等功能的内核）
* 多线程：把执行一个应用程序的进程划分为可以同时运行的多个线程。

- - **线程：可分派的工作单元。包括处理器上下文环境，栈中自身的数据区域，线程顺序执行且可以中断，因此处理器可以转到另一个线程**

- - **进程：一个或多个线程和相关系统资源（如包含数据和代码的存储器空间，打开的文件和设备）的集合**

* 对称多处理(SMP)：具有**多个处理器**，可以将进程或线程调度到所有的处理器上运行
* 分布式操作系统：多机系统具有单一的内存空间，外存空间等
* 面向对象设计：用于给小内核增加模块化的扩展


# 第三章.进程

## 1.什么是进程

进程有如下定义：
* 一个正在执行中的程序
* 一个正在计算机上执行的程序实例
* 能分配给处理器并由处理器执行的实体
* 由**一组执行的指令，一个当前状态和一组相关的系统资源**表征的活动单元

也可以把进程看作是由一组元素组成的实体，进程可以视为**程序代码**和与代码相关联的**数据集**以及**进程控制块**组成

进程控制块：由操作系统创建和管理，进程控制块包含了充分的信息，因此可以根据控制块来实现进程的中断，然后恢复进程的执行。

![ps_control](/img/ps_control.png)

## 2.进程的状态
### 2.1进程的创建

将一个新进程添加到正在被管理的进程集中去:

1. 操作系统需要建立用于**管理该进程的数据结构**
2. 并在内存中给他**分配地址空间**
3. 然后**初始化进程控制块**
4. 并设置正确的连接**保存到相应队列**。

### 2.2五状态模型

运行态：正在被处理器执行的进程的状态，如果只有一个处理器则同时最多只有一个进程处于运行态。
就绪态：进程做好了准备。只要有机会就开始执行。
阻塞／等待态：进程在某些事件发生前不能执行，如I/O操作完成
新建态：刚刚创建的进程，操作系统还未把它加入到可执行进程组，通常是进程控制块已经被创建但还没有加载到内存中的新进程。
退出态：操作系统从可执行进程组中释放出的进程，要么它自身已停止要么它因某种原因被取消。

![five_state](/img/five_state.png)

新建态意味着操作系统已经执行了**创建进程的必须动作**，但未执行的进程状态，因为有时候可能会因为**性能不高或内存不足**限制系统中的进程数量，但进程本身没有进入内存，系统所需的该进程的**系统信息保存在内存的进程表**中，但进程本身还未进入内存。也就是说即将执行的**程序代码不在内存中而是在外存保存**

进程退出也分为两步，首先，进程被终止，进入退出态，此时不再执行进程，与作业相关和其他信息会**临时被操作系统保留**，实用程序可能为了分析性能和利用率需要**提取进程的历史信息**，这些**信息提取完后，操作系统就会删除该进程以及该进程相关的数据**

**运行态－>就绪态**： 1）**超时**，超过了分配给它的最长时间段  2)**抢占**，优先级高的抢占优先级低的进程

为了方便进程管理，我们可以用**多个队列**来维护进程的状态，每个队列对应**不同的事件和不同的优先级**，可以使得处理器迅速找到下一个应该执行的进程。

**这些队列中维护的信息就是每个进程的控制块信息**

![block_queue](/img/block_queue.png)

其中多个队列，每个队列对应不同的阻塞等待的事件。

### 2.3引入“挂起态”的进程模型

为何引入挂起态的原因：就是为了腾出内存空间

* 由于处理器速度远快于I/O速度，为了充分利用处理器而不让处理器处于“空闲状态”，**防止多个进程都在等待I/O的状态**，我们可以通过两个方式解决这个问题：
* * **增加内存空间**，使多道处理的程序尽可能多，但限制于内存的价格
* * **交换**，即把内存中某个进程的一部分或全部移出磁盘，**换出到挂起队列**。此后操作系统要么**从挂起队列中取出另一个进程**，要么接收一个**新进程**的请求放入内存运行

![hang_up](/img/hang_up.png)

只要是在挂起的状态，进程就在外存中，还没有加载到内存。

- 就绪／挂起－>就绪：1) 当没有就绪态程序时，需要调入一个进程继续执行时 2) 或者当处于就绪/挂起的进程优先级更高时。
- 就绪－>就绪／挂起：1）一般都是**选择挂起阻塞态的进程**，但是如果释放空间以得到足够空间的**唯一方法**是挂起一个就绪态进程，也会出现这种转换。2）操作系统确信**高优先级**的阻塞态进程会**很快就绪**，也会选择去挂起一个**低优先级**的就绪态的进程
- 新建－>就绪／挂起：进程创建需要为其分配内存空间，但没有足够的内存空间时会进行这种转换
- 阻塞／挂起－>阻塞：如果一个进程终止，释放了一些内存，此时阻塞/挂起进程的**优先级比所有的就绪状态进程的优先级都高**，操作系统还确信该**阻塞的事件会很快发生**，会进行这种转换
- 运行－>就绪／挂起：如果位于**阻塞／挂起队列**中的具有**较高优先级**的进程变得不再阻塞，操作系统**抢占这个进程**并直接把这个进程转换到就绪／挂起，因为内存空间依然不足。

## 3.进程的描述
操作系统是管理资源的实体，操作系统如果要**通过进程并管理资源**，操作系统需要哪些信息？这些信息就叫做进程的描述。

操作系统管理进程和资源，必须掌握每个进程和资源的当前状态，普遍采用的方法是**操作系统构造并维护其管理的每个实体的信息表**。这些表大致分为四类：

*  内存表:用于跟踪内（实）存和外（虚）存，内存某些部分留给**操作系统使用**，剩余部分给进程使用
*  I/O表：管理I/O设备和通道
*  文件表:提供文件是否存在，文件在外存中的位置，当前状态和其它属性的信息
*  进程表：内存，I/O和文件是代表进程而被管理的，所以进程表中必须有这些资源的**直接或间接引用**

![control_table](/img/control_table.png)

### 进程控制结构
操作系统在管理和控制进程是，首先要知道**进程的位置**，然后要知道**进程的属性**

* **进程位置**：进程的物理表示其实就是**一段内存空间**，该内存空间里面包含了要执行的**代码和所需的数据**

所以我们常用**进程映像**来描述一个进程，包括：**程序、数据、栈和进程控制块**。在最简单的情况下，进程映像一般保存在**连续的内存块**中，但当引入虚拟内存后，存在**分页内存**来支持进程映像。

![ps_iso](/img/ps_iso.png)

进程映像结构：

![ps_iso_consturct](/img/ps_iso_consturct.png)

* **进程属性**：操作系统将会用到的信息，这里分为三类
* * 进程标识信息：进程标识符可以简单理解为**主进程表的索引**，内存表和一些其它的表可以**使用这些进程标识符**来构建和进程的映射关系，如进程的**内存映射**。标识信息还包括，父进程标识符，用户标识符。
* * 进程状态信息：处理器状态信息，运行一个进程时，它的相关状态信息一定会保存在一组成为程序状态字的寄存器中。
* * 进程控制信息：调度和状态信息（进程状态，优先级，调度相关信息如调度算法，事件），数据结构，进程间通信，进程特权，存储管理，资源所有权和使用情况

## 4.进程控制

### 4.1执行模式

大多数处理器支持两种执行模式：

* 用户态
* 内核态：访问指定内核内存，可以完全控制所有指令，寄存器和内存

使用这两种模式可以保护操作系统的结构不受用户程序干扰

程序如何知道它处于什么模式？如何改变该模式？
* 程序状态字中存在一个指示执行模式的位，该位会随着事件的改变而变化。
* 进入内核态 ：调用操作系统服务或中断触发系统例程时
* 进入用户态：系统服务返回到用户进程时

### 4.2进程创建
之前有提过，见书P88

### 4.3进程切换

在发生**系统中断**和**系统调用**的时候，会将控制权交给操作系统：

* 系统中断分为两类：
* * 中断：与当前正在运行的程序无关的某种**外部事件**相关引起的，如**时钟中断，I/O中断，内存失效**
* * 陷阱：与当前指令执行相关，处理一个错误或异常。1）系统首先判断错误和异常是否致命，若是，则进程被换出到退出态，发生进程切换    2)若不是，则看操作系统的设计，可能进行进程切换也可能继续执行
* 系统调用：转移到操作系统代码一部分的一个例程上执行，通常，使用系统调用会将进程置为阻塞态
 
**模式切换**：部分中断发生时，控制权交给操作系统，**执行完中断处理程序后继续执行正在运行的程序，不需要改变运行态状态**，保存上下文和恢复上下文只需要**很小的开销**
**进程切换**：部分中断发生时，如时钟中断，控制权先交给操作系统，当前进程的事件片已经用完，需要**调度另一个进程**，所以需要进行**进程切换**，将**进程的状态**进行改变，此时操作系统需要让处理器等环境发生实质性变化。

进程切换的步骤：

1. 保存处理器上下文环境（程序计数器和其它寄存器）
2. 更新当前处于运行态进程的进程控制块，包括修改进程状态
3. 将进程控制块移到相应队列
4. 经过调度，选择下一个要运行的程序
5. 更新所选择的进程状态和进程控制块信息
6. 更新内存管理数据结构
7. 载入该选择进程的程序计数器和其它寄存器先前的值，处理器也恢复为之前的上下文。

>**进程切换一定有模式切换；模式切换不一定有进程切换**（中断会发生模式切换，但是在大多数操作系统中，中断的发生并不是必须伴随着进程的切换的。可能是中断处理器执行之后，当前正在运行的程序继续执行）；

# 第四章.线程

## 1.进程和线程

* 进程是操作系统进行**资源分配**的基本单位，所有**线程共享进程状态和资源**（相当于一个进程隔离一片资源视图）
* 线程是**调度**的基本单位，从处理器切换进程状态和调度的视角来区分

为什么进程和线程难以区分？因为在**单线程方法**的处理模式中，线程的概念还没有被提出来，一个进程就是资源和调度的基本单位，后来**多线程方法**出现后支持一个进程中有**多个线程并发执行**的能力。从而进程和线程一直难以区分。

线程共享进程的状态和资源，线程都驻留在同一地址空间中，进程和线程关系如下：

![thread_model](/img/thread_model.png)

从性能上比较，线程具有如下优点：
1. 在一个进程中创建新线程的时间远少于创建一个新进程的时间
2. 终止线程要比终止进程花的时间少
3. 同一进程内线程间切换的时间要少于进程间切换的时间
4. 线程提高了不同执行程序间通信的效率，同一进程中的多个线程共享文件和内存无序通过调用内核就可以实现

使用线程的场景：1)前台和后台  2)异步处理   3）执行速度  4)模块化程序结构

## 2.线程分类
**线程状态**：**就绪态，运行态，阻塞态**（当一个线程需要等待另一个线程执行完毕才能继续执行时进入阻塞态），（挂起态对于线程没有意义，因为是共享内存空间）

线程的**实现**分为两大类：
* 用户级线程：有关线程的管理工作都由应用程序完成（使用线程库），内核意识不到线程的存在
* 内核级线程：有关线程管理的工作都由内核完成，应用程序部分没有进行线程管理的代码
![thread_class](/img/thread_class.png)

### 2.1用户级线程

在用户级线程中，进程和线程的状态切换可能有如下过程：
![user_thread](/img/user_thread.png)


* a)->b)：**线程2中执行的应用程序代码进行系统调用，阻塞了进程B**。例如，进行一次I/O调用。这导致控制转移到内核，内核启动I/O操作，把进程B置于阻塞状态，并切换到另一个进程。在此期间，根据线程库维护的数据结构，进程B的线程2仍处于运行状态。值得注意的是，从处理器上执行的角度看，线程2实际上并不处于运行态，但是在线程库看来，它处于运行态
* a)->c)：**时钟中断把控制传递给内核**，内核确定当前正在运行的进程B已经用完了它的时间片。内核把进程B置于就绪态并切换到另一个进程。同时，根据线程库维护的数据结构，进程B的线程2仍处于运行态
* a)->d)：**线程2运行到需要进程B的线程1执行某些动作的一个点**。此时，线程2进入阻塞态，而线程1从就绪态转换到运行态。进程自身保留在运行态

前两种情况下，内核切换进程之间的调度对线程来说是不可见的，虽然进程及内部的线程都是阻塞的，但对于进程内的其它线程来说，该线程依然是运行态，只要进程切换回来时，该线程继续执行。

* * **线程调度**：在进程内部的调度，状态的切换都是相对于进程内部所有的线程而言的，不关心进程外部的其它线程，所以处理器调度是从**进程的角度来进行调度**，它**执行的内容却是具体到进程中的线程**中去，处理器只要调度处理合适的进程，而**具体执行该进程中哪一个线程就由线程调度来决定**。比如进程A中的线程2正在运行，当线程2需要进行系统调用时，会将进程A置于阻塞态，但线程2依然是运行态，只有当线程2运行到该进程内部其它的线程1需要执行时才会变为阻塞态。因为它的状态只相对内部线程视角来看的
* * **进程调度**：：**处理器进行调度的视角是从进程的视角进行调度的，但处理器处理的基本单位却是具体的线程**

**用户级线程优点**：

1. 进程内部切换线程不需要进行模式切换，不需要进入内核态，节省了两次模式切换的时间
2. 调度只需应用程序相关，算法可以量身定做而不会扰乱底层操作系统的调度程序
3. 可以在任何操作系统上执行

**用户级线程缺点**：

1. 用户级线程执行系统调用时，不仅该线程被阻塞，该进程内的所有其它线程也会被阻塞
2. 一个多线程应用不能使用多处理技术，因为内核一次只能把一个进程分配给一个处理器，所以该进程内部的线程一次只能执行一个，不能并发执行。

### 2.2内核级线程
内核能意识到线程的存在，所有线程的调度和管理都由内核完成

**内核级线程优点**：

1. 多处理技术：内核可以用**多个处理器**同时处理一个进程内部的多个线程，因为线程由内核管理
2. 如果进程中内部的一个线程阻塞了，可以**切换到该进程内部的其它线程执行**
3. **内核例程自身**也可以使用该多线程技术

**内核级线程缺点**：

1. 在把控制权从一个线程切换到**同一个**进程内的线程时需要进行**两次状态切换**，先切换到内核态，再回到用户态。

### 2.3混合方案

混合使用用户级线程和内核级线程，克服两种实现的缺点，利用两种方法的优点。

# 第五章.并发性

操作系统设计的核心问题是进程和线程的管理，管理过程中的问题的基础是并发的问题，并发是所有问题的基础，也是操作系统设计的基础，并发包括很多设计问题：**进程间通信、资源共享和竞争，进程活动的同步、进程分配处理器时间等**

要想解决并发的问题，我们首要需求就是赋予进程互斥的能力，而如何提供互斥的能力是通过三种方法来实现的：

* 信号量
* 管程
* 消息传递

一些并发相关的术语解释：

![concurrency](/img/concurrency.png)

* 共享代码区域规则：一次只允许一个进程进入该共享代码区域
* 竞争条件：当两个进程想要同时修改更新一个数据，需要进行竞争，竞争的"失败者"将决定该数据最终的值。

进程的交互分为三类：
* 进程之间相互不知道对方的存在（资源竞争）：他们不会一起工作，操作系统需要知道他们**对资源的竞争情况**
* 进程间接知道对方的存在(共享合作)：通过**共享某些对象**，但不知道对方ID，如共享I/O缓冲区，有合作行为
* 进程间直接知道对方存在（通信合作）：通过**ID直接通信**，合作完成某种活动，合作行为

![ps_interactive](/img/ps_interactive.png)

* **进程间资源竞争**：进程不知道其它进程的存在，当访问**某些资源（这类资源包括I/O设备，存储器，处理器，时钟）**时，要和其它进程竞争，而在不知道其它进程的前提下能够竞争资源，我们就**必须要为进程赋予互斥能力**。这类不可共享的资源为**临界资源**，访问临界资源的代码称为**临界区**。而引入互斥后我们随之产生两个额外的问题：**死锁和饥饿**
* **进程间通过共享合作**：进程可能使用冰**修改共享变量数据（不同于资源，这里的数据是在代码级别的数据）**，并且知道其它进程也会访问同一数据，所以需要合作确保共享的数据得到正确的管理。由于数据是存储在**资源设备**上的，所以也会涉及到**互斥，死锁和饥饿**的问题，除此之外还有一个新要求:**数据一致性**
* **进程通过通信合作**：由于在通信的过程中，进程间没有共享任何对象，所以**不存在互斥现象**，但是会存在**死锁和饥饿**的现象，（死锁：两个进程都被阻塞，每个都在等待来自对方的通信。饥饿：P3想和P1通信，P1一直在和P2交换信息，导致P3一直阻塞处于饥饿状态）



## 1.1互斥的硬件支持
**1）中断禁用（只对单处理器有效）**：为保证互斥，只需要在访问临界区时保证一个进程不被中断即可

{%highlight c%}

while(true){
   /*禁用中断*/
   /*临界区*/
   /*启用中断中断*/

}

{%endhighlight%}

问题：
* 处理器被限制只能交替执行程序，执行效率明显降低
* 不能用于多处理器结构

**2)专用机器指令**:由于多处理器之间的行为是无关的，表现出一种对等关系，**没有支持互斥的中断**即止，所以我们需要在硬件级别上设计**一些机器指令**，在硬件的层次实现对数据的**原子性操作**，从而达到**互斥**的目的。

最常用的两种指令：

* 比较和交换指令（原子执行）：compare&swap，测试word是否为测试值testval，是则返回true，并修改word，实现互斥
* exchange指令(原子执行)：交换bolt到寄存器中来do while测试是否为0，为0进临界区，不为0则继续do while循环测试

自旋等待：进程在得到临界区访问权之前只能继续执行测试变量的指令来得到访问权，进入临界区的进程选择取决于哪个进程正好执行compare_and_swap来进行测试。



```c++
/*比较和交换指令*/
int bolt;
void P(int i)
{
    while(true){
        while(compare_and_swap(bolt,0,1) == 1)//测试bolt是否为0，为0则进入临界区，并将bolt设为1实现互斥
            /*不做任何事*/;
        /*临界区，访问临界资源*/
        bolt = 0;//访问临界资源结束后，恢复该信号量为0
        /*其余部分*/
    }
}

int compare_and_swap(int *word,int testval,int newval)//测试word是否为测试值testval，是则返回true，并修改word，实现互斥
{
    int oldval;
    oldval = *word;
    if(oldval == testval) *word = newval;
    return oldval;
}

/*交换指令*/
int bolt;
void P(int i)
{
    int keyi = 1;
    while(true){
        do exchange (&keyi,&bolt);//通过交换操作将bolt值放入到keyi
        while(keyi != 0);//测试keyi，如果等于0则可以进入临界区，不等于零则不断do while循环测试
        /*临界区*/
        bolt = 0;
        /*其余部分*/
    }
}

void exchange (int *register.int *memory)
{
    int temp;
    temp = *memory;
    *memory = *register;
    *register = temp;
}
```

缺点:

* 使用忙等待（进入临界区之前会一直循环检测，会浪费处理器时间）
* 可能饥饿（存在一些忙等的进程一直无法进入临界区）
* 可能死锁（P1在临界区中被高优先级进程P2抢占，此时P2请求该临界区请求不到，因为P1还没有释放）


## 1.2互斥的软件支持

软件支持包括操作系统和用语提供并发性的程序语言机制，常见并发机制如下：

![concurrency_mechanism](/img/concurrency_mechanism.png)

### 1） 信号量
非二元信号量也称为计数信号量或一般信号量

基本原理：两个或多个进程同时操作信号量，根据信号量信息得到资源的使用情况。

实现：可以把信号量视为一个具有整数值的变量，定义三个操作：

1. 一个信号量可以初始化为非负数
2. semWait:操作使得信号量减一（说明要**等待使用相关资源**），若值变为**负数，说明资源正在被使用**，故**阻塞**发起semWait操作的进程。否则直接使用该资源。**负数的绝对值为阻塞队列中的进程数量**
3. semSignal:操作使得信号量加一（说明资源使用完毕后**释放资源**），若值依然为**小于等于0，说明有进程正在等待使用该资源**，所以解除发起semWait的进程阻塞状态，使其获得资源的使用权,只要**发起semSignal信号，就会唤起另一个进程**，解除阻塞的进程要没有要么为1。

信号量原语（原子操作）的定义：


```c++
struct semaphore{
    int count;
    queueType queue;//阻塞队列
};

void semWait(semaphore s)
{
    s.count--;
    if(s.count < 0){
        /*把当前进程插入到队列当中*/;
        /*阻塞当前进程*/;
    }
}

void semSignal(semaphore s)
{
    s.count++;
    if(s.count <= 0){
        /*把进程P从队列中移除*/;
        /*把进程P插入到就绪队列*/;
    }
}

```

### 1） 二元信号量
二元信号量有更为严格的形式，二元信号量只能是0或1，具有三个操作：

1. 二元信号量可以被初始化为0或1
2. semWaitB操作检查信号的值，为0则阻塞，为1，则执行并将信号改为0。
3. semSignalB操作检查队列是否有进程受阻，有则唤醒，没有则将信号设置为1

```c++
struct binary_semaphore{
    enum {zero,one} value;
    queueType queue;
};

void semWaitB(binary_semaphore s)
{
    if(s.value == one)
        s.value = zero;
    else{
        /*把当前进程插入到队列当中*/;
        /*阻塞当前进程*/;
    }
}

void semSignalB(binary_semaphore s)
{
    if(s.queue is empty())
        s.value = one;
    else{
        /*把进程P从等待队列中移除*/;
        /*把进程P插入到就绪队列*/;
    }
}
```

与二元信号量相关的一个概念就是互斥锁：

* 二元信号量：多个进程同时操作信号量，根据信号量协调合作，可能出现一个进程对信号量进行加锁，另一个进程可以对该信号量进行解锁
* 互斥锁：只能是同一个进程来对互斥量进行加锁和解锁操作。

*  强信号量：队列设计为FIFO，被阻塞最久的进程最先从队列中释放（保证不会饥饿）
*  弱信号量：没有规定进程从队列中移出顺序

### 使用信号量实现互斥

```c++
const int n = /*进程数*/
semaphore s = 1;

void P(int i)
{
    while(true){
        semWait(s);//请求信号
        /*临界区*/;
        semSignal(s);//释放信号
        /*其它部分*/;
    }
}

void main()
{
    parbegin(P(1),P(2),...,P(n));
}

```









---
layout:     post
title:      "Unix网络编程：套接字API"
subtitle:   "Unix网络编程"
date:       2018-05-07 12:00:00
author:     "Xu"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - Unix网络编程
---
# Unix网络编程：套接字API

## 第一章 传输层TCP,UDP和SCTP

TCP/IP协议概貌：

![unix_socket_1](/img/unix_socket_1.png)

### 1.1SCTP:流控制传输协议
SCTP在客户和服务器之间提供关联，并像TCP那样给应用层提供可靠性，排序，流量控制以及全双工的数据传输服务。SCTP使用“关联”取代“连接”是为了避免：一个连接只涉及到两个IP地址之间的通信，一个关联指代可能因为多宿而涉及不止一个地址的两个系统之间的一次通信回话。

与TCP不同在于：
* SCTP面向消息
* SCTP能够在所连接的端点之间提供多个流
* SCTP提供多宿特性

### 1.2TCP连接的建立和终止

这一小节帮助大家理解connect,accept,close函数并使用netstat调试TCP应用程序。

#### 三次握手

1. 服务器端必须准备好接受外来的连接，这通过调用socket、bind和listen来完成，称为 “被动打开”
2. 客户端通过connect进行"主动打开",这将引起客户端向服务器端发送一个SYN报文段.告诉服务器初始序列号，SYN一般只含有一个IP头部，一个TCP头部，及可能有的TCP选项。
3. 服务器端必须确认SYN,同时自己也得发一个SYN，SYN和ACK合并在一个报文段发送
4. 客户端必须确认服务器SYN

![unix_socket_2](/img/unix_socket_2.png)

#### TCP选项

* MSS选项:TCP发送的SYN报文段中包含这个选项表示，通知服务器它的最大报文段大小为MSS
* 窗口规模大小:流量窗口，最大为65535，因为TCP头部只占16位
* 时间戳大小

#### TCP连接关闭
![unix_socket_3](/img/unix_socket_3.png)

#### TCP状态转换图

![unix_socket_4](/img/unix_socket_4.png)

![unix_socket_5](/img/unix_socket_5.png)

#### TIME_WAIT的作用：
TIME_WAIT一般维持2MSL（报文段生命期*2）

* 可靠实现TCP全双工连接的终止：假设最后客户端发送的ACK丢失，服务器端将重发最终的FIN，客户端要一直**维护这种可以接受FIN的状态，然后重发ACK**。否则它将响应一个**RST**报文段，因为如果没有TIME_WAIT则认为客户端该连接已经彻底关闭。
* 允许老的重复报文段在网络中消逝，在TIME_WAIT阶段**防止客户端发起该关闭连接的化身**（IP地址和端口号相同的连接）。因为如果出现该连接，可能之前 **“迷途漫游”**的报文段（ACK,FIN）会到达该连接导致，该化身接收到错误的报文段。这也就是为什么要设置**2MSL**，使得两端的迷途漫游的报文段**会在网络中消逝**

### 1.3SCTP关联的建立和终止

#### 四次握手

1. 同样服务器通过socket,bind,listen函数作为接受连接的准备
2. 客户通过调用connect发送一个SCTP的**INIT消息**（包括IP地址清单，初始序列号，起始标志...）
3. 服务器端对**INIT消息发送一个ACK**，ACK包含（服务器IP地址清单，初始序列号，起始标志，以及一个**state cookie**）
4. 客户端尝试根据cookie来发送信息，发送一个**COOKIE ECHO消息**来尝试进行带有cookie的数据发送。
5. 服务器端根据客户端发送过来的COOKIE来**ACK消息确认cookie是否正确**。

![unix_socket_6](/img/unix_socket_6.png)

#### 关联终止

* SCTP不像TCP那样允许半关闭的关联，当一端关闭某个关联时，另一端必须停止从应用进程传入新的用户数据并发送。
* 关联关闭请求的接受端只将已经排队的数据发送完后，执行关联的关闭

![unix_socket_7](/img/unix_socket_7.png)

#### 状态转换图

![unix_socket_8](/img/unix_socket_8.png)

![unix_socket_9](/img/unix_socket_9.png)

### 1.4 套接字端口号与并发服务器

当服务器通过调用accept创建**新的套接字**与客户端建立连接并调用**fork来处理客户端数据**，当有多个客户同时和服务器建立请求后，会有**多个子进程和多个套接字**来处理连接中的数据。但这些套接字都是**通过相同的端口**进行通信，端口是如何通过数据信息来将每个连接的数据转发到对应的套接字fd中进行通信的？这就是通过**套接字对**来进行连接数据的分流

* 每个已连接的套接字都保存一组**套接字对信息**，其中包括**源主机IP地址**(一个服务器端可能有**多个IP地址**供不同进程使用,多宿)及端口信息，还包括对端地址的端口信息
* {12.106.32.254:21,206.168.112.219:1500},其中12.106.32.254:21为源机的IP地址和端口号，206.168.112.219:1500为目的端IP地址和端口号。
* 还可以使用通配符来表示{\*:21,\* :\* },这就表示监听21端口来自任何IP地址的数据。

![unix_socket_26](/img/unix_socket_26.png)

### 1.5 缓冲区大小及限制

**IPv4**

- 1.IPv4最大大小是2^16（65535，包括IPv4首部，实际载荷为65535-20）


- 2.IPV4最小链路MTU为68，因为IPv4首部=20字节+40多字节的选项部分
- 3.路径MTU：两个主机之间的路径中最小的MTU
- 4.分片：这些分片在到达最终目的之前通常不重组
  - IPv4与IPv6的区别：
    - IPv4：主机对其产生和路由对其转发的数据报进行分片
    - IPv6：主机对其产生的数据报分片，路由不对其转发的数据报进行分片（路由对其产生的还是会分片的）
  - DF位：置位表示，不允许分片
    - IPv4：当路由器收到一个超出其外出链路MTU大小且设置了DF位的IPv4数据报时，将产生一个ICMPv4（目的不可达，需分片但DF已置位）
    - IPv6：隐含一个DF位（IPv6本来就不允许路由转发时分片），将产生一个ICMPv6（分组太大）
- 5.DF位的作用：发现路径MTU
- 7.最小重组缓冲区大小，表示IP的任何实现版本都必须保证的最小数据报大小（即双方还没开始交换MSS大小）
  - IPv4：576字节
  - IPv6：1500字节
- 8.MSS：用于向对端TCP通告对端在每个分节中能发送的最大TCP数据量，目的是告诉对端其重组缓冲区大小的实际值，从而避免分片
  - 通常值：MTU-IP首部固定长度-TCP首部固定长度（以太网为：1500-20-20=1460）
  - 实现：通过SYN分节（第一次和第二次握手）上的MSS选项设置
  - 最大值：2^16（65535）字节

### 1.6 TCP输出

![unix_socket_27](/img/unix_socket_27.png)

这里描述的是应用进程写数据到一个TCP套接字中时发生的步骤。

这里涉及以下知识点：

- 1.每一个TCP套接字都有一个发送缓冲区，由**SO_SNDBUF**更改大小
- 2.write调用发生的事情：
  - 内核从**应用进程的缓冲区**中复制所有数据写到**套接字的发送缓冲区**
  - 如果套接字缓冲区无法容下，可能原因：
    - 应用进程的缓冲区大于套接字的发送缓冲区
    - 套接字的发送缓冲区已有其他数据
  - 如果无法容下，进程被睡眠
  - 内核不从write返回（假设是阻塞的套接字） ，直到应用进程的缓冲区所有的数据都复制到套接字缓冲区中
  - 如果write返回，表示当前进程数据**已经复制到套接字缓冲区**，进程缓冲区可继续使用。但**不表示对端已经收到**
- 3.TCP套接字缓冲区需要**保留已经发送的数据**，直到收到该数据的ACK

### 1.7 UDP输出

![unix_socket_28](/img/unix_socket_28.png)

这里描述的是应用进程写数据到一个UDP套接字中时发生的步骤。

这里涉及以下知识点：

- 1.UDP有发送缓冲区（通过SO_SNDBUF设置）,实际上不存在（因此上图用虚线），它表示的只是该UDP套接字的**数据报上限**。
- 2.应用程序写一个**大于套接字发送缓冲区大小的数据报**，内核返回进程**EMSGSIZE**错误
- 3.因UDP不可靠，**不必保留应用进程的数据副本(和TCP的区别)**，因此无需一个真正的发送缓冲区
- 4.数据保存的过程：应用进程的数据在沿协议向下传递时，通常被复制到某种格式的一个内核缓冲区中，当数据发送后，**副本被链路层丢弃**
- 5.UDP的**write成功返回**表示所写的数据报或其所有分段已经被**加入数据链路层的输出队列**
- 6.如果链路层输出队列没有足够的空间存放数据报或分段，返回**ENOBUFS错误**到进程

## 第二章 套接字编程

### 2.1 套接字地址结构：

#### IPv4地址结构（16个字节）：
```
struct in_addr{
    in_addr_t s_addr;//32bit IPv4地址
}；
struct sockaddr_in{
    unit8_t sin_len;//Ipv4地址结构长度
    sa_family_t sin_family;//Ipv4地址族：AF_INET，posix
    in_port_t sin_port;//16位表示端口号,posix
    struct in_addr sin_addr;//表示地址,posix
    char sin_zero[8];//暂不使用
};
```

#### 通用套接字地址结构

我们将套接字地址传递给套接口函数时，总是**通过指针**来传递，即传递的是一个指向结构的指针。

为了兼容Ipv4,unix域，数据链路等不同协议类型的socket地址，定义了一个通用地址结构来存储这些地址信息：

```
struct sockaddr {
    unit8_t sa_len;//协议长度
    sa_family_t sa_family;//协议类型
    char sa_data[14];//协议所指向的地址

}
```
从应用程序开发人员的观点看，这些通用的套接字结构的唯一用途就是给指向特定协议的地址结构的**指针转换类型**。

#### IPv6地址结构(28个字节)：

```
struct in6_addr{
    unit8_t s6_addr[16];//16*8=128bit的地址结构
}
#define SIN6_LEN

struct sockaddr_in6{
    unit8_t sin6_len;//Ipv6地址结构长度
    sa_family_t sin6_family;//Ipv6地址结构的地址族:AF_INET6，posix
    sa_family_t sin6_port;//16位表示端口号,posix

    uint32_t sin6_flowinfo;//流信息:低20位是流标签，高12位保留
    struct in6_addr sin6_addr;//表示地址,posix
    uint32_t sin6_scope_id;//域接口集合
};
```

#### 套接字地址结构比较

![unix_socket_10](/img/unix_socket_10.png)

### 2.2 值－结果参数

1. 从**进程到内核**传递套接字地址结构的有三个函数:bing,connect,sendto

    ```
    struct sockaddr_in serv;
    connect(sockfd,(SA*) &serv,sizeof(serv));//传递套接字地址结构地址，和该结构数据的长度
    ```

2. 从**内核到进程**传递套接字地址结构的函数有四个：accept,recvfrom,getsockname,getpeername

    ```
    struct sockaddr_un cli;
    socklen_t len;
    len = sizeof(cli);
    getpeername(unixfd,(SA*)&cli,&len);//传递一个套接字地址结构对象进去cli，并告诉内核该结构的数据长度为len ,内核返回函数想要的地址结构到cli，并告诉进程该地址结构的数据长度，同样写到&len
    ```

    * 类似上面这种，参数将**一定信息传入函数**，函数返回时又**将结果返回到参数数据中**的类型就叫做**值－结果参数**
    * 这种具有值－结果参数的函数还有：select,getsockopt,recvmsg,ifconf,sysctl

### 2.3 字节排序函数

对于一个整数，内存中存储这两个字节又两种办法：

* 一种是将低字节存储在起始地址，称为**小端字节序**
* 另一种方法是将高序字节存储在起始地址。称为**大端字节序**。

* **主机字节序**：对于某一个系统内部使用的字节序叫做主机字节序，系统使用大端字节序还是小端字节序并没有标准。
* **网络字节序** ：网际协议使用的字节序是网络字节序，**网际协议**在处理这些数据的时候使用的是**大端字节序**。

为了将网络字节序和主机字节序进行协调，然后转换，我们定义如下四个函数来进行字节序的转换：

```
#include <netinet/in.h>

//主机字节序向网络字节序进行转换
unit16_t htons(unit16_t host16bitvalue);
unit32_t htons(unit32_t host32bitvalue);

//h代表主机host,n代表网络net,s代表短整形short,l代表长整型long

//网络字节序向主机字节序进行转换
unit16_t ntohs(unit16_t net16bitvalue);
unit32_t ntohs(unit32_t net32bitvalue);
```

### 2.4 字节操作函数

对字节进行设置，拷贝，比较操作的有两组函数：
* 一组以b开头（byte）
* 一组以mem开头(memory)

```
#include <strings.h>
void bzero(void *dest,size_t nbytes);//将目标中的指定数目字节置为0
void bcopy(const void *src,void *dest,size_t nbytes);//将指定数目的字节从源地址拷贝到目标地址
void bcmp(const void *ptr1,const void *ptr2,size_t nbytes);//比较两个字节串，相同返回0，否则返回非0

#include<string.h>

void *memset(void *dest,int c,size_t len);//将目标指定数目字节置为c
void *memcpy(void *dest,const const void *src,size_t nbytes);//将源地址的指定数目的字节拷贝到目标。
void *memcmp(const void *ptr1,const void *ptr2,size_t nbytes)//同bcmp,但ptr1>ptr2返回大于0的数，ptr1<ptr2返回小于0的数。

```

* memcpy的参数顺序和**赋值语句**相同：dst = src;
* memset最后两个参数的顺序：memXXX的函数都**要求有一个长度，且它总是最后一个参数**。


### 2.5 网络地址转换函数
这一组函数将网络字节序的二进制值和ASCLL字符串（易读性）之间进行转换：

```
#include <arpa/inet.h>
//a代表ascll码，n代表网络字节序的二进制

int inet_aton(const char *strptr,struct in_addr *addrptr);//将strptr指向的C字符串"206.168.112.96"转换为网络字节序二进制值到addrptr存储
//返回1时，串有效，返回0，串有错

in_addr_t inet_addr(const char *strptr);//同上，进行字符串到二进制的转换，直接返回结果32位二进制的值。
//不推荐使用

char *inet_ntoa(struct in_addr inaddr);//将二进制值转化为十进制的ASCLL码字符串，参数并非是指向结构的指针，而是结构本身
//返回转换后的字符串
```

* inet_addr函数和inet_aton的**区别**在于，当转换出错时，inet_addr会返回一个**全为1的32位二进制值**，所以我们不能用inet_addr处理十进制字符串**"255.255.255.255"广播地址**


还有一组比较新的网络地址转换函数：inet_pton,inet_ntop(n代表numeric，p代表presentation（ASCLL串）)

```
#incldue<arpa/inet.h>

int inet_pton(int family,const char *strptr,void *addrptr);//将ASCLL串转换为二进制，存放到addrptr

char *inet_pton(int family,void *addrptr,const char *strptr,size_t len);//将二进制addrptr转换为ASCLL串返回，也就是存放在strptr中
```

地址转换函数总结：

![unix_socket_11](/img/unix_socket_11.png)


* **sock_ntop()**:由于inet_pton和inet_pton都需要**协议相关的信息，还有特定的地址结构**，会使我们的代码具有局限性，不具有**通用性**，为了解决这个问题，我们引入sock_ntop()函数来使用**通用地址结构作参数**，然后分析地址结构信息调用具体的地址转换函数：

```
#include "unp.h"

char *sock_ntop(const struct sockaddr *sockaddr,socklen_t addrlen);//使用通用地址结构sockaddr,函数内部，对该地址结构信息进行分析然后调用对应的地址转换函数

```

###2.6 对字节流套接口上的读写操作

* 字节流 **套接字**上的读read写write操作所表现出的行为 **不同于通常的文件I/O**。字节流套接字上的读或写输入或输出的字节数可能比要求的数量少，这是因为内核中套接口的 **缓冲区可能已经达到上限**，此时需要调用者 **再次调用**read和write函数来输入或输出剩余的字节。

我们对字节流套接口进行读或写操作时调用下面的三个函数：

```
ssize_t readn(int fd,void *buff,size_t nbytes);//从套接字读取指定数目的字节到buff中
ssize_t writen(int fd,const void *buff,size_t nbytes);//将buff中的数据写入指定数目的字节到fd的文件中
ssize_t readline(int fd,void *buff,size_t maxlen);//逐行读取数据到buff中，但读取的最大数目字节数为maxlen

```

* readn和writen都是对read和write进行**封装**，通过**重复调用read和write**来读取或写入**指定数目**的字节内容
* readline则是调用read来**一个一个字节读取**，碰到'\n'或达到maxlen长度停止读取数据,因为对read多次重复调用，所以**效率非常低**
* 这三个函数会对**EINTR**（系统调用被一个捕获的信号中断）进行检查，发生这种错误**继续进行**读写操作

![unix_socket_12](/img/unix_socket_12.png)
![unix_socket_13](/img/unix_socket_13.png)
![unix_socket_14](/img/unix_socket_14.png)


## 3.基本TCP套接口编程

* 本部分讲解编写一个完整的TCP客户和服务器程序所需要的基本套接口函数。
* 还包括并发服务器，是在同时有大量的客户连接到同一服务器上时用于提供并发性的一种常用的Unix

### 3.1 socket函数

一个进程想要指向网络I/O，第一件事就是要调用socket函数创建套接字用于进行网络I/O的接口。

```
#incldue<sys/socket.h>
int socket(int family,int type,int protocol);//创建成功时返回套接字文件的文件描述符fd
```
* family指协议族，AF_INET,AF_INET6等
* type表示socket套接字的类型:SOCK_STREAM(字节流),SOCK_DGRAM（数据报）等
* protocol表示传输层协议：IPPROTO_TCP,IPPROTO_UDP,IPPROTO_SCTP

基于TCP客户／服务器端套接口函数简介：

![unix_socket_15](/img/unix_socket_15.png)

family,type以及protocol可选项：

![unix_socket_16](/img/unix_socket_16.png)
![unix_socket_17](/img/unix_socket_17.png)

### 3.2 connect函数

TCP客户用connect函数来建立与TCP服务器的连接：

```
#include<sys/socket.h>

int connect(int sockfd,const struct sockaddr *servaddr,socklen_t addrlen);//sockfd为我们创建的套接字文件描述符,servaddr为我们想要连接的服务器端的通用地址结构，addrlen为该地址的数据长度。
```

* 客户在调用函数connect前**并不必非得调用bind函数**，内核会确定源IP地址，并选择一个**临时端口**作为源端口
* 如果是TCP套接字，则connect会触发三次握手

connect函数可能会出现如下三种情况：
1. ETIMEDOUT错误：超时，没有收到SYN的响应，4.4BSD分4s，24s，75s三次间隔发送仍未收到响应报该错误
2. RST:复位表示服务器并没有进程监听和等待与客户端进行连接
3. ICMP:目的地不可达，软错误，同样根据4,24,75间隔重复发送SYN。

### 3.3 bind函数

bind函数把一个本地协议地址赋予一个套接口，对于网际协议，协议地址就是32位IPv4或128位的IPv6地址与16位的TCP或UDP端口号的组合。

```
#include<sys/socket.h>

int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);

//sockfd指对应的套接字文件描述符，myaddr指我们要绑定的协议地址，addrlen表示该地址的数据长度
```

* bind函数可以指定一个端口号，也可以指定一个IP地址，可以两个都指定，也可以两个都不指定。当IP地址信息为**通配地址时，或指定端口号为0**时，内核会给该套接字设置**临时端口**，并且只有当套接字发出数据时才选择一个本地的IP地址。

![unix_socket_18](/img/unix_socket_18.png)

* 当bind不指定IP地址和端口时，内核会临时分配一个，但**分配的端口值并不能被返回**，因为参数myaddr是const类型，所以我们要想获取该临时端口号，需要使用**getsockname**函数来获取宿IP协议地址信息。
* bind函数常返回的一个常见错误为EADDRINUSE(地址已经被使用)

### 3.4 listen函数

* 当socket创建套接字时，它被假设为一个 **主动套接口**，也就是默认要调用connect发起连接
* listen函数把一个 **主动套接口**转换成一个 **被动套接口**。

```
#include <sys/socket.h>

int listen(int sockfd,int backlog);//sockfd指要转换为被动套接字的文件描述符，backlog表示该套接字排队的最大连接个数
```

backlog涉及到的两个队列：

1. **未完成连接队列**：客户端已经发送一个SYN到服务器端，服务器端接收到该SYN后就会在未完成队列创建一项，然后该套接口处于SYN_RCVD状态，并响应三次握手中第二个报文段。
2. **已完成连接队列**：每个已完成三次握手过程的套接字，都会位于该队列，这些套接字都处于ESTABLISHED状态

![unix_socket_19](/img/unix_socket_19.png)
![unix_socket_20](/img/unix_socket_20.png)

* backlog曾设置为这两个队列总和的最大值，但不同的系统有不同的实现方式，并且**不要把backlog设置为0.**
* 未完成连接中队列的任何一项在其中**存留时间不超过RTT**
* 当一个客户的SYN到达时，若这些队列是满的，TCP则忽略该SYN报文段，会自动出发TCP的自动重传机制

###3.5 accept函数

用于从已完成队列队头返回下一个已完成连接，如果已完成连接队列为空，进程被投入睡眠。

```
#include<sys/socket.h>

int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);//值－结果参数

```
* 参数cliaddr和addrlen用来返回内核分配的已连接的**客户端的协议地址及长度信息**。返回值是内核自动生成的一个**全新的描述符**，用于与客户进行TCP连接。
* 返回结果包括
    - 新套接字描述符或错误代码
    - cliaddr客户端协议地址信息
    - addrlen协议地址数据长度
* 如果我们队客户端的协议地址信息**不感兴趣**，可以将cliaddr和addrlen设置为**空指针**。

### 3.6 fork和exec函数

#### fork函数
在介绍并发服务器之前，要先介绍一下Unix的fork函数

```
#include <unistd.h>
pid_t fork(void);
```

* 调用一次fork，返回两次，在父进程中返回子进程的pid,在子进程中返回0（因为子进程可以轻松通过getppid去的父进程pid）
* 父进程中调用fork之前的所有描述符在fork返回之后有子进程分享，网络服务器中，通常，子进程对一个已连接套接口继续进行读写，而父进程则关闭这个已连接的套接口。

fork的两种典型用法：

1. 一个进程创建一个自身的拷贝，每个拷贝都可以在另一个拷贝执行其他任务的同时处理各自的操作
2. 一个进程想要执行另一个程序，但创建新进程只能通过调用fork，所有fork先创建一个自身的拷贝，然后调用exec来执行新的程序。

#### exec函数

存放在硬盘上的**可执行程序**能够被Unix执行的唯一方法是，由一个现有进程调用六个exec函数中的一个，exec会将当前**进程映像替换成新的程序文件**，该程序通常从main开始执行，**进程ID不变**。

![unix_socket_21](/img/unix_socket_21.png)
![unix_socket_22](/img/unix_socket_22.png)

六个exec函数中只有execve是内核调用，其他五个都是调用execve的库函数：

![unix_socket_23](/img/unix_socket_23.png)

### 3.7 并发服务器

我们希望一个服务器不长时间被单个客户长期占用，而是希望 **同时服务多个客户**，Unix编写并发服务器的最简单的办法就是fork一个子进程来服务每个客户。这样就使得**父进程**仅为**监听进程**，**子进程**来提供对客户的服务。

* 父进程会关闭accept打开的**已连接文件描述符**。
* 子进程则关闭用于**连接请求监听的文件描述符**。
* 这样父子进程分工明确，父进程监听请求，子进程处理客户数据。

```
//并发服务器编程模版：

pid_t pid;
int listenfd,connfd;
listenfd = Socket(...);//创建一个套接字
Bind(listenfd);//将套接字绑定到指定的协议地址
Listen(listenfd,LISTENQ);//将套接字由主动转换为被动开始监听。
for(;;)
    connfd Accept(listenfd,..);//从已完成队列中取出一个连接分配一个套接字，并返回文件描述符
    if((pid = Fork())==0){
        //进入子进程服务客户
        Close(listenfd);//首先关闭监听套接字，仅让父进程监听
        doit(connfd);//处理连接传送过来的数据
        Close(connfd);//处理完毕后关闭该套接字
        exit(0);//子进程退出
    }
    Close(connfd);//父进程关闭已连接套接字，仅让子进程去处理连接中客户传送过来的数据

```

问题：为什么父进程关闭connfd,子进程关闭listenfd都没有将这两个套接字关闭。

* 因为每个文件或套接字在 **文件表项**中，都有一个 **引用计数**，当fork一个子进程后，listenfd和connfd的引用计数都变为了2，所以关闭一个，其引用计数减为1，**只有当引用计数减为0时，该套接字才会关闭**。

![unix_socket_24](/img/unix_socket_24.png)


### 3.8 close函数

```
#include <unistd.h>

int close(int sockfd);//导致相应描述符的引用计数值减1，当引用计数减为0时触发四次挥手
```

如果想要直接通过socket发送FIN来关闭连接，不通过引用计数，则可以改用shutdown函数

### 3.9 getsockname和getpeername函数

```
#include <sys/socket.h>
//均为值－结果参数

int getsockname(int sockfd,struct sockaddr *localaddr,socklen_t *addrlen);

int getpeername(int sockfd,struct sockaddr *peeraddr,socklen_t *addrlen);
```

这两个函数都是获取指定套接字的协议地址信息，存放到localaddr和peeraddr，使用场景有如下几种：
1. 没有bind就直接发起connect的套接字，getsockname来返回**内核给套接字在连接中赋予的IP地址和临时端口号 **
2. 用**通配IP地址或端口号0**来绑定的套接字
3. getsockname获取套接字的地址族
4. 当服务器调用accept的某个进程通过调用exec更换程序时，由于**进程映像全部被替换**，accept获取的**“对端地址”信息也随之丢失**，所以我们要获取该已连接套接字的"对端地址"则需要调用**getpeername**来获取。

![unix_socket_25](/img/unix_socket_25.png)

## 4.TCP客户／服务器的代码实例

这一章我们将实行一个完整的TCP客户端/服务器端程序的例子。

1. 客户从标准输入和输出读入一行文本，并写给服务器
2. 服务器从网络输入读入这行文本，回射给客户
3. 客户从网络输入读入这行回射文本，并显示在标准输出上

### 4.1 TCP服务器程序

进行网络通信的第一步是要启动服务器，这里我们编写了一个并发服务器程序。该程序主要分为5个步骤：

1. 创建监听套接字socket
2. 设置协议地址信息，并将该协议地址绑定到该套接字上
3. 将套接字转换为被动套接字
4. 处理套接字的连接请求
5. fork子进程来处理客户端数据（包括回射客户端str_echo）

![unix_socket_29](/img/unix_socket_29.png)

服务器回射程序str_echo,来和客户端通信：

![unix_socket_30](/img/unix_socket_30.png)

### 4.2 TCP客户端程序

服务器启动后，开始监听请求连接，接下来我们看客户端是如何发起连接请求的：

客户端主要做了三件事：

1. 创建客户端用于TCP连接的socket
2. 根据参数配置协议地址信息后，发起请求连接connect，这里没有进行bind操作
3. 向连接成功的套接字发送数据

![unix_socket_31](/img/unix_socket_31.png)

其中通过已连接的套接字给服务器端发送数据的函数str_cli代码如下：

![unix_socket_32](/img/unix_socket_32.png)

### 4.3 正常启动

1. 首先本地启动服务器：
    ```
    linux$ tcpserver &  //阻塞在accept调用
    ```

2. 查看服务器启动后的监听套接字：
    ![unix_socket_33](/img/unix_socket_33.png)

3. 启动客户端：
    ```
    linux$ tcpcli 127.0.0.1  //阻塞在fgets调用
    ```
4. 查看端口状态
    ![unix_socket_34](/img/unix_socket_34.png)

5. 查看这些进程的父子关系：
     ![unix_socket_35](/img/unix_socket_35.png)

### 4.4 正常终止

我们可以在客户端键入EOF(Control+D)来终止客户端进程，终止后立即调用netstat命令可以看到客户端进程处于TIME_WAIT状态。

* 客户端程序中**fgets会返回空指针**，从而离开函数str_cli(),并执行exit(0),关闭客户端进程
* 客户端进程终止处理的其中一个步骤就是关闭该进程相关的套接字，导致TCP客户端发送一个**FIN信号**到服务器端
* 服务器端TCP接收到FIN报文段时，**readline函数会返回0**，同样跳出子进程中的处理函数str_echo(),并执行exit（）退出子进程，服务器端的套接字被关闭。
* 客户端接收到服务器端**最后一个ACK后处于TIME_WAIT状态**(2RTT)
* 服务器端子进程退出后会向父进程**发送SIGCHLD信号**，虽然该信号产生了，但本服务器代码并没有处理该信号，父进程没有处理导致子进程成为了**僵死进程(Z:没有将进程退出时的信息进行回收)**

### 4.5  POSIX信号处理

信号就是通知某个进程发生了某个事件，有时也称为软件中断，并且是异步发生的

信号可以：

1. 由一个进程发给另一个进程（可以是自身）
2. 内核发给某个进程

每个信号都有一个与之关联的处置，也称为行为，我们通过调用**sigaction函数**来设定信号的处理过程:

1. 我们可以捕获信号，并调用该信号所设置的信号处理函数，这称为捕获信号，但有两种信号不能被捕获：SIGKILL和SIGSTOP
2. 可以将信号设置为SIG_IGN来忽略该信号，同样，SIGKILL和SIGSTOP不能被忽略
3. 将信号设置为SIG_DFL，启用默认的信号处理函数

#### signal函数

* 建立信号处置的POSIX方法就是调用sigaction函数，但这个过程比较复杂，因为我们需要创建并填写对应的sigaction结构。
* 另一个方法是调用signal函数，两个参数一个是信号名，另一个则是信号处理函数。调用简单
* 其实目前大部分定义signal函数就是通过内部创建sigaction结构体，然后调用sigaction函数来实现，如下图所示：

     ![unix_socket_36](/img/unix_socket_36.png)

1. 上图所示的Sigfunc是通过**typedef**定义的：typedef void Sigfunc(int);//定义Sigfunc为参数为整型数，函数没有返回值的**函数原型**，这样可以简化函数的书写
2. 设置sigaction的**sa_handler**元素设置为传进来的函数指针
3. 第7行设置**信号掩码**，POSIX允许我们设置这样一组信号，他们在信号处理函数被调用期间阻塞，不能传递给进程。这里是将**sa_mask设置为空集**，也就是不阻塞任何信号（但POSIX**保证阻塞该信号处理函数所处理的信号不能再次传递给进程**)
4. 设置SA_RESTART标志：8～17行，设置该标志，由相应信号而中断的系统调用将由**内核自动重启**。对SIGALARM进行特殊处理：因为该信号通常是对I/O操作**设置超时的操作**，发生超时时，我们希望该**系统调用中断**掉。所以有和SA_RESTART互补的SA_INTERRUPT标志
5. 调用sigaction设置信号的处理动作，并**返回旧的处理动作到oact,然后返回旧的信号处理函数**。

#### 信号处理语义

1. 信号处理函数一旦被安装就**一直被安装**
2. 信号处理函数期间，**正在被递交和sa_mask信号集**中的信号被阻塞
3. 一个信号在被阻塞期间产生多次，当被解阻塞后，只会递交一次，信号默认是**不排队**的
4. 利用**sigprocmask**来阻塞和解阻塞一组信号

### 4.5 处理SIGCHLD信号

* 僵死进程：当子进程退出时，会给父进程发送**SIGCHLD**信号，子进程会处于**僵死状态维护进程信息**，这些信息包括子进程的进程ID,终止状态以及资源的利用信息（CPU时间，内存使用量等）。
* 当一个进程终止时，操作系统会检查该进程的子进程**是否拥有僵死进程**，如果有，则将这些僵死进程的**父进程ID 设置为1，由Init进程**来清理这些僵死进程的信息（init会wait这些僵死进程）

#### 处理僵死进程
* 僵死进程的存在会**占用内存空间**，并且可能导致我们耗尽进程资源。
* 所以无论何时我们**fork子进程都要wait**它们，防止它们变成僵死进程。
* 解决方案就是通过在父进程**捕获SIGCHLD信号的处理函数**，函数体中调用**wait()**来回收子进程中的信息

```
Signal(SIGCHLD,sig_chld);//设置SIGCHLD处理函数

#include "unp.h"

void sig_chld(int signo){
    pid_t pid;
    int stat;
    pid = wait(&stat);//wait调用获取到子进程的pid和终止状态stat
    printf("child %d terminated\n",pid);
    return;

}

```

* 我们服务器的父程序中阻塞在accept（）**慢系统调用**（slow system call）中,捕获到SIGCHLD信号，致使accept返回一个**EINTR错误（系统调用被中断）**，而父进程程序没有处理该错误，导致进程终止。
* 有的系统会设置**SA_RESTART标志**，导致该信号触发时，阻塞进程的系统调用accept会**自动重启，而不会返回错误**后终止。
* 所以有些系统对于阻塞于某个慢系统调用的一个进程捕获某个信号且相应处理函数返回时，该系统调用会返**回EINTR错误**，而有的系统则**自动重启该系统调用**

### 4.6 wait和waitpid函数

```
#include <sys/wait.h>

pid_t wait(int statloc);

pid_t waitpid(pid_t pid,int statloc,int options);
```

相同点：

* 都等待子进程终止然后返回**终止子进程的pid**及子进程的**终止状态**（正常终止，由某个信号杀死，作业控制停止）。
* 有些宏（**WIFEXITED,WEXITSTATUS**）的设置来获取子进程的退出状态，杀死子进程的信号值，停止子进程作业控制的信号值。

区别：

* wait:**不指定**子进程，在父进程中等待任一子进程终止为止，且会 **一直阻塞**。
* waitpid:等待 **指定子进程**终止，才进行处理，通过pid参数进行指定，当pid为**－1**时，不指定子进程，第一个子进程终止时就处理。同时可以通过设置参数**option(WNOHANG)**,等待子进程时**不阻塞**父进程。

#### 多个信号同时递交

1. 当一个服务器进程有多个子进程来服务多个客户时，当多个客户（如5个）同时终止，服务子进程也会终止**并发出5个SIGCHLD信号**
2. 当我们在父进程调用 **wait()**函数时，处理第一个SIGCHLD信号时调用信号处理函数，该函数执行完毕之前收到其它四个子进程发出的SIGCHLD信号
3. 由于信号**不排队**，所以其他四个信号都会消失。导致这四个进程变为**僵死进程**

![unix_socket_37](/img/unix_socket_37.png)
解决办法：使用waitpid函数，我们在一个**循环内调用waitpid**，获取终止的子进程的状态。因为waitpid可以**不用阻塞**，当waitpid调用信号处理函数时，循环依然继续监听子进程是否终止。

服务器端的正确代码：
![unix_socket_38](/img/unix_socket_38.png)

![unix_socket_39](/img/unix_socket_39.png)

#### accept返回前连接夭折

TCP三次握手的连接已经建立，TCP却发送了一个RST复位，也就是当该连接已经进入已完成队列，等待服务器调用accept。这时客户端发送一个RST信号，随后服务器进程调用accept。这会引发accept报错。

#### 服务器子进程终止

当客户/服务器对启动后，然后杀死服务器子进程，我们观察客户端发生的动作：

1. 正常情况下，客户端给服务器端发送一行文本，服务器端回射给客户端显示在终端。
2. 当服务器处理该客户的子进程被**kill掉**后，服务器会向客户端**发送FIN信号**，客户端TCP会立即**响应ACK**。
3. SIGCHLD信号发送给服务器父进程，调用对应的处理函数
4. 此时客户端正**阻塞在fgets系统调用**上，且客户端TCP处于**CLOSE_WAIT状态**，服务器端TCP位于**FIN_WAIT2状态**
5. 当客户端输入一行文本，客户端依然可以发送给服务器，因为客户TCP接收到FIN只是表示服务器进程关闭了连接的服务器端（也就是**服务器不会再向客户端发送数据**），并没有告诉客户端说服务器进程已经终止（这个例子中，服务器进程是**被kill掉的，已经终止**,如果没有被kill是可以发送数据的）。所以服务器接收到该数据后，会返回一个**RST报文段**。
6. 客户端看不到这个RST信号，因为当执行到Readline时，会读取到第2步服务器发送过来的**FIN报文段从而返回0**，报错“server terminated prematurely”
7. 客户端进程退出，关闭所有套接字

![unix_socket_40](/img/unix_socket_40.png)

#### SIGPIPE信号

* 上述服务器子进程终止的场景下，要是我们连续两次写数据到服务器端，第一次会触发服务器**发送RST报文段**，第二次写则是 **向某个已经收到RST的套接字执行写操作**。
* 这时，内核向该进程发送一个 **SIGPIPE信号**，该信号缺省行为是 **终止进程，并返回EPIPE错误**。

![unix_socket_41](/img/unix_socket_41.png)

#### 服务器主机崩溃

在客户端服务器端启动后，然后从网络上断开服务器主机，然后客户端键入文本数据。

此时发生的情况如下：

1. 这里我们假设服务器主机崩溃并**不是shutdown**。也就是服务器端网络不可达
2. 客户端发送文本数据到服务器端，并阻塞在**readline 系统调用**，等待回射的应答。
3. 客户TCP会执行重传机制，不断向网络**重传**数据报文段，Berkeley实现的重传要**重传12次，共等待9min**才放弃重传，放弃重传后，readline会返回**ETIMED-OUT（超时错误），如果中间有路由器判定服务器主机不可达，则响应“destination unreachable”ICMP消息，返回EHOSTUNREACH或ENETUNREACH错误 **

* 如果我们不想等待9min才知道服务器崩溃，我们可以 **设置readline超时**
* 上述是我们 **向服务器发送数据**时，我们才能知道服务器崩溃，为了不用发送数据就能感知到服务器崩溃，我们可以给套接字设置 **SO_KEEPALIVE**套接口选项。

#### 服务器主机崩溃后重启
假设，服务器端崩溃后重启，客户端并没有感知到服务器关闭的过程，这里假设**没有使用SO_KEEPALIVE**套接口选项，所以客户端不发送数据就不能感知到服务器的关闭，发生如下步骤：

1. 服务器和客户端正常连接
2. 服务器崩溃并重启
3. 客户端输入一行文本数据，向服务器端发送对应报文段
4. 服务器崩溃后重启，它的TCP**之前的连接信息全部丢失**，所以服务器端对接收到的报文段**响应RST**
5. 客户端接收到RST响应，被阻塞的**readline系统调用返回ECONNRESET错误**

#### 服务器主机关机

Unix系统关机时，init进程会给所有进程**发送SIGTERM信号**，该信号可以被捕获，再等待一段**固定**的时间(往往在5~20s之间)然后给所有仍在运行的进程**发送SIGKILL信号，该信号不能被捕获**。这么做是为了给进程留一小段时间来清除和终止，当服务器子进程终止时，所有套接字都将关闭

## 5.I/O复用：select和poll函数

从上一章节的例子中，客户端**阻塞在fgets**系统调用，当服务器端子进程被kill掉时，给客户端发送了一个FIN报文段，而**readline不能及时读取**，所以这样的场景下需要进程有一种预先告知内核的能力，使得内核一旦发现进程**指定的一个或多个I/O条件就绪**，它就通知进程。这个能力就叫做 **I/O复用**

I/O复用的场景：
* 客户端处理多个描述符
* 客户端处理多个套接字
* TCP服务器即要处理监听套接口，又要处理已连接套接口
* 服务器即要处理TCP又要处理UDP
* 服务器要处理多个服务或多个协议（inetd守护进程）

### 5.1 I/O模型
* 阻塞I/O模型:recvfrom，当没有数据报到达时，进程一直**阻塞等待**
* 非阻塞I/O模型:recvfrom**轮询，循环询问数据报**是否准备好。如果没有准备好，返回**EWOULDBLOCK**错误
* I/O复用模型：可以等待多个描述符就绪，**阻塞在select调用**上，而不是单个描述符的recvfrom上。
* 信号驱动I/O模型：当描述符就绪时发送**SIGIO信号**通知进程，并通过sifaction系统调用安装信号处理函数。
* 异步I/O模型：告诉内核启动一个I/O操作，并让内核在整个I/O操作完成后通知我们，信号驱动I/O是通知我们**开始I/O操作**，异步I/O则是由 **内核通知我们I/O操作何时完成**
  - 除了异步I/O操作，其它都是同步I/O操作。异步和同步的区别在于：**真正执行I/O读写时，进程是否堵塞**。

![unix_socket_42](/img/unix_socket_42.png)

### 5.2 select:函数细节详见blog：高级I/O

blog:http://blog.xbblfz.site/2018/04/15/高级i-o/

目前使用select技术修改客户端发送数据的代码：

客户端的套接口上三个条件处理如下：
1. 对端TCP发送数据，套接口可读，read**返回一个大于0**的数
2. 对端TCP发送一个**FIN**套接口可读，read**返回0**
3. 对端TCP发送一个**RST**套接口可读，read**返回－1**，且将errno设置为对应错误码

![unix_socket_43](/img/unix_socket_43.png)

### 5.3 批量输入

问题：当我们的标准输入批量发送文本数据（多行）到服务器端，采用5.2中的代码，我们发现客户端接收服务器端回射的输出文件总是小于输入文件。(readline和fgets)

原因：因为缓冲区的存在使得I/O问题更加复杂:

1. 当服务器端发送一个**FIN**到客户端时，客户端不应该直接退出将套接字的**读写端全部关闭**，因为客户端**TCP缓冲区可能还有数据没有发送到服务器端**，所以我们需要一种**关闭TCP连接一半**的方法：只关闭客户端TCP的读端，但还可以继续写，这个部分将由函数**shutdown**完成
2. 当客户端输入多行数据后，stdio缓冲区存放多行文本数据，此时我们调用**fgets却只能读取其中的一行**，其余行依然在**缓冲区**,要等下一次触发标准输入可读时才能读取下一行，不能显示到标准输出。所以，我们需要进行相应的处理，将发送到客户端的缓冲区的数据全部读取到标准输出

### 5.4 shutdown函数

close函数的两个限制：
1. close只负责把描述字的引用计数减一，shutdown可以立马激发TCP的连接终止操作
2. close会关闭数据传送的两个方向：读和写，shutdown可以控制全关闭，和半关闭

```
#include <sys/socket.h>
int shutdown(int sockfd,int howto);
```

howto的值：

1. SHUT_RD:关闭连接**读这一半**，套接口不再接收数据，且接收缓冲区中的**现有数据全被丢弃**
2. SHUT_WR:关闭连接**写这一半**，对于TCP套接口， 这称为**半关闭**(half-close),当前留在套接口发送**缓冲区的数据发送到服务器**，进程不能对该套接口进行任何写操作
3. SHUT_RDWD:连接的读写都被关闭，相当于**连续调用两次**shutdown函数，第一次指定SHUT_RD，第二次指定SHUT_WR。

### 5.5 针对缓冲区的问题，再次修订str_cli发送数据的代码

![unix_socket_44](/img/unix_socket_44.png)

其中：

1. stdineof是为了标记是否是**客户端读取到EOF正常退出**，还是**服务器异常终止**服务进程而发送FIN到客户端
2. 这里将**Readline改为Read**,读取单元由一行一行读取改为**针对缓冲区大小**单元进行读取
3. 使用**shutdown来半关闭**可以使得客户端发送缓冲区的数据发送到服务器端，同时，服务器端的**发送缓冲区**或者是客户端发送给服务器但还在**网络中**的数据，也可以**完整的**到达客户端显示。而不是直接关闭客户端进程，导致部分数据丢失

### 5.6 TCP回射服务器程序

我们这一章节将利用select技术来实现可以处理任意数目客户的单进程程序，而不是像之前为每个客户派生一个子程序。

我们使用一个client整型数组来记录每个客户对应的socket描述符号，然后使用可读描述符集rset：

* 当客户关闭后(socket描述符为4)，client数组中对应项由4**设为-1**,rset中第4位置为0
* 当有新客户连接到达时，将client数组中**第一个为－1**的项记录套接字描述符。同时添加到rset
* 本服务器可以处理的最大客户数量限制是在**FD_SETSIZE(宏)**和内核允许本进程打开的**最大描述符字数**之间的**较小数**。

![unix_socket_45](/img/unix_socket_45.png)

服务器前面监听套接字的监听绑定，初始化部分的代码都一样，区别在于for循环处理新到来的客户端连接请求，这里不是通过fork子进程来处理客户连接而是通过selelct来处理连接。

思路：通过select监听哪些套接字可读，然后循环检测**监听套接字和所有客户连接套接字**是否可读，如果可读则做对应的处理

![unix_socket_46](/img/unix_socket_46.png)

#### 拒绝服务攻击

一些恶意程序，会只给服务器发送一个字节数据，服务器调用Read函数时，会循环调用read系统调用，因为没有读取到EOF，也没达到指定读取数据量大小，从而导致阻塞。使得该服务器不能服务其它的客户，为了解决这个问题，给出了三个解决方案：

1. 使用非阻塞I/O
2. 每个客户由单独的线程提供服务
3. 对I/O设置超时

### 5.7 pselect函数

pselect的时长设置的更加**精确**，并且可以**设置信号掩码**，可以使得进程禁止递交某些信号，然后再测试这些描述符是否可读，可写或异常。

```
#include<sys/select.h>
#inclde<signal.h>
#include<time.h>

int pselect(int maxfdp1,fd_set *readset,fd_set *writeset,
  fd_set *exceptset,const struct timespec *timeout,
  const sigset_t *sigmask)//sigmask:信号掩码

struct timespec{
  time_t tv_sec;//秒
  long tv_nsec;//ns纳秒
}
```

### 5.8 poll函数
详见高级i/o blog:http://blog.xbblfz.site/2018/04/15/高级i-o/

利用poll实现的服务器程序，主要是配置poll所需要的监听的描述符数组。代码见P159

## 6.套接字选项

有很多方法来获取和设置影响套接口的选项：
* getsockopt和setsockopt
* fcntl
* ioctl

```
#include <sys/socket.h>

int getsockopt(int sockfd,int level,int optname,void *optval,socklen_t *optlen);//optval和optlen为值结果参数

int setsockopt(int sockfd,int level,int optname,void *optval,socklen_t *optlen);//optval为要设置的选项的新值

```

套接口选项分为两类：

1. 标志选项：开启和禁止某个特性的二元（0/1）选项
2. 值选项：取得和返回我们可以设置或检查的特定值的选项

![unix_socket_47](/img/unix_socket_47.png)
![unix_socket_48](/img/unix_socket_48.png)

### 6.1 检查选项是否受支持并获取缺省值

根据套接口的选项的需求创建对应类型的套接口，然后调用getsockopt获取选项值并打印出来。

![unix_socket_49](/img/unix_socket_49.png)

![unix_socket_50](/img/unix_socket_50.png)


### 6.2 套接口状态

下面套接口选项是由TCP**已连接套接口从监听套接口继承**而来的：SO_DEBUG,SO_DONTROUTE,SO_KEEPALIVE,SO_LINGER,SO_OOBINLINE,SO_RCVBUF,SO_RCVLOWAT,SO_SNDBUF,SO_SNDBUF,SO_SNDLOWAT,TCP_MAXSEG和TCP_NODELAY

### 6.3 通用套接口选项
下面这些选项和协议无关，所有协议的套接口类型都能使用，但也有些选项只能应用到某些特定类型的套接口中：

#### 6.3.1 ***SO_BROADCAST***
开启或禁止进程**发送广播的能力**，只有**数据报套接口**支持广播，数据报套接口会先在内核中测试发送地址是否为广播地址，且广播选项是否设置,然后才能进行数据广播。

#### 6.3.2 ***SO_DEBUG***
仅**支持TCP**，开启该选项时，内核将对TCP在该套接口发送和接收的所有分组**保留详细的跟踪信息**，这些信息保存在某个环形缓冲区中，并可以使用**trpt程序**进行检查。

#### 6.3.3 ***SO_DONTROUTE***
规定外出发送的分组，**屏蔽底层协议的正常路由机制**，而是定向到某一个**特定端口**进行发送。

#### 6.3.4 ***SO_ERROR***
套接口有一个名为so_error的变量，记录错误条件

  - 这是一个只可以**获取值而不能设置值**的选项 (值选项) 
  - getsocketopt获取该选项的值会返回so_error的值，随后so_error会由内核**复位**为0。
  - 同时当对套接口调用**read**时如果**没有数据**返回，会检查so_error的值，如果为非零值，read返回-1，并将so_error复位为0。
  - read如果**有数据返回**，则返回数据，而不是返回so_error的错误条件
  - 当调用write时，so_error为非0值，返回－1，且errno设置为so_error的值，且so_error被复位
  
#### 6.3.5 ***SO_KEEPALIVE***
当给一个TCP套接口设置保持存活（keep-alive）选项后，如果**2个小时**内该套接口一直没有数据传输和接收，则TCP会自动给对段发送一个探测报文段
  - 会出现下面三种情况
    + **对端正常响应**
    + **对方进程已经崩溃，或崩溃后重启**，返回**RST响应**，导致本地套接字待处理错误为**ECONNRESET**,套接口本身也被关闭
    + **对端网络连接不可达**：没有响应，每隔**75秒**重传一个探测分组，一共传**8次**，若均没有响应，则待处理错误为**ETIMEOUT**，关闭套接字，若其中有响应是**ICMP错误**（路由不可达），则返回相应的错误，待处理错误设为EHOSTUNREACH
  - 时间参数是否可改（2小时改为15min）？
    + 因为这些时间参数是面向整个内核维护的，所以修改这个套接口的时间参数，其他所有开启了这个选项的套接字的时间参数也收到影响。
  
#### 6.3.6 ***SO_LINGER***
该选项指定close对面向连接的协议（TCP和SCTP）如何执行，默认的行为是close函数立即返回，然后将残留在套接口发送缓冲区的数据发送到对端，该选项就是用来修改这个默认的行为

  ```
  struct linger{
    int l_onoff;//是否打开
    int l_linger;//标记如何close
  }
  ```
  - 当l_onoff为0时，关闭该选项，close执行默认操作
  - 如果l_onoff非0，l_linger为0，当close某个连接时，TCP将夭折该连接，也就是说TCP将丢弃发送缓冲区中的数据，并发送一个RST给对端，没有四次挥手。这主要用来避免TIME_WAIT状态（如果有新的化身，数据会被错误传递）
  - 如果l_onoff为非0且l_linger为非0:close时，套接口将拖延一段指定时间（l_linger的值指定），这段时间内，执行序列是先将发送缓冲区的数据发送到服务器端，然后发送FIN开始四次挥手,会出现以下两种结果：
    + 套接口将所有缓冲区中的数据发送并得到确认后**正确返回**
    + 设定的拖延时间到返回，返回EWOULDBLOCK错误，还没发送完的 **缓冲区数据会被丢弃**，**只要当拖延时间到时，客户端的套接字没有经历完整的四次挥手的过程变成Closed状态，则会报EWOULDBLOCK错误**
    + ![unix_socket_51](/img/unix_socket_51.png)
    + ![unix_socket_52](/img/unix_socket_52.png)
    + ![unix_socket_53](/img/unix_socket_53.png)
  - close函数会**关闭读写两端**，禁止向缓冲区写入（write）数据和读取(read)数据,但**发送缓冲区中的数据依然会发送到对端**
  - shutdown则可以只关闭一边（读或写），所以还可以向缓冲区添加数据，或读取数据。
    + ![unix_socket_54](/img/unix_socket_54.png)
    
#### 6.3.7 ***SO_OOBINLINE***
带外数据将被留在正常的输入队列中。

#### 6.3.8 ***SO_RCVBUF和SO_SNDBUF***

这两个选项允许我们改变套接字**发送和接收缓冲区的缺省大小**。对于TCP来说，套接口的接收缓冲区中的可用空间限定了TCP通告对端的接收窗口大小（流量控制），UDP没有**流量控制**，所以会出现较快的发送端很容易淹没较慢的发送端。
  - 在设置TCP套接口缓冲区大小时，TCP的窗口规模在**建立连接时**用SYN与对端互换得到
    + 所以SO_RCVBUF选项必须在**调用connect之前**设置
    + 对于服务器，此选项必须在**listen 之前**设置
  - 套接口缓冲区的大小总是由新创建的已连接套接口从**监听**套接口**继承**而来
  - TCP套接口缓冲区的大小至少必须为相应连接的**MSS的四倍**（因为快速恢复机制：容纳一个响应＋3个重复响应）

#### 6.3.9 ***SO_RCVLOWAT和SO_SNDLOWAT***
接收低潮标记和发送低潮标记，供select函数使用

  - 当接收缓冲区中的 **可读数据大于或等于**接收低潮标记，触发select **“可读”**，默认为1字节
  - 当发送缓冲区中的 **可用空间大于或等于**发送低潮标记，触发select **“可写”**，默认为2048字节，且 **UDP的发送缓冲区的可用空间大小不会变化**（因为缓冲区不保留拷贝），所以UDP只要发送缓冲区大小大于或等于低潮标记，则总是"可写"。

#### 6.3.10 ***SO_RCVTIMEO和SO_SNDTIMEO***
这两个选项允许我们给套接字的接收和发送设置一个超时值，参数都是一个指向timeval结构的指针，默认情况下，这两个超时都是禁止的
  - 接收超时影响五个输入函数:read,readv,recv,recvfrom和recvmsg
  - 发送超时影响5个输出函数：write,writev,send,sendto和sendmsg

#### 6.3.11 ***SO_REUSEADDR和SO_REUSEPORT***
  - SO_REUSEADDR有如下四个功能
  
  > **1.允许启动一个\*\*监听服务器并捆绑其众所周知的端口\*\*，即使以前建立的将该端口用作它们的本地端口的连接仍存在**。这个场景通常是这样碰到的：
    + a) 启动一个监听服务器
    + b) 连接请求到达，派生一个子进程来处理这个客户
    + c) 监听服务器终止，子进程依然在提供服务
    + d) 重启监听服务器绑定到同样的端口（如果不设置SO_REUSEADDR将会绑定失败）
    
  > **2.允许同一端口启动同一服务器的多个实例，只要每个实例捆绑不同的IP地址即可**
    + 绑定三个服务器到三个不同地址，通配地址，198.69.10.128 和198.69.10.129,请求会分配到最好匹配的IP地址的服务器上去
    + 对于TCP，我们绝不能启动捆绑相同IP和相通端口的服务器，这是完全重复的捆绑
  > **3.允许单个进程捆绑同一个端口到多个不同IP的套接字上去**
  > **4.允许完全重复的捆绑，相同IP和相同端口，仅支持UDP套接口(用于多播)。**
    + **所用规则**：如果数据报的目的地址时一个广播地址或多播地址，那就给每个匹配的套接字递送一个该数据报的副本。如果是单播地址，且有多个套接字匹配该数据报，那么该选择由哪个套接字接收它取决于实现
    
  - SO_REUSEPORT的功能
    + 1.本选项允许完全重复的绑定，不过只有在想要捆绑同一IP地址和端口的每个套接字**都指定了套接字选项**才行
    + 2.如果被捆绑的IP地址时一个多播地址，那么SO_REUSEADDR和SO_REUSEPOPT被认为是等效的
  - 总结：
    + 1.在所有TCP服务器程序中，在调用bind之前设置SO_REUSEADDR套接字选项
    + 2.当编写一个可在同一时刻在同一主机上运行多次的多播应用时，设置SO_REUSEADDR套接字选项，并将所有参加多播组的地址作为本地IP地址捆绑

#### 6.3.12 SO_TYPE
返回套接口的类型，返回的整数值是一个诸如SOCK_STREAM或SOCK_DGRAM之类的值

#### 6.3.13 SO_USELOOPBACK
仅用于路由域（AF_ROUTE）套接口。默认打开（唯一一个默认打开的SO_XX类型选项），选项开启时，相应套接口将接收**在其上发送的任何数据报的拷贝**。

### 6.4 IPv4套接口选项
这些套接字选项由IPv4处理，它们的级别为IPPROTO_IP
#### 6.4.1 IP_HDRINCL
#### 6.4.2 IP_OPTIONS
  允许我们在IP首部设置IP选项
#### 6.4.3 IP_RECVDSTADDR
  导致所收到的UDP数据报的目的**IP地址**由recvmsg函数作为**辅助数据返回**
#### 6.4.4 IP_RECVIF
  导致所收到的UDP数据报的接收**接口索引**由recvmsg函数作为**辅助数据返回**
#### 6.4.5 IP_TOS
  允许我们为TCP、UDP或SCTP套接字设置IP首部中的**服务类型字段**（该字段包含DSCP和ECN子字段）
#### 6.4.6 IP_TTL
  设置或获取系统用在从某个给定套接字发送的单播分组上的**默认TTL值**（多播TTL值使用IP_MULTICAST_TTL套接字选项）

**默认值**：

1. TCP、UDP：64
2. 原始套接字：255

**给本选项调用getsockopt**：

1. 返回系统将用于外出数据报的字段的默认值
2. 没有办法从接收到的IP数据报中取得该值

### 6.5 TCP套接口选项
TCP有两个套接字选项， 它们的级别为IPPROTO_TCP
#### 6.5.1 TCP_MAXSEG选项

* 该选项允许我们**获取和设置TCP连接的最大报文段大小**（MSS），这个值通常由对端SYN报文段通告的MSS，在连接建立之前（没有收到对端的SYN），则获取的值为默认值。
* 如果我们使用**时间戳选项**时，通常实际用于连接中的最大报文段的大小**小于**该选项的返回值，因为时间戳选项在每个报文段中占用12字节
* 如果TCP支持**路径MTU发现**功能，那么他将发送的每个报文段的最大数据量会在**存活期内改变,上下调整**
* 一旦连接建立，则TCP报文段大小**不能超过**对端通告的MSS选项值，但可以**小于**该选项值。

#### 6.5.2 TCP_NODELAY选项

开启本选项将禁止TCP的Nagle算法，默认情况下，该算法是启动的。

Nagle算法的目的：防止一个连接**在任何时刻有多个小分组待确认**，减少网络中小分组（小于MSS）的传输，尽量将小分组**整合**到一个分组中传输，提高有效数据的传输效率。因为TCP总是尽可能地发送最大大小的分组。

Nagle算法的实现：如果某个给定连接上有**一个小分组没有得到确认**，则不能发送新的小分组到连接中。直到该小分组被确认后，才允许发送新的小分组。

Nagle算法带来的问题：使得用户的输入延迟更加明显

例子：Rlogin或Telnet客户端键入6个字符的串“hello!”,每个字符之间的输入准确相隔250ms,到服务器端的RTT为600ms,而且服务器端接收到数据后会立即发送该字符到客户端回显。

当Nagle算法被**禁止**时：
![unix_socket_55](/img/unix_socket_55.png)

当Nagle算法被**启用**时：
![unix_socket_56](/img/unix_socket_56.png)

Nagle算法常常与另一个TCP算法结合起来使用，**ACK停滞算法**，该算法使得TCP在接收到数据后不立即发送ACK，而是**等待一小段时间**（典型为50ms~200ms）,然后发送ACK。目的是为了在目的段等待一段时间，期望有数据要发送回源端。这样**被延滞的ACK就可以由这些数据捎带**，从而**节省**一个TCP分组。

**Nagle算法＋ACK停滞算法**的缺点：

1. 对于服务器**并不往回发送数据**(不用捎带)的客户来说，会明显察觉到延迟
2. 另一类不适合使用Nagle算法和TCP的ACK停滞算法是发送**单个逻辑请求**的客户，该请求由一个4字节的请求类型和后跟396字节的请求数据构成，这样396的请求数据必须要等4字节的请求响应才能被发送。明显增加延迟，有三个解决办法：
  - 使用**writev**而不是两次调用write,writev只会**产生一个TCP分节**
  - 把前4字节的数据和后396字节的数据**拷贝到单个缓冲区**，然后对该缓冲区调用一次**write**
  - 设置**TCP_NODELAY**套接口选项，继续调用write两次（**禁止使用Nagle算法和ACK停滞算法**），这个方法最不可取，会有损网络。


## 7.基本UDP套接口编程

下图中给出了典型的UDP客户/服务器程序的函数调用，客户不与服务器建立连接，只管使用sendto函数给服务器发送数据报，服务器不接受连接，只管recvfrom接收数据：
![unix_socket_57](/img/unix_socket_57.png)

### 7.1 recvfrom 和sendto函数
类似于标准的read和write函数，不过需要三个额外参数：

```
#include<sys/socket.h>

ssize_t recvfrom(int sockfd,void *buff,size_t nbytes,int flags,struct sockaddr *from,socklen_t *addrlen);

ssize_t sendto(int sockfd,const void *buff,size_t nbytes,int flags,const struct sockaddr *to,socklen_t addrlen);
```

前三个参数sockfd,buff,nbytes和read及write中的参数一致，flags参数暂时我们不关心，姑且认为均设置为0

* recvfrom: from指针和addrlen指针是值－结果参数，获取接收的数据报的来源地址from,返回值为接收的数据量大小。
* sendto: to表示数据报要发送的目的地址，addrlen（不为指针）为地址数据的大小，返回值同样是发送数据量的大小

**recvfrom和sendto可以用于TCP，但没有理由这么做，因为我们通过getsockname就可以获取到对端地址，没必要使用这两个函数**

### 7.2 UDP回射服务器程序
同TCP中的实现例子一样，这一章将会就同样的客户／服务器使用场景，并结合UDP的网络编程方式实现服务器端／客户端代码：

![unix_socket_58](/img/unix_socket_58.png)

服务器端接收到数据后回显给客户端部分的代码dg_echo:

![unix_socket_59](/img/unix_socket_59.png)

* 该循环**永不终止**，因为UDP是一个无连接的协议，没有像TCP有EOF之类的标记
* **迭代服务器**：TCP是**并发服务器**，因为一个客户就需要**维护一条连接**，一条连接对应一个套接口，UDP不需要维护连接，所以**一个进程，单个套接口**可以循环处理来自**多个客户**的数据
* UDP有**排队**发生：UDP套接口都有一个**接收缓冲区**，缓冲区排队的数据报以**FIFO**的方式返回给进程

### 7.3 UDP回射客户端程序

![unix_socket_60](/img/unix_socket_60.png)

客户端数据发送部分代码：

![unix_socket_61](/img/unix_socket_61.png)

这部分代码的问题：当客户端发送的数据报丢失，或服务器端发回的回显数据报丢失时，客户端的代码将一直阻塞于Recvfrom函数调用，防止这样阻塞的典型办法是给recvfrom设置一个超时，但这并不是一个完整的解决办法

![unix_socket_62](/img/unix_socket_62.png)

这部分修改的代码主要是**限制**发送数据报的服务器端地址和回显数据报的服务器端**地址一致**，才能在客户端回显。

* 服务器运行在只有单个IP地址上，这部分代码可以正常工作，然而如果服务器主机是**多宿**的，则回显可能会失败
* 当服务器发送数据时，**内核**将为封装这些应答的IP数据报**选择源地址**，选为源地址的是外出接口的**主IP地址**，如果我们客户端是向非主IP地址发送的数据报，则发送回显数据报的IP就会和客户端中的服务器端地址不一致，导致回显失败

解决办法：

1. 客户端不通过比较IP地址来验证是否来自同一主机，而是**通过DNS**来验证比较域名
2. 服务器中为每一个IP创建一个套接口，**绑定每个IP地址到每个套接口**中去，使得一个套接口传送和接收数据只能对应一个IP地址

### 7.4 服务器进程未运行

当我们不启动服务器，而启动客户端向服务器端发送数据报，客户端将永远阻塞于它的recvfrom调用。

这个过程中，我们启动tcpdump来观察底层协议输出：

![unix_socket_63](/img/unix_socket_63.png)

* 我们从第四行看到，主机响应了port unreachable的ICMP消息，但这个错误并不会返回给客户进程，并且客户进程依然永远阻塞在recvfrom系统调用
* sendto成功返回只表示着将数据报拷贝到**输入队列缓冲区**
* 一个基本规则：对于UDP套接口，由它引发的**异步错误**却并不返回给它，除非它**已连接**。
  - 原因：因为当recvfrom收到一个出错ICMP数据报，如果返回给进程，**recvfrom只能返回出错码errno**,并不能获取出错来源的**宿IP地址和UDP端口号**（因为没有连接，这些信息丢失后就无法再次获取）

### 7.5 UDP的connect函数

在上一节我们提到，除非套接口已经连接否则**异步错误**是不会返回到UDP套接口的。我们确实可以给UDP套接口调用connect, 然而这样做的结果却和TCP连接相差很多，**没有三次握手**的过程，所以一端套接口调用connect**只会影响到这一端**的发送信息，对connect连接的**对端没有产生任何影响**

实际上，一段调用connect,只是在这一端的套接字的信息中**记录对端的IP地址信息和端口**，发送数据时，只向该纪录的IP地址和端口发送数据报，同时接收数据时，也只接收来自该IP地址的数据报。

所以我们需要区分：
* **未连接UDP套接口**
* **已连接套接口**

对于已连接UDP套接口，与未连接的套接口相比，主要有三点变化：

1. 对于已连接的套接口输入数据时，我们不能指定对端IP地址和端口号，所以一般**不需要使用sendto**（使用时第五个参数一般为空指针）,而是使用**write和send**.套接口会自动发送到connect指定的协议地址
2. 我们不必使用recvfrom来获得数据报的发送端的IP地址和端口号，而是用**read,recv或recvmsg**,如果收到**不是来自**之前connect指定的IP地址和端口号，传输层**不会投递**到该套接口。
3. 由已连接UDP套接口引发的**异步错误**返回给它们所在的进程，而未连接UDP套接口**不接受任何异步错误**（防止对端IP丢失，已连接不需要担心这个问题）

![unix_socket_65](/img/unix_socket_65.png)

![unix_socket_66](/img/unix_socket_66.png)

总结：

* 当客户端进程或服务器端进程仅仅在使用自己的UDP套接口与确定的唯一对端进行通信时才可以调用connect，大部分都是UDP客户调用connect,只有小部分网络应用的UDP服务器会与单个客户长时间通信（TFTP），客户端和服务器端会都调用connect,维持长时间固定对端的通信。

#### 给一个UDP套接口多次调用connect

拥有一个已连接UDP套接口的进程再次调用connect是为下列两个目的：

1. 指定新的IP地址和端口号（设置新地址）
2. 断开套接口（设置地址为AF_UNSPEC）

#### 性能分析

当应用程序在一个未连接的UDP上调用两次sendto会经历下面六个步骤：

1. 连接套接口
2. 输出第一个数据报
3. 断开套接口连接
4. 连接套接口
5. 输入第二个数据报
6. 断开套接口连接

当套接口连接后，调用两次write操作会经历：

1. 连接套接口
2. 输出第一个数据报
3. 输出第二个数据报

当应用程序知道要给同一宿地址发送多个数据报时，**显示连接**套接口更有效率。

### 7.6 使用已连接的UDP套接口修改客户端代码

![unix_socket_64](/img/unix_socket_64.png)

该代码运行在服务器为**多宿**机的情况下，客户端通过已连接的UDP套接字发送数据报到服务器端，服务器端用外出接口的主IP地址返回数据报到客户端，而该主IP和已连接的UDP套接字**connect信息不匹配**，所以客户端产生**ICMP错误**：“udp port 9877 unreachable”。返回给客户端的应用进程

### 7.7 UDP缺乏流量控制

当UDP缓冲区满的时候，新发送的数据报很容易被丢弃，从而导致发送端淹没接收端

### 7.8 UDP中的外出接口确定

我们可以创建一个数据报套接字，**不绑定bind**端口及IP，然后和一个目的端IP地址及端口号进行连接**connect**，然后通过**getsockname**来获取连接后系统给该套接字指派的**临时端口号**及**外出接口的主IP地址**

### 7.9 利用select实现TCP和UDP复用的服务器程序

思路：创建TCP和UDP套接字**绑定在同一端口**，然后利用select对两个套接字都设置监听，当任一套接口可读时，**检测**是哪一个套接口可读，TCP(**并发服务器**)就调用**Fork**生成子程序来处理数据，UDP（**迭代服务器**）直接进行处理然后调用**Sendto**发送回客户端。

![unix_socket_67](/img/unix_socket_67.png)
![unix_socket_68](/img/unix_socket_68.png)

## 8. 高级I/O函数

这这一章将从以下几个部分进行讲解：

* 如何在I/O操作上设置超时（三种方法）
* 讲解read和write这两个函数的三个变体
  - readv,writev
  - recv,send
  - recvmsg,sendmsg
* 如何确定套接口接收缓冲区中的数据量
* 如何在套接口使用C的标准I/O函数库
* 介绍T/TCP，可以避免三次握手的开销

### 8.1 如何给I/O操作设置超时

1. 调用alarm,它到时会发送SIGALARM信号，然后设置信号处理函数中断I/O操作
2. 利用select来封装I/O操作，将read或要write的套接字描述符用select监听是否可读可写，超时后返回0，如果可读可写再调用对应的I/O操作
3. 通过对套接字设置SO_RECVTIMEO和SO_SNDTIMEO来设置读写超时。

#### 利用alarm设置超时

利用alarm函数设置超时然后为connect封装一个带有连接超时限制的函数：前三个参数用于调用connect函数，第四个参数用于设置超时限制

![unix_socket_69](/img/unix_socket_69.png)

利用alarm给recvfrom设置超时：

![unix_socket_70](/img/unix_socket_70.png)

#### 使用select为recvfrom设置超时

将具有超时限制的recvfrom封装为一个函数，具有两个参数：一个要监听的描述符，一个为要设置的超时限制。

![unix_socket_71](/img/unix_socket_71.png)
![unix_socket_72](/img/unix_socket_72.png)

#### 利用SO_RECVFROM套接口选项为recvfrom设置超时

![unix_socket_73](/img/unix_socket_73.png)

### 8.2 recv和send函数

这两个函数类似于标准的read和write函数，但多一个额外的参数。
```
#include <sys/socket.h>

ssize_t recv(int sockfd,void *buff,size_t nbytes,int flags);

ssize_t send(int sockfd,const void *buff,size_t nbytes,int flags);

```

前三个参数和read,write相同，最后一个参数flags参数的值或为0，或为下列一个或多个常值的逻辑与：
![unix_socket_74](/img/unix_socket_74.png)

* **MSG_DONTROUTE**:这个标志告诉内核宿主机在某个直接连接的本地网络上，**无需路由表查找**，我们随SO_DONTROUTE套接口选项提供了本特性的额外信息。SO_DONTROUTE可以设置**该套接口的所有输出操作**，也可以，用MSG_DONTROUTE指定**单次**的输出操作。
* **MSG_DONTWAIT**:即使套接口没有打开非阻塞选项，我们也可以通过该标志将单个I/O操作设置为非阻塞的
* **MSG_OOB**:对于send，该标志说明要发送**带外数据**（优先级高的数据），recv则说明即将读入的是带外数据而不是普通数据
* **MSG_PEEK**:适用于recv和recvfrom允许我们**窥看已可读取**的数据，不过系统不丢弃recv和recvfrom窥看走的数据
* **MSG_WAITALL**:告知内核不要在尚未读入请求数目的字节之前让一个读操作返回

### 8.3 readv和writev函数

这两个寒暑类似于read和write，但区别在于，readv和writev可以读取或写入到**一个或多个**缓冲区。这些操作叫做**"分散读，集中写"**。

```
#include<sys/uio.h>

ssize_t readv(int filedes,const struct iovec *iov, int iovcnt);

ssize_t writev(int filedes,const struct iovec *iov, int iovcnt);
```

第二个参数都是指向某个iovec结构数组的一个指针，其中iovec 结构在头文件中定义：

```
struct iovec{
  void *iov_base;//缓冲区起始地址
  size_t iov_len;//长度
};
```

* 在这两个函数中俄iovec结构数组中元素的数目存在某种**限制**，Linux和4.3BSD最多为1024个，HP-UX为2100个
* writev是一个**原子**操作，对于UDP协议而言的话，一次writev操作只**产生一个数据报**
* 在前面套接字选项章节时，我们提到**TCP_NODELAY**套接口选项，还可以用writev来避免Nagle算法，因为他会将4字节和数据和396字节的数据**集中**写到一个数据报中去。

### 8.4 recvmsg和sendmsg函数

这两个函数是最通用的函数，实际上我们可以把所有read、readv（分散读）、recv（可以设置读取选项）和recvfrom（可以获取来源地址）替换成recvmsg来调用。类似的各种写操作可以换成sendmsg来调用。

```
#include <sys/sokcet.h>

ssize_t recvmsg(int socketfd,struct msghdr *msg,int flags);

ssize_t sendmsg(int sockfd,struct msghdr *msg,int flags);

```
这两个函数相当于将其他函数的所需要的参数全部封装到结构体msghdr结构题中去。
```
struct msghdr{
  //对应recvfrom参数:协议地址＋长度
  void *msg_name;//数据来源协议地址
  socklen_t msg_namelen;//协议地址数据长度
  //对应readv参数：*iovec(缓冲区起始地址＋长度)+数组元素个数iovcnt
  struct iovec *msg_iov;//iovec缓冲区地址数组
  int msg_iovlen;//数组中的元素个数
  void *msg_control;//辅助数据数组
  socklen_t msg_controllen;//辅助数据数组元素个数
  //对应recv参数：可以设置选项flags.
  int msg_flags;

}
```

* 与recvfrom和sendto对应的参数：msg_name,msg_namelen
* 与readv和writev对应的参数为：msg_iov,msg_iovlen
* 区分flags参数（值）和msghdr中的msg_flags参数（引用）
  - **recvmsg**时使用的是**后者msg_flags**参数，将**flags**拷贝到msg_flags中去作用来告知内核某个选项被打开,内核还依据recvmsg结果更新msg_flags成员的值
  - **sendmsg**则忽略msg_flags标志，**直接使用flags**标志告知内核。

flags和msg_flags作用函数总结如下表：

![unix_socket_75.png](/img/unix_socket_75.png)

下图展示了一个msghdr结构以及它指向的各种信息：我们假设进程即将对一个UDP套接口调用recvmsg

![unix_socket_76.png](/img/unix_socket_76.png)

当我们从192.6.38.100：2000端口到达了一个170字节的UDP数据报要发送，它的目的地址为206.168.112.96，下图展示recvmsg返回时msghdr结构中的所有信息：

![unix_socket_77.png](/img/unix_socket_77.png)

下图汇总了5组I/O函数之间的差异：

![unix_socket_78.png](/img/unix_socket_78.png)

### 8.5 辅助数据

这一小节介绍辅助数据的用途，结构和一些相关的宏

下图为辅助数据一些常见用途：
![unix_socket_79.png](/img/unix_socket_79.png)

辅助数据结构由一个个辅助数据对象构成的数组，每个辅助数据的对象又是以描述该对象的cmsghdr开头：

```
struct cmsghdr{
  socklen_t cmsg_len;//辅助有效数据的长度
  int cmsg_level;//协议类型
  int cmsg_type;//选项类型
  //后面跟着cmsg_data[]
}
```

下图为包含两个辅助对象的辅助数据：
![unix_socket_80.png](/img/unix_socket_80.png)

下图为通过一个Unix域套接字传递描述符，和传递凭证时cmsghdr的格式：
![unix_socket_81.png](/img/unix_socket_81.png)

#### 操作辅助数据的5个宏
由于recvmsg返回的辅助数据可含有任意数目的辅助数据对象，为了对应用程序屏蔽可能出现的填充字节，头文件中定义了5个宏，来简化对辅助数据的操作：
![unix_socket_82.png](/img/unix_socket_82.png)

使用这五个宏的操作伪代码实例：
![unix_socket_83.png](/img/unix_socket_83.png)

### 8.6 排队的数据量

我们如果想在不读取数据的前提下知道一个套接口已有多少数据排队等着读取，有三个技术可用于获悉已排队的数据量：

1. 如果我们获取已排队的数据量的目的是**避免读操作阻塞**，使用**非阻塞I/O**即可
2. 如果我们即想查看数据，又想数据留在接受队列之中，使用MSG_PEEK选项，如果我们不能确定是否有数据可读，结合使用非阻塞套接口使用该标志，也可以组合使用MSG_DONTWAIT和MSG_PEEK
  * 对于字节流套接口，数据没有边界，第一次调用recv并**结合MSG_PEEK**可获取的数据量，和第二次**不使用MSG_PEEK**获取的数据量可能**发生变化**。
  * 对于数据报套接口，数据报是有确定边界的，第一次调用recv并**结合MSG_PEEK**可获取的数据量，和第二次**不使用MSG_PEEK**获取的数据量是**完全一样**的。
3. 利用ioctl的FIONREAD命令，获取套接口接受队列的当前字节数。

### 8.7 套接口和标准I/O函数

之前所介绍的所有I/O函数都是围绕描述字工作，通常作为Unix内核中的系统调用实现，执行I/O的另一个方法是使用标准I/O库函数。

标准I/O库处理I/O时我们必须考虑到一些细节：自动缓冲输入和输出流的问题。

标准I/O函数库可以用于套接口，不过需要考虑到以下几点：

1.  通过调用**fdopen**函数，可以从任何一个描述服创建一个标准的I/O流。类似，调用**fileno**可以获取一个给定标准I/O流对应的描述符。
2.  TCP和UDP套接口是全双工的，标准I/O流也是也可以是全双工的，只要**指定"r+"** (读写)打开流即可
  - 我们不能在这样的流上调用一个输出函数(write)后，不调用fflush,fseek,fsetpos或rewind调用就接着调用一个输入函数（read）
  - 同样，我们不能在一个输入函数(read)后面，不调用fseek,fsetops或rewind调用就跟着一个输出函数(write)。
  - 并且fseek,fsetpos和rewind三个函数都调用lseek,而lseek用在套接口上会失败
  - **解决这个问题最好的办法就是打开两个标准I/O流，一个只用于读，一个只用于写**

使用标准I/O函数的str_echo函数：

![unix_socket_84.png](/img/unix_socket_84.png)

利用这个函数对三行文本数据实现回射的话，服务器只有在接受到EOF之后才会向服务器回射这三行文本，原因在于缓冲问题：

* 客户端发送到服务器端的三行数据首先会**被标准输入流完全缓冲**，缓冲区没满时，**不会写入到套接字缓冲区**。
* 当输入EOF时，函数退出，C库函数**调用标准I/O清理函数**，标准的I/O缓冲区才被输入到套接字缓冲区进行回射
* 随后才进行四次挥手

标准I/O函数库执行以下三类缓冲：
1. **完全缓冲**：只有在缓冲区满，或进程显示调用fflush,或进程调用exit终止自身发生时才进行I/O操作,通常标准I/O缓冲区大小为8192字节
2. **行缓冲**：在碰到**换行符**，或进程显示调用fflush,或进程调用exit终止自身发生时才进行I／O
3. **不缓冲**：每次调用标准I/O输出函数，都会真正发生I/O

Unix标准I/O函数库规则：

  - **标准错误输出**总是不缓冲
  - **标准输入和标准输出，和所有其他I/O流**都是完全缓冲，除非是终端设备，则行缓冲

PS:尽量**避免在套接口**上使用标准I/O函数库

## 9.Unix域协议
Unix域协议并不是一个实际的协议族，而是在单个主机上执行客户/服务器通信的一种方法，所有API也有所不同。我们可以将Unix域协议视作一种IPC方法

Unix域协议提供两种套接口：

* 字节流套接口
* 数据报套接口

使用Unix域协议无非有三个原因：

1. 快，在同一主机上，使用Unix域协议比TCP套接口快上一倍（因为无需经过协议对数据的封装）
2. 传递描述符
3. 传递凭证（用户ID和组ID）

### 9.1 Unix域套接口地址结构

```
struct sockaddr_un{
  sa_family_t sun_family;/*AF_LOCAL*/
  char sun_path[104];
};
```
**Unix域协议地址**：用于标识客户和服务器的协议地址是**普通文件系统中的路径名**。这些路径名不是普通Unix文件：除非把它们和Unix域套接字关联起来，否则无法读写这些文件。

* sun_path：Unix域协议地址，存放在其中的路径名必须以**空字符**结尾。未指定地址以空字符串作为路径名指示（即sun_path[0]值为0的地址结构），它等价于IPv4的**INADDR_ANY常值**和IPv6的**IN6ADDR_ANY_INIT常值**

Unix域套接口的bind调用：

![unix_socket_85.png](/img/unix_socket_85.png)

### 9.2 socketpair函数

该函数用于创建两个已经连接好的套接口，这个函数仅适用于Unix域套接口：

```
#include<sys/socket.h>

int socketpair(int family,int type,int protocol,int sockfd[2]);

```
* family参数必须为AF_LOCAL
* protocol参数必须为0
* type参数可选项为：SOCK_STREAM,SOCK_DGRAM。
* 该函数新创建的两个套接口描述字会作为sockfd[0]和sockfd[1]返回
* 新创建的两个套接口不曾命名，也就是说没有涉及到隐式的bind调用
* 当指定type为SOCK_STREAM时，创建的是一种流管道，它与调用pipe创建的普通管道Unix管道类似，差别在于流管道是全双工的。

### 9.3 套接口函数

用在Unix域套接口时，套接口函数中存在一些差异和限制。如下：

1. bind创建的路径名**默认访问权限为0777**
2. 与Unix域套接口关联的路径名应该时一个**绝对路径名**
3. connect调用中指定的路径名必须是一个**当前绑定在某个打开**的Unix域套接口上的路径名。绑定过程可能报下面**三个**错误
  - 该路径名已经存在但**不是一个套接口类型的文件**
  - 该路径名存在且是一个套接口类型的文件，但**没有与之关联的打开的描述符**
  - 该路径名存在而且是一个打开的套接口，不过套接口**类型不符合**
4. 调用connect连接一个Unix域套接口涉及的**权限测试等同于**调用open以只写方式访问相应的路径名
5. Unix域字节流套接口类似于TCP套接口，都为进程提供一个**无记录边界**的字节流套接口
6. Unix域数据报套接字类似于UDP套接字：都提供一个**保留记录边界的不可靠**的数据报服务
7. 如果对于某个Unix域字节流套接字的connect调用发现这个**监听套接字的队列已满**，调用就立即返回一个**ECONNREFUSED错误**（对于TCP，监听套接字会忽略新到达的SYN，而TCP连接发起端将**数次发送SYN进行重试**）
8. **不同于字节流套接字**：在一个未绑定的Unix域套接字上**发送数据报不会自动**给这个套接字**捆绑一个路径名**（在一个未绑定的UDP套接字上发送UDP数据报导致给这个套接字捆绑一个临时端口）,如果发送端不绑定一个路径名则，目的端**无法回射**数据给发送端
9. 类似8，对于某个Unix域数据报套接字的**connect调用**不会给本套接字捆绑一个路径名

### 9.4 Unix域字节流客户端／服务器程序

####  服务器端

服务器做的工作就是创建一个Unix域套接字，然后绑定到一个路径上监听，随后阻塞在accept系统调用上等待连接请求。请求到达后创建子进程提供服务。

![unix_socket_86.png](/img/unix_socket_86.png)

#### 客户端

客户端代码创建一个Unix域套接字，然后connect连接到服务器端绑定的路径名。

![unix_socket_87.png](/img/unix_socket_87.png)

### 9.5 Unix域数据报客户／服务器程序

#### 服务器端

数据报服务器端，主要是套接口创建的区别：

![unix_socket_88.png](/img/unix_socket_88.png)

#### 客户端
数据报客户端的套接口必须要**显式绑定**路径名，否则服务器端recvfrom无法获取客户端的路径从而**无法回射**数据到客户端。

![unix_socket_89.png](/img/unix_socket_89.png)

### 9.6 描述符传递

当从一个进程到另一个进程传递文件描述符的时候有两种场景：

1. fork调用之后，子进程会共享父进程所有打开的文件描述符，然后子进程打开待传递的描述符传递给父进程
2. 不具有亲缘关系的两个进程传递文件描述符，通过创建Unix域套接字，然后sendmsg利用辅助数据传递文件描述符

两个进程中传递描述符的步骤如下：

1. 创建一个字节流或数据报的Unix域套接口。
  - 如果是场景1（父子进程）：父进程调用**socketpair**创建一个流管道，通过这个流管道sockfd[2]来传递描述符
  - 如果是场景2（不具有亲缘关系）：服务器进程创建一个**Unix域套接口**，**bind**到一个路径名，客户进程也创建一个Unix域套接口，**Connect**到服务器绑定的路径名上，然后传递描述符
2. 在步骤一之后两个进程之间用于传递描述符的套接字已经创建后，接下来就是传递描述符的过程，首先我们要传递的描述符**可以是任何类型**：open,pipe,mkfifo,socket,accept打开的描述符都可以传递。
3. 发送进程创建一个**msghdr结构**，其中含有待传递的描述字，作为**辅助数据**传输，发送一个描述符，会使得该描述符的**引用计数加1**
4. 接受进程调用recvmsg接收描述符，接受进程中的描述符和发送进程中的描述符**可能不同**，这涉及到在接收进程中**创建一个新的描述符**，而这个新的描述符和发送进程中的旧描述符指向的**文件表项是相同的**。

#### 实例

该例子的功能如下：mycat程序，通过命令行参数取得一个路径名，打开这个文件并拷贝到标准输出。

代码执行细节：
1. 主函数main**获取参数**指定路径，调用my_open函数完成文件打开操作
2. my_open函数实现中，将文件打开的部分交由（Fork）**子进程**执行
3. 子进程**执行exec交由openfile程序**完成对指定路径名文件的打开操作
4. 在子进程获取文件描述符，并传递给父进程。
5. 父进程根据文件描述符**读取文本数据**显示到标准输出。

![unix_socket_90.png](/img/unix_socket_90.png)

父进程要给openfile程序传递三个参数：

1. 待打开的文件路径名
2. 打开方式
3. 流管道中openfile端使用的端口描述符号

* 并且程序的退出状态来告知父进程文件能否打开，若不能打开要告知发生什么类型的错误
* 通过exec执行另一个程序来打开文件的优势在于，另一个程序可以是一个setuid到root的程序，能够打开我们通常没有打开权限的文件

***mycat程序：***

1. 主函数如下：

  ![unix_socket_91.png](/img/unix_socket_91.png)

2. my_open函数的实现：创建子进程，exec openfile程序

  ![unix_socket_92.png](/img/unix_socket_92.png)

3. Read_fd函数实现：父进程从流管道sockfd[0]接收文件描述符
  ![unix_socket_93.png](/img/unix_socket_93.png)

***openfile程序：***

1. 主函数如下：

![unix_socket_94.png](/img/unix_socket_94.png)

2. write_fd函数如下：通过流管道发送文件描述符到父进程。
![unix_socket_95.png](/img/unix_socket_95.png)
![unix_socket_96.png](/img/unix_socket_96.png)

### 9.7 传递凭证
传递凭证的使用场景往往在于客户和服务器通信时，服务器通常需要以一定手段获悉客户的身份，以便验证客户是否具有权限请求相应的服务

传递凭证和传递描述符类似，同时通过sendmsg和recvmsg及辅助数据来传递，区别在于传递凭证时的**凭证数据**有所区别，且**描述辅助数据的cmsghdr**也有所区别：

凭证数据如下：
```
//即通过宏CMSG_DATA(msg_control)得到的数据
struct cmsgcred{
  pid_t cmcred_pid;//发送进程的进程ID
  uid_t cmcred_uid;//发送进程的用户世纪ID
  uid_t cmcred_euid;//发送进程的有效ID
  gid_t cmcred_gid;//发送进程的组ID
  short cmcred_ngroups;//组的数量
  gid_t cmcred_groups[CMGROUP_MAX];//组
}
```

描述凭证数据的cmsghdr如下：

```
cmptr->cmsg_level = SOL_SOCKET;
cmptr->cmsg_type = SCM_CREDS;
```

具体实例不再赘述，见书P370
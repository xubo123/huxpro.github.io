---
layout:     post
title:      "LeetCode题目思路整理"
subtitle:   "LeetCode"
date:       2018-05-14 15:00:00
author:     "Xu"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - LeetCode
---

# LeetCode刷题思路

**LeetCode**


主要tag：数组、字符串、链表、树、栈、队列、动态规划、哈希表、二分查找

题目分类：

* [**数据搜索和查找（哈希表，二分法）**](#数据搜索及查找哈希表二分法)
    - [如何找到两个排序数组的中位数？(LeetCode4:Median of Two Sorted Arrays)](#leetcode4)
    - [在翻转数组中查找指定数据（LeetCode33: Search in Rotated Sorted Array](#leetcode33)
    - [搜索一个数字在一个递增数组（允许数字重复）中出现的范围(LeetCode34:Search for a Range)](#leetcode34)
    - [判断数独二维数组是否合法(LeetCode36: Valid Sudoku)](#leetcode36)
    - [找到第一个未出现的正数（LeetCode41: First Missing Positive）](#leetcode41)
    - [设置矩阵0项的行和列（LeetCode73:Set Matrix Zeroes](#leetcode73)
    - [最长连续序列（LeetCode128:Longest Consecutive Sequence）](#leetcode128)
    - [LRU缓存（LeetCode146:LRU Cache）](#leetcode146)
    - [查找第n大的元素（LeetCode215:Kth Largest Element in an Array）](#leetcode215)
    - [查找是否存在重复元素（LeetCode217：Cantains Duplicate）](#leetcode217)
    - [二位数组搜索指定数值（LeetCode240：Search a 2D Matrix II）](#leetcode240)
    - [找到重复数字(LeetCode287:Find the Duplicate Number)](#leetcode287)
    - [返回右边小于当前数的计数数组](LeetCode315:Count of Smaller Numbers After Self)(#leetcode315)
* [**动态规划**](#动态规划)
    - [ 找到最长回文子字符串(LeetCode5:Longest Palindromic Substring)](#leetcode5)
    - [字符串匹配“.*”(LeetCode10:Regular Expression Matching)](#leetcode10)
    - [字符串匹配："?*"(LeetCode44:Wildcard Matching)](#leetcode44)
    - [计数后用字符串表达（LeetCode38:Count and Say](#leetcode38)
    - [最大子序列和（LeetCode53:Maximum Subarray）](#leetcode53)
    - [机器人走格子路径（LeetCode62：Unique Paths）](#leetcode62)
    - [求解码方法总数（LeetCode91:Decode Ways）](#leetcode91)
    - [入室抢劫（LeetCode198: House Robber）](#leetcode198)
    - [剩余数组乘积（LeetCode238：Product of Array Except Self](#leetcode238)
    - [完全平方和（LeetCode279：Perfect Squares）](#leetcode279)
    - [最长升序序列（LeetCode300：Longest Increasing Subsequence）](#leetcode300)
    - [最小硬币找零方案(LeetCode322:Coin Change)](#leetcode322)
    - [递增的三元子序列(LeetCode334: Increasing Triplet Subsequence)](#leetcode334)

* [**递归**](#递归)
    - [手机号码的字符串组合（LeetCode17:Letter Combinations of a Phone Numbe）](#leetcode17)
    - [排列组合（LeetCode 46: Permutations）](#leetcode46)
    - [n x n矩阵的旋转（LeetCode48: Rotate Image）](#leetcode48)
    - [旋转打印矩阵（LeetCode54：Spiral Matrix）](#leetcode54)
    - [求数组所有可能的子集（LeetCode78：Subsets](#leetcode78)
    - [二维数组中的字符串匹配（LeetCode79:Word Search）](#leetcode79)
    - [回文分割（LeetCode131:Palindrome Partitioning）](#leetcode131)
    - [岛屿的数量 （LeetCode200:Number of Islands）](#leetcode200)
    - [课程安排 （LeetCode207：Course Schedule）](#leetcode207)
    - [课程表II（LeetCode210：Course ScheduleII）](#leetcode210)
    - [二维数组最长路径递归(LeetCode329:Longest Increasing Path in a Matrix)](#leetcode329)

* [**位运算,数学,边界问题**](#位运算数学边界问题)
    - [整型数反转(LeetCode7:Reverse Integer)](#leetcode7)
    - [两个整型数做除法，不使用乘除运算符(LeetCode29:Divide Two Integers)](#leetcode29)
    - [求幂myPow()(LeetCode50: Pow(x, n))](#leetcode50)
    - [求平方根（LeetCode69:Sqrt(x)）](#leetcode69)
    - [n的阶乘尾部0的个数（LeetCode172:Factorial Trailing Zeroes）](#leetcode172)
    - [将所有数字拼成一个最大数（LeetCode179：Largest Number）](#leetcode179)
    - [翻转bits(LeetCode190: Reverse Bits)](#leetcode190)
    - [位为1的个数（LeetCode191:Number of 1 Bits）](#leetcode191)
    - [快乐数（LeetCode202: Happy Number）](#leetcode202)
    - [质数计数（LeetCode204：Count Primes）](#leetcode204)
    - [基础计算器II（LeetCode227：Basic Caculator II）](#leetcode227)
    - [缺失数字（LeetCode268： Missing Number）](#leetcode268)
    - [判断是否为3的幂(LeetCode326:Power of Three)](#leetcode326)

* [**数据分类**](#数据分类)
    - [字符串分类(LeetCode49：Group Anagrams)](#leetcode49)
* [**树**](#树)
    - [二叉树的中序遍历（LeetCode94:Binary Tree Inorder Traversal）](#leetcode94)
    - [验证是否是二叉搜索树（LeetCode98:Validate Binary Search Tree）](#leetcode98)
    - [验证是否是对称树（LeetCode101:Symmetric Tree）](#leetcode101)
    - [层次遍历打印（LeetCode102:Binary Tree Level Order Traversal）](#leetcode102)
    - [Zigzag打印(LeetCode103:Binary Tree Zigzag Level Order Traversal)](#leetcode103)
    - [求二叉树的高度（LeetCode104:Maximum Depth of Binary Tree）](#leetcode104)
    - [根据前序和中序遍历序列构造树结构（105： Construct Binary Tree from Preorder and Inorder Traversal）](#leetcode105)
    - [根据递增序列构造二叉查找树（LeetCode108:Convert Sorted Array to Binary Search Tree](#leetcode108)
    - [将树每一层用链表连接（LeetCode116:Populating Next Right Pointers in Each Node）](#leetcode116)
    - [求树中最大路径和（LeetCode124：Binary Tree Maximum Path Sum）](#leetcode124)
    - [求树中第k大的元素（LeetCode230：Kth Smallest Element in a BST）](#leetcode230)
    - [求两个节点的第一个公共祖先（LeetCode236：Lowest Common Ancestor of a Binary Tree）](#leetcode236)
    - [二叉树的序列化和反序列化(LeetCode297:Serialize and Deserialize Binary Tree)](#leetcode297)
    
* [**图**](#图)
    - [单词接龙（LeetCode127:Word Ladder）](#leetcode127)
    - [被围绕的区域（LeetCode130:Surrounded Regions）](#leetcode130)

* [**链表**](#链表)
    - [复制带有随机指针的链表（LeetCode138:Copy List with Random Pointer）](#leetcode138)
    - [链表排序(LeetCode148:Sort List)](#leetcode148)
    - [回文链表（LeetCode234：Palindrome Linked List）](#leetcode234)
    - [删除链表给定节点（LeetCode237：Delete Node in a Linked List）](#leetcode237)
    - [奇偶链表(LeetCode328:Odd Even Linked List)](#leetcode328)

* [**数据结构**](#数据结构)
    - [计算逆波兰表达式(LeetCode150: Evaluate Reverse Polish Notation)](#leetcode150)
    - [滑动窗口最大值（LeetCode239: Sliding Window Maximum）](#leetcode239)
    - [数据流中的中位数(LeetCode295:Find Median from Data Stream)](#leetcode295)
    - [前k个高频元素](LeetCode347:Top K Frequent Elements)(#leetcode347)
   

* [**其它**](#其它)
    - [装水最多的容器(LeetCode11:Container with most water)](#leetcode11)
    - [计算容器可以装多少水(LeetCode42:Trapping Rain Water)](#leetcode42)
    - [罗马数转化为整数（LeetCode13:Roman to Integer）](#leetcode13)
    - [三个数相加为0(LeetCode15:3Sum)](#leetcode15)
    - [产生所有可能的有效括号组合（LeetCode22:Generate Parentheses）](#leetcode22)
    - [合并k个排序链表（LeetCode23: Merge k Sorted Lists）](#leetcode23)
    - [跳跃游戏（LeetCode55: Jump Game）](#leetcode55)
    - [区间合并(LeetCode56: Merge Intervals)](#leetcode56)
    - [颜色排序（LeetCode75:Sort Colors）](#leetcode75)
    - [最小匹配窗口（LeetCode76:Minimum Window Substring）](#leetcode76)
    - [求最大面积子矩阵](#leetcode84)
    - [股票交易（LeetCode122:Best Time to Buy and Sell Stock II）](#leetcode122)
    - [有效回文（LeetCode125:Valid Palindrome）](#leetcode125)
    - [汽油站（LeetCode134:Gas station）](#leetcode134)
    - [求数组中的主元素（LeetCode169：Majority Element）](#leetcode169)
    - [Excel列号转换（LeetCode171:Excel Sheet Column Number）](#leetcode171)
    - [循环移动数组（LeetCode189:Rotate Array）](#leetcode189)
    - [移动0元素（LeetCode283：Move Zeros）](#leetcode283)
    - [生命游戏(LeetCode289：Game of Life)](#leetcode289)
    - [摇摆排序(LeetCode324：Wiggle SortII)](#leetcode324)


|  #   |  Title  |        Solution        | Difficulty | Tag  |
| :--: | :-----: | :--------------------: | :--------: | :--: |
|  1   |  两个排序数组的中位数 | [O](#leetcode4) |    Hard    | 数组 \| 数据搜索|
|  5   | 最长回文子串 | [O](#leetcode5) |    Medium    | 字符串 \| 动态规划 |
|  7   | 反转整数 | [O](#leetcode7) |    Easy    | 数学 \| 其他 |
|  8   | 字符串转整数 | [O](#leetcode8) |    Medium    | 字符串 |
|  10 | 字符串常规匹配 | [O](#leetcode10) |    Hard    | 字符串 \| 递归 \|动态规划 |
|  11 | 盛最多水的容器 | [O](#leetcode11) |    Medium    | 数组 |
|  13 | 罗马数字转整数 | [O](#leetcode13) |    Easy    | 字符串 |
|  15 | 三数之和 | [O](#leetcode15) |    Medium    | 数组 \| 两点法 |
|  17 | 电话号码的字母组合 | [O](#leetcode17) |    Medium    | 字符串 \| 递归|
|  20 | 有效的括号 | [O](#leetcode20) |    Easy    | 字符串 \| 回溯法 |
|  21 | 合并两个有序链表 | [O](#leetcode21) |    Easy    | 链表 \| 优先级队列 \| 归并法 |
|  29   | 两数相除 | [O](#leetcode29) |    Medium    | 数学 \| 位运算|
|  33   | 搜索旋转排序数组 | [O](#leetcode33) |    Medium    | 数组 \| 二分查找 |
|  34   | 搜索范围 | [O](#leetcode34) |    Medium    | 数组 \| 二分查找 |
| 35 | 搜索插入位置 | [O](#leetcode35) | Easy | 数组 \| 二分查找 |
| 36 | 有效的数读独 | [O](#leetcode36) | Medium | 数组 \| 哈希表 |
| 38 | 报数 | [O](#leetcode38) | Easy | 数学 |
| 41 | 寻找第一个未出现的正数 | [O](#leetcode41) | Medium | 数组 \| 哈希表 |
| 42 | 容器可以装多少水 | [O](#leetcode42) | Medium | 数组 \| 动态规划 \|两点法|
| 44 | 字符串匹配2 | [O](#leetcode44) |    Hard    | 字符串 \| 递归 \|动态规划 |
| 48 | 旋转图形 | [O](#leetcode48) | Medium | 数组 \| 递归 |
| 49 | 字符串分类 | [O](#leetcode49) | Medium | 数组 \| 哈希表，索引|
| 50 | 求幂Pow(x, n) | [O](#leetcode50) | Medium | 数学 \| 位运算|
| 53 | 最大子序和 | [O](#leetcode53) | Easy | 数组 \| 动态规划 |
| 54 | 旋转打印矩阵 | [O](#leetcode54) | Medium | 数组 \| 递归 |
| 55 | 跳跃游戏 | [O](#leetcode55) | Medium | 数组 \| 其它 |
| 56 | 区间合并 | [O](#leetcode56) | Medium | 数组 \| 其它 |
| 62 | 机器人走格子路径 | [O](#leetcode62) | Medium | 数组 \| 动态规划 |
| 69 | 求平方根 | [O](#leetcode69) | Easy | 数学 \| 边界 |
| 73 | 设置矩阵0行和列 | [O](#leetcode73) | Medium | 数组 \| 哈希表 |
| 75 | 颜色排序 | [O](#leetcode75) | Medium | 数组 \| 两点法 |
| 76 | 最小匹配窗口 | [O](#leetcode76) | *Hard | 数组 \| 哈希表 \|其它 |
| 78 | 求所有可能的子集 | [O](#leetcode78) | Medium | 数组 \| 递归 |
| 79 | 字符串匹配（二维数组中） | [O](#leetcode79) | Medium | 数组 \| 递归 \|回溯法 |
| 84 | 求最大面积子矩阵 | [O](#leetcode84) | *Hard | 数组 \| 栈 |
| 91 | 解码方法总数 | [O](#leetcode91) | Medium | 字符串 \| 动态规划 |
| 94 | 二叉树中序遍历 | [O](#leetcode94) | Medium | 树 \| 迭代 |
| 98 | 验证是否是二叉搜索树 | [O](#leetcode98) | Medium | 树 \| 迭代 |
| 101 | 验证是否是对称树 | [O](#leetcode101) | Easy| 树 \| 迭代 |
| 102 | 层次遍历打印 | [O](#leetcode102) | Medium| 树 \| 迭代 |
| 103 | Zigzag打印 | [O](#leetcode103) | Medium| 树 \| 迭代 |
| 104 | 求树的高度 | [O](#leetcode104) | Easy| 树 |
| 105 | 根据前序和中序遍历序列构造树 | [O](#leetcode105) | Medium| 树 |
| 108 | 根据递增序列构造查找树 | [O](#leetcode108) | Easy| 树 |
| 116 | 层次链表连接 | [O](#leetcode116) | Medium | 树 \| 层次遍历|
| 122 | 股票交易 | [O](#leetcode122) | Easy | 数组 \| 其它|
| 124 | 最大路径和 | [O](#leetcode124) | Hard | 树 \| 递归|
| 125 | 有效回文 | [O](#leetcode125) | Easy | 字符串 \| 其它|
| 127 | 单词接龙 | [O](#leetcode127) | *Medium | 图 \|BFS|
| 128 | 最长连续序列长度 | [O](#leetcode128) | *Hard | 数组 \| 哈希表 |
| 130 | 被包围的区域 | [O](#leetcode130) | Medium | 图 \|DFS |
| 131 | 回文分割 | [O](#leetcode131) | Medium | 字符串 \|DFS \|递归|
| 134 | 汽油站 | [O](#leetcode134) | *Medium | 数组 \| 贪心算法 \|其它|
| 138 | 带有随机指针的链表复制 | [O](#leetcode138) | *Medium | 链表|
| 139 | 单词分割I(II) | [O](#leetcode139) | *Medium | 字符串\| 动态规划|
| 146 | LRU Cache | [O](#leetcode146) | *Hard | 链表 \| 哈希表|
| 148 | **链表排序** | [O](#leetcode148) | **Medium** | 链表|
| 149 | 求在一条线上点的最大个数 | [O](#leetcode149) | Hard | 数组 \|其他 |
| 150 | 计算逆波兰表达式 | [O](#leetcode150) | Hard | 数组 \| 数据结构 \|栈 |
| 152 | 最大乘积子串 | [O](#leetcode152) | Medium | 数组  |
| 162 | 找出"山顶"元素 | [O](#leetcode162) | Medium | 二分查找  |
| 166 | 计算循环小数的分数值 | [O](#leetcode166) | Medium | 其它  |
| 169 | 求数组中的主元素 | [O](#leetcode169) | *Medium | 数组 \| 其它|
| 171 | Excel列号转换 | [O](#leetcode171) | Easy | 字符串 \| 其它|
| 172 | n的阶乘尾部0的个数 | [O](#leetcode172) | Easy |  数学|
| 179 | 将所有数字拼成一个最大数 | [O](#leetcode179) | Medium | 数学 \| 数组|
| 189 | 循环移动数组 | [O](#leetcode189) | Easy | 数组 \| 其它|
| 190 | 翻转bits | [O](#leetcode190) | Easy | 位运算 |
| 198 | 入室抢劫 | [O](#leetcode198) | Easy | 动态规划 |
| 200 | 岛屿的数量 | [O](#leetcode200) | Medium | 递归 \| DFS |
| 202 | 快乐数 | [O](#leetcode202) | Easy | 数学 |
| 207 | 课程安排 | [O](#leetcode207) | Medium | 递归 \| DFS \| 拓扑排序|
| 210 | 课程安排II | [O](#leetcode210) | Medium | 递归 \| DFS \| 拓扑排序|
| 215 | 找到第k大的元素 | [O](#leetcode215) | Medium | 数组 \| 排序 \|搜索|
| 217 | 是否存在重复元素 | [O](#leetcode217) | Easy | 数组 \| 哈希|
| 227 | 基础计算器II | [O](#leetcode227) | Medium |  字符串 \| 数学 \| 后缀表达式|
| 230 | 二叉树中给出第k大的元素 | [O](#leetcode230) | Medium |  树 \| 迭代 \| 后缀表达式|
| 234 | 回文链表 | [O](#leetcode234) | Medium | 链表 |
| 236 | 求两个节点的第一个公共祖先 | [O](#leetcode236) | Medium | 树 \| 迭代 |
| 237 | 删除链表给定节点 | [O](#leetcode237) | Easy | 链表 |
| 238 | 剩余数组的乘积 | [O](#leetcode238) | Medium | 数组 \| 动态规划 |
| 239 | 滑动窗口最大值 | [O](#leetcode239) | Hard | 数组 \| 双端队列 \| 数据结构 |
| 240 | 二位数组搜索指定数值 | [O](#leetcode240) | Medium | 数组 \| 数据搜索 |
| 268 | 缺失数字 | [O](#leetcode268) | Easy | 数组 \| 位运算 |
| 279 | 完全平方和 | [O](#leetcode279) | Medium | 动态规划 |
| 283 | 移动0元素 | [O](#leetcode283) | Easy | 其它 |
| 287 | 找到重复数字 | [O](#leetcode287) | Medium | 数组 \| 数据搜索 |
| 289 | 生命游戏 | [O](#leetcode289) | Medium | 数组 \| 其它 |
| 297 | 二叉树的序列化和反序列化 | [O](#leetcode297) | Hard | 树 |
| 300 | 最长升序序列 | [O](#leetcode300) | *Medium | 数组 \| 动态规划 |
| 315 | 返回右边小于当前数的计数数组 | [O](#leetcode315) | *Hard | 数组 \| 数据搜索 \| 二叉搜索树 |
| 324 | 摆动排序 | [O](#leetcode324) | Medium | 数组 \| 排序 \| 其它 |
| 326 | 判断是否为3的幂 | [O](#leetcode326) | Medium | 数学 |
| 328 | 奇偶链表 | [O](#leetcode328) | Medium | 链表 |
| 329 | 二维数组最长递增路径 | [O](#leetcode329) | Medium | 数组 \| 递归 \|DFS |
| 334 | 递增的三元子序列 | [O](#leetcode334) | Medium | 动态规划 |
| 347 | 前k个高频元素 | [O](#leetcode347) | Medium | 数据结构 \| 红黑树 |

## 数据搜索及查找

(哈希表,二分法)

### LeetCode4

#### 如何找到两个排序数组的中位数？(LeetCode4:Median of Two Sorted Arrays)

* 描述：给定两个排序的数组a，b长度分别为m，n找出这两个数组的中位数，时间复杂度为O(log(m+n))

假定a,b长度分别大于k，现在选择第k个数（排序后第k个数），先将a的第k/2个元素（a[k/2-1]）和b的第k/2个数进行比较，存在以下三种情况：

1. a[k/2-1] == b[k/2-1],第k个数找到了，就是a[k/2-1]或b[k/2-1]
2. a[k/2-1] > b[k/2-1],第k大的数肯定不可能在b[0..k/2-1]之间，因为小于b[k/2-1]的数包括b[0..k/2-1]（k/2个）以及a[0..k/2-1]（小于k/2个）中的一部分
3. 同上，a[k/2-1] < b[k/2-1],第k大的数肯定不可能在a[0..k/2-1]之间

要是m,n其中有一个长度小于k/2,则取长度和k/2的较小值来进行切割。

### LeetCode33

#### 在翻转数组中查找指定数据（LeetCode33: Search in Rotated Sorted Array）

翻转数组在剑指offer中有相关描述，这题也是剑指offer面试题11的很好的延伸，思路利用二分法来进行数据搜索，需要注意的是，如何根据nums[mid]和查找目标target的大小关系进行范围的缩小，分为两种情况：

{% highlight c++ %}

class Solution {
public:
    int search(vector<int>& nums, int target) {
        if(nums.empty()){
            return -1;
        }
        int low = 0,high = nums.size()-1,mid = 0;
        while(low < high){
            mid = (low+high)/2;
            //情况1:中切节点后面的部分不为递增数列
            if(nums[mid]>nums[high]){
                if(nums[mid] > target){
                    if(target > nums[high]){
                        high = mid -1;
                    }else if((target < nums[high])){
                        low = mid + 1;
                    }else {
                        return high;
                    }     
                }else if(nums[mid] < target){
                    low = mid + 1;
                }else{
                    return mid;
                }
            }else if(nums[mid]<=nums[high] ){
            // 情况2:中切节点后面的部分为递增序列
                if(nums[mid] > target){
                    high = mid -1;
                }else if(nums[mid] < target){
                    if(target > nums[high]){
                        high = mid - 1;
                    }else if(target < nums[high]){
                        low = mid +1;
                    }else{
                        return high;
                    }

                }else{
                    return mid;
                }
            }
        }
        //确定最后一个元素是否等于target
        if(nums[low] == target)
            return low;
        
        return -1;
        
    }
};

{% endhighlight %}

### LeetCode34

#### 搜索一个数字在一个递增数组（允许数字重复）中出现的范围(LeetCode34:Search for a Range)

返回出现的下标范围［start ，end］，如果不存在返回［-1,-1］

思路：二分法

{% highlight c++ %}
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int low = 0,high = nums.size()-1;
        int mid;
        int start = -1, end = -1;
        vector<int> result;
        if(nums.empty()){
            result.push_back(start);
            result.push_back(end);
            return result;
        }
        //开始二分查找，只要找到就返回
        while(low<high){
            mid = (low+high)/2;
            if(nums[mid] > target){
                high = mid -1;
            }else if(nums[mid] < target){
                low = mid + 1;
            }else{
                start = end = mid;
                break;
            }
        }
        //查看最后的位置是否即为目标数
        if(nums[low] == target){
            start = end = low;
        }
        //确定前后范围
        if(start >= 0){
            while(start>0){
                if(nums[start-1] == target)
                    start--;
                else
                    break;
            }
            
            while(end < nums.size()-1){
                if(nums[end+1] == target)
                    end++;
                else 
                    break;
            }
        }

        result.push_back(start);
        result.push_back(end);
        return result;
    }
};

{% endhighlight %}


### LeetCode36

#### 判断数独二维数组是否合法(LeetCode36: Valid Sudoku)

* 为什么要把这一题放到数据搜索及查找这一分类？因为判断一个数独数组是否合法可以分解为在纵向列，横向行，及每个子box中寻找重复的数字（1-9），只要有重复的数字就不合法，没有就合法。
* 而寻找重复的数字在剑指offer中有对应的题目：**面试题3，哈希表的思路**

我先介绍自己的思路：利用**三个map**保存每一行，每一列，每个子box是否有效，然后逐个字符来进行判断。

{% highlight c++ %}

class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        map<int,bool> row_map,column_map,box_map;//三个记录每行，每列，每个子 box是否合法的map
        set<char> test_set;
        
        //初始化
        for(int i = 0;i<9;i++){
            row_map.insert(make_pair(i,false));
            column_map.insert(make_pair(i,false));
            box_map.insert(make_pair(i,false));
        }
        //循环遍历二维数组中的每个元素
        for(int i = 0;i<9;i++){
            for (int j = 0;j<9;j++){
                
                //对于每一个元素，先测试所在行是否合法
                if (board[i][j]!='.'){
                    if(!column_map[i]){
                        //还没被测试过，开始测试，如果已经测试为真，则直接跳过
                        for(int k = j;k<9;k++){
                            if(board[i][k]!='.'){
                                if(test_set.count(board[i][k])){
                                    return false;
                                }else{
                                    test_set.insert(board[i][k]);
                                }
                            }
                        }
                        column_map[i] = true;
                    }
                    
                    test_set.clear();//清楚测试集，用于下一个测试

                    //开始测试所在列是否合法，若之前已经被测试过，则直接跳过
                    if(!row_map[j]){
                        //还没测试过，开始检查
                        for(int k = i;k<9;k++){
                            if(board[k][j]!='.'){
                                if(test_set.count(board[k][j])){
                                    return false;
                                }else{
                                    test_set.insert(board[k][j]);
                                }
                            }
                        }
                        row_map[j] = true;
                    }
                    
                    test_set.clear();
                    int index = (i/3)*3 + j/3;
                    //开始测试所在子box是否合法
                    if(!box_map[index]){
                        //开始检查
                        int start_col = (index/3)*3;
                        int start_row = (index%3)*3;
                        for(int col = start_col;col<start_col+3;col++){
                            for(int row = start_row;row<start_row+3;row++){
                                if(board[col][row]!='.'){
                                    if(test_set.count(board[col][row])){
                                        return false;
                                    }else{
                                        test_set.insert(board[col][row]);
                                    }
                                }
                            }
                        }
                        box_map[index] = true;
                    }
                    test_set.clear();
                }
                
            }
        }
        //当所有元素遍历检查结束后没出现不合法情况，则合法
        return true;
        
    }
};

{% endhighlight %}

**哈希表**的思路：分别创建用于测试行，列，子box的三个二维哈希表。

{% highlight c++ %}

class Solution
{
public:
    bool isValidSudoku(vector<vector<char> > &board)
    {
        int used1[9][9] = {0}, used2[9][9] = {0}, used3[9][9] = {0};//三个用于测试的哈希表，初始化为0
        
        for(int i = 0; i < board.size(); ++ i)
            for(int j = 0; j < board[i].size(); ++ j)
                if(board[i][j] != '.')
                {
                    int num = board[i][j] - '0' - 1, k = i / 3 * 3 + j / 3;
                    if(used1[i][num] || used2[j][num] || used3[k][num])
                    //所在位置出现重复，说明所在行，所在列或所在子box有重复的元素，不合法
                        return false;
                    used1[i][num] = used2[j][num] = used3[k][num] = 1;//之前没出现过则将该数值存放到行，列，子box三个哈希表中和数值相等的下标的位置上去。
                }
        
        return true;
    }
};


{% endhighlight %}

### LeetCode41

#### 找到第一个未出现的正数（LeetCode41: First Missing Positive）

* 描述：给出一个未排序的整型数组（元素可以重复），找出所有正数1,2,3...开始第一个没出现在该数组中的元素

如：
* \[ 1,2,0 \]:输出3
* \[ -1,3,4,1 \]:输出2

思路： 哈希表，将自身当作一个hash表，遍历这个数组，将每一个数放置到该数对应的下标上去
如果：

    - 出现该数对应的下标超出该数组的范围或者该数为非正数，则和尾部**第一个没有超出**数组大小的数进行互换，互换后尾部的数据则**不用考虑**，且**需要检测**的数组的大小也对应缩小
    - 该数对应的下标的位置上已经有正确的数(**重复**)，同样和数组尾部第一个没有超出数组大小的数进行互换，互换后尾部的数据则不用考虑，且需要检测的数组的大小也对应缩小

所有的数正确安排结束后，则开始从头开始遍历，第一个和下标不能一一对应的数就是第一个没有出现的正数，返回

{% highlight c++ %}

class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        if(nums.empty()){
            return 1;
        }
        int size = nums.size();
        int tmp;
        int end = size;
        for(int i = 0;i<end;i++){
            if(nums[i] != i+1){
                if(nums[i] <= 0||nums[i] > end|| nums[nums[i]-1] == nums[i]){//需要放置到尾部不予考虑
                    while(end-1 > i && nums[end-1] >= end){
                        end--;//在尾部找到第一个合法的数
                    }
                    if(end-1>i){
                        tmp = nums[end-1];
                        nums[end-1] = nums[i];
                        nums[i] = tmp;
                        i--;
                        end--;
                    }
                }else {
                //放置到正确的下标位置
                    tmp = nums[nums[i]-1];
                    nums[nums[i]-1] = nums[i];
                    nums[i] = tmp;
                    i--;
                }
            }
        }
        
        int k = 0;
        while(k<size && nums[k] == k+1){
            k++;//遍历得到第一个没有出现的正数
        }
        return k+1;
    }
};

{% endhighlight %}

### LeetCode73

#### 设置矩阵0项的行和列（LeetCode73:Set Matrix Zeroes）

给出一个二维矩阵，对于该矩阵中的每一个为0的元素，将其所在的行和列全部设为0。

```
Input: 
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
Output: 
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]

Input: 
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
Output: 
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
```

思路：哈希表。一个矩阵一共有m行，n列，每一行和每一列我们都需要了解其是否应该被设置为0的信息。将这个信息和它们所在的行列下标联系起来:

* 所以我们可以用**第一行**的元素 matrix[0][j]来记录所有列是否该设为0，若需要，则将第一行对应列的元素也设为0。
* 对于行是否该设为0 的信息则保存在**第一列**中
* 但由于第一行和第一列的信息**发生重合**，所以我们将第一行的信息，保存在额外的变量**col0**中

代码实现：

```c++
void setZeroes(vector<vector<int> > &matrix) {
    int col0 = 1, rows = matrix.size(), cols = matrix[0].size();

    for (int i = 0; i < rows; i++) {//将每一行和每一列是否该设置为0的信息保存在对应的位置
        if (matrix[i][0] == 0) col0 = 0;
        for (int j = 1; j < cols; j++)
            if (matrix[i][j] == 0)
                matrix[i][0] = matrix[0][j] = 0;
    }

    for (int i = rows - 1; i >= 0; i--) {//根据行和列保存的信息设置每一个元素
        for (int j = cols - 1; j >= 1; j--)
            if (matrix[i][0] == 0 || matrix[0][j] == 0)
                matrix[i][j] = 0;
        if (col0 == 0) matrix[i][0] = 0;
    }
}
```

### LeetCode128 

#### 最长连续序列（LeetCode128:Longest Consecutive Sequence）

给一个整型数组，找出该数组中的整型数最长的连续序列的长度。

```
Input: [100, 4, 200, 1, 3, 2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
```

要求：O(N)的复杂度

思路：使用哈希表，结合C++中的关联容器unordered_set来使用哈希表结构

```c++

class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        if(nums.empty())
            return 0;
        unordered_multiset<int> num_set(nums.begin(),nums.end());//将数组中的元素添加到以hashtable为基础的unordered_set数据结构中
        
        int curnum,len=1,maxlen=1;
        for(auto num : num_set){
            if(num_set.find(num-1) == num_set.end()){//数组中没有当前数字的前一个数字存在，如果有，前面已经被计算过，不用重复计算
                curnum = num;
                len = 1;
                while(num_set.find(curnum+1) != num_set.end()){//获取以当前整形数为起点的最长连续序列的长度
                    curnum++;
                    len++;
                }
                maxlen = max(maxlen,len);
            }
        }
        
        return maxlen;
    }
};
```
### LeetCode146

#### LRU缓存（LeetCode146:LRU Cache）

题目：实现一个LRU缓存类，缓存替换策略使用LRU最近最少使用策略，实现获取数据的接口get(key),实现添加数据的接口put(key,value);

这两种操作的复杂度限制在O(1);

```
LRUCache cache = new LRUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.put(4, 4);    // evicts key 1
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4
```

思路：

1. 获取数据（数据查找）的复杂度为O（1）要求必须使用哈希表作为索引实现
2. 插入数据的复杂度为O（1）要求使用链表来实现复杂度
3. 所以我们结合使用链表和哈希表的结构，数据缓存使用链表结构，然后所有链表中的节点和哈希表中的元素相关联，从而达到O（1）快速索引的目的。

![leetcode146](/img/leetcode146.png)

代码实现：

```c++
class LRUCache {
public:
    LRUCache(int capacity) {
        this->capacity_ = capacity;
    }
    
    int get(int key) {
        if(key_map.find(key)!=key_map.end()){//key搜索由哈希表结构unordered_map完成
            cache_.splice(cache_.begin(),cache_,key_map[key]);//链表操作，将某连续范围内的元素从一个list移动到另一个list的某个定点
            return key_map[key]->second;
        }
        
           return -1;
    }
    
    void put(int key, int value) {
        if(key_map.find(key)!=key_map.end()){
            key_map[key]->second = value;
            cache_.splice(cache_.begin(),cache_,key_map[key]);
            return;
        }
        
        if(cache_.size() == capacity_){//当前缓冲区满时，删除链表尾端
            int key = cache_.back().first;
            key_map.erase(key);
            cache_.pop_back();
        }
        
        cache_.emplace_front(key,value);
        auto iter = cache_.begin();
        key_map[key] = iter;
    }
private:
    int capacity_;
    list<pair<int,int>> cache_;//缓存存放数据
    unordered_map <int,list<pair<int,int>>::iterator> key_map;//哈希表构建缓存链表的每个节点的快速索引
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```

### LeetCode215
#### 查找第n大的元素（LeetCode215:Kth Largest Element in an Array）

给出一个数组，查找出其中第n大的元素

```
Input: [3,2,1,5,6,4] and k = 2
Output: 5

Input: [3,2,3,1,2,4,5,5,6] and k = 4
Output: 4
```
思路:

1. 快速排序
2. 堆排序

堆排序的实现：

```c++
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        make_heap(nums.begin(), nums.end());//构建堆
        auto last = nums.end();
        auto start = nums.begin();
        for (int i = 0; i<k - 1; i++)
            pop_heap(start, last--);//因为堆排序每次会将pop的元素放置到数组末端，所以last--不断减少其规模
        return nums.front();
    }
};
```


快速排序的实现：

```c++
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        if(nums.size()==0 || k > nums.size())
            return -1;
        int start = 0;
        int end = nums.size()-1;
        while(start<=end)
        {
            int index = Partition(nums,start,end);//进行快排
            if(index == k-1) return nums[index];//直到找到第k大的元素
            else if(index > k-1) end = index - 1;
            else start = index + 1;//不断调整进行快排的范围
        }
        return -1;
    }
private:
    int Partition(vector<int>& nums, int start, int end)
    {
        int pivot = nums[end];//将最后一个元素作为枢纽元
        int big = start-1;
        for(int i=start; i<end; ++i)
        {
            if(nums[i]>pivot)//将大于该枢纽的元素放到右边
            {
                ++big;
                swap(nums[big],nums[i]);
            }
        }
        ++big;
        swap(nums[end],nums[big]);//将枢纽元放到合适的位置
        return big;
    }
};
```
### LeetCode217

### 查找是否存在重复元素（LeetCode217：Cantains Duplicate）

给出一个数组，查找其中是否存在重复元素

```
Input: [1,2,3,1]
Output: true

Input: [1,2,3,4]
Output: false
```

思路：

1. 哈希表
2. 利用map不可插入重复元素的性质

```c++
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        set<int> num_set;
        pair<set<int>::iterator,bool> res;
        for(auto num:nums){
            res = num_set.insert(num);//插入操作返回一个pair，第二元素包含是否插入成功
            if(!res.second)
                return true;
        }
        return false;
    }
};
```

### LeetCode240

#### 二位数组搜索指定数值（LeetCode240：Search a 2D Matrix II）

给一个二维数组，每一行保持递增关系，每一列也保持递增关系，在这样的数组中搜索我们指定的数值。

```
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

Given target = 5, return true.

Given target = 20, return false.
```

思路：见剑指offer：面试题四：二维数组中的查找（对顺序容器的访问）

代码实现：

```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if(matrix.empty())
            return false;
        int i =0,j=matrix[0].size()-1;
        while(i<matrix.size()&&j>=0){
            if(matrix[i][j]>target)
                j--;
            else if(matrix[i][j]<target)
                i++;
            else
                return true;
        }
        return false;
    }
};
```

### LeetCode287

#### 找到重复数字（LeetCode287:Find the Duplicate Number）
给出一个数组，该数组包含n+1个元素，所有数据的范围在1~n之间，其中只有一个数字重复出现，且重复的次数并不清楚，找到该重复的数字。

```
Input: [1,3,4,2,2]
Output: 2

Input: [3,1,3,4,2]
Output: 3
```

要求：

1. 不能修改数组
2. 只能使用O(1)的内存空间
3. 时间复杂度小于O(n*n)

若能够修改数组，我们可以使用哈希表的思路来直接求解

代码实现：

```c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int result = nums[0];
        for (int i = 0;i<nums.size();i++){
            if(i!=nums[i]-1){
                if( nums[nums[i]-1]!=nums[i]){
                    swap(nums[i],nums[nums[i]-1]);
                    i--;
                }
                else return nums[i];
            }
                
        }
        return 0;
    }
};
```

不能修改数组，则只能使用二分查找，将1~n（如9）分成两部分

1. 1~9分为1~5和6~9两部分
2. 遍历数组，计数有多少个在1~5之间的数，若计数的个数大于5（5-1+1），则说明1~5之间有重复的数字，否则6~9之间有重复的数字
3. 循环1,2步骤，继续缩小范围，直到找到重复的数字

代码实现：

```c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int low = 1,high = nums.size()-1,mid;
        int count = 0;
        while(low<high){
            count = 0;
            mid = (low+high)/2;
            for(int i = 0;i<nums.size();i++){
                if(nums[i]<=mid&&nums[i]>=low)
                    count++;
            }
            if(count>mid-low+1){
                high = mid;
            }else{
                low = mid+1;
            }
        }
        return low;
    }
};
```

### LeetCode315

#### 返回右端小于当前元素的计数数组（LeetCode315:Count of Smaller Numbers After Self）

给出一个数组，返回一个数组，返回的数组中的元素代表，原数组中当前下标的元素x的右端有多少个小于x的元素

```
Input: [5,2,6,1]
Output: [2,1,1,0] 
Explanation:
To the right of 5 there are 2 smaller elements (2 and 1).
To the right of 2 there is only 1 smaller element (1).
To the right of 6 there is 1 smaller element (1).
To the right of 1 there is 0 smaller element.
```

思路1：暴力求解 O（N^2）

```c++
class Solution {
public:
    vector<int> countSmaller(vector<int>& nums) {
        int count = 0;
        vector<int> result(nums.size());
        for(int i=nums.size()-1;i>=0;i--){
            count = 0;
            for(int j=nums.size()-1;j>i;j--){
                if(nums[j]<nums[i])
                    count++;
            }
            result[i] = count;
        }
        return result;
    }
};
```

思路2：

[参考思路](https://github.com/guanjunjian/LeetCode/blob/master/Solution/315.%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0.md)

### LeetCode162

#### 找出山顶元素（LeetCode162:Find Peak Element）

题目：给出一个数组，找出"山顶"元素,山顶元素就是该元素比它两边的元素都大的元素

假设nums[-1] = nums[n] = -∞

可能有多个山顶元素，返回其中的一个即可

```
Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.

Input: nums = [1,2,1,3,5,6,4]
Output: 1 or 5 
Explanation: Your function can return either index number 1 where the peak element is 2, 
             or index number 5 where the peak element is 6.
```

思路1:遍历所有节点，找到第一个出现"下降"位置的元素。复杂度O(N)

思路2:二分法。

* 找到中间元素mid 
* 若nums[mid] > nums[mid+1],则在前半部分肯定有山顶元素的存在，因为nums[0] = -∞
* 若nums[mid] < nums[mid+1],则在后半部分肯定有山顶元素的存在，因为nums[n] = -∞

代码：

```c++
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int low=0,high=nums.size()-1;
        int mid;
        if(high == 0)
            return 0;
        while(low<high){
            mid = (low+high)/2;
            if(nums[mid] > nums[mid+1]) 
                high = mid;
            else if(nums[mid] < nums[mid+1])
                low = mid+1;
        }
        
        return low;
            
    }
};
```

二叉树中的每个节点记录三个信息：当前节点值，当前节点值得重复个数，当前节点的左子树节点个数

[leetcode315](/img/leetcode315.png)

1. 使用二叉搜索树，提高效率
2. 构建二叉树，从数组的右端开始
3. 当遍历到x元素时，先在二叉树中找到元素x合适的插入节点，在**递归**遍历过程的路径中，当当前节点小于x时：
    - 若当前节点没有右子树，则插入到当前节点的右孩子节点，并返回当前节点的左子树（小于该节点元素的个数）的节点个数和当前节点的重复个数。
    - 若当前节点有右子树，返回当前节点的重复计数+左子树节点个数+右子树根节点递归遍历返回的数量
4. 在**递归**遍历过程的路径中，当当前节点小于x时：
    - 按照步骤3递归左子树根节点，直接返回递归的结果值即可

代码实现：

```c++
struct BSTNode{
    BSTNode(int v):val(v),count(1),left_count(0),left(nullptr),right(nullptr){}
    ~BSTNode(){
        if(left) delete left;
        if(right) delete right;
    }
    //返回小于等于该节点的值
    int less_or_equal()
    {
        return count+left_count;
    }
    int val;
    int count;
    int left_count;
    BSTNode* left;
    BSTNode* right;
};
class Solution {
public:
    vector<int> countSmaller(vector<int>& nums) {
        if(nums.empty()) return {};
        vector<int> res;
        //初始化nums最右数的值
        res.push_back(0);
        BSTNode* root = new BSTNode(nums[nums.size()-1]);
        for(int i=nums.size()-2; i>=0; --i)
            res.push_back(insert(root,nums[i]));//从最右边的元素开始遍历
        reverse(res.begin(),res.end());
        return res;
    }
    int insert(BSTNode* root, int num)
    {
        if(num == root->val)
        {
            root->count++;
            return root->left_count;
        }
        else if(num < root->val)//小于当前元素时。往左边插入时
        {
            ++(root->left_count);
            if(root->left==nullptr)
            {
                root->left = new BSTNode(num);   
                return 0;
            }
            return insert(root->left,num);//直接返回递归结果
        }
        else//大于当前元素，往右边插入时
        {
            if(root->right==nullptr)//右子树为空时
            {
                root->right = new BSTNode(num);
                return root->less_or_equal();
            }
            return root->less_or_equal() + insert(root->right,num);//右子树不为空时
        }
    }
};
```
>>>>>>> 91a7459cc9573404b078ef43a13cdcd32b3f84ff

### 数据搜索和查找ending


## 动态规划

### LeetCode5

#### 找到最长回文子字符串(LeetCode5:Longest Palindromic Substring)

* 描述：给出一个字符串，找出它的最长且为回文结构的子字符串：如：“babad”的最长子字符串且为回文的子串为"bab",或“aba”,而"cbbd"的最长子串为“bb”

思路1：暴力求解：找出所有可能的子字符串头i和尾j，然后判断是否为回文，复杂度O（N^3）

思路2: 动态规划，用一个二维数组arr记录子字符串是否为回文，横坐标纪录字符串开头i(i < s.zise()),纵坐标纪录结尾j(i<=j< s.size());然后二维数组中纪录的是从i到j的子字符串**是否为一个回文结构**。回文结构由以下三种情况

    * 由**一个字符**组成的回文字符串
    * 由**两个相同的字符**组成回文字符串
    * i到j字符串为回文字符串，则i+1到j也为回文字符串，且s[i] = s[j];

所以根据上述关系arr[i][j]和arr[i+1][j-1]的关系来做状态转换方程构建该二维数组。构建过程的复杂度为O(N^2),然后根据该二维数组找出最长子字符串。空间复杂度也为O(N^2)

思路3(中心扩展，时间复杂度O(N^2),空间复杂度O(1)): 回文结构其实就是以一个点为**中心**，向两边扩展，我们只要找到这**2n-1个中心**（n为字符串的长度）然后两边扩展即可得到回文长度即可。为什么是2n-1个中心，因为中心分为两种：

    * 以一个字符为中心
    * 以两个相同的字符为中心

{% highlight c++ %}
public String longestPalindrome(String s) {
    int start = 0, end = 0;
    for (int i = 0; i < s.length(); i++) {
        int len1 = expandAroundCenter(s, i, i);
        int len2 = expandAroundCenter(s, i, i + 1);
        int len = Math.max(len1, len2);
        if (len > end - start) {
            start = i - (len - 1) / 2;
            end = i + len / 2;
        }
    }
    return s.substring(start, end + 1);
}

private int expandAroundCenter(String s, int left, int right) {
    int L = left, R = right;
    while (L >= 0 && R < s.length() && s.charAt(L) == s.charAt(R)) {
        L--;
        R++;
    }
    return R - L - 1;
}
{% endhighlight %}

思路4（Manacher's Algorithm,O(N)）:

首先将每两个字符串中插入"#",确保每个回文字符串都是奇数形式，以一个字符为中心的回文字符串
```
＃1＃2＃2＃1＃2＃2＃
```
为了防止越界，我们还需要在首尾再加上非#号字符

遍历字符串，当遍历到第i字符时，我们需要在遍历过程中纪录回文串可以延伸到**最右端的端点下标max_right**,和以该端点作为结尾的回文字符串的**中心点ct**。还要纪录以该点为中心点的回文串的长度len[i]

* 假设当我们遍历到ct时，匹配后确定了以它为中心的回文串达到的**右端点为前面所有中心的回文串的最右端点**：max_right。
* 遍历下一个节点j = ct＋1时，len[j] = max_right < j ? min(p[2*ct-j],max_right - j):1;
    - 这个表达式的含义就是当这个下标还在我们前面遍历得到回文串的**最右端点的范围之内**时，根据回文串的映射关系：2*ct-j为j以ct为中心的**映射点**，在ct为中心的回文串范围中，j和2*ct-j的回文串长度应该保持一致，但是出了这个范围，就需要进一步匹配来确定:
    ![LeetCode_1.png](/img/LeetCode_1.png)
    - 遍历过程中需要纪录:回文串**最右端点及中心点**，最长回文字符串的**中心点及长度**。遍历一次更新一次
    - 代码参考：https://www.cnblogs.com/grandyang/p/4475985.html

### LeetCode10

#### 字符串匹配“.*”(LeetCode10:Regular Expression Matching)

题目链接： https://leetcode.com/problems/regular-expression-matching/description/
描述：给定一个字符串匹配模式pattern，输入一个字符串判断是否与该pattern匹配。

1. '.'代表任意字符
2. 'a*'代表a可以出现0次，1次或任意次
3. '.*'带表任意长度（包括0）任意类型的字符串

思路1：递归

处理这三种匹配情况
1. 碰到字母或'.'时，只要相等就进行下个字符的匹配
2. 碰到*时分两种情况

    * 字符＋‘*’匹配0个字符，1个字符或多个重复字符
    * '.*'匹配0个字符，1个任意字符或多个任意长度的任意类型的字符

{% highlight c++ %}
bool match(string & str,string & pattern,int str_i,int pat_i){
        if(str_i == str.size() && pat_i == pattern.size()){
                return true;
        }
        if(str_i>str.size())
            return false;
        bool result = false;
        if(pattern[pat_i+1]!='*'){
        /*处理非*的情况*/
            if(str[str_i] == pattern[pat_i]||pattern[pat_i] == '.')
                return match(str, pattern, str_i+1, pat_i+1);
            return result;
        }else {
            if(pattern[pat_i] != '.'){
            /*处理字符＋‘*’的情况*/
                result = match(str, pattern, str_i, pat_i+2);//字符＋‘*’匹配0个字符串
                if(result)
                    return result;
                if(str[str_i] == pattern[pat_i])
                    result = match(str, pattern, str_i+1, pat_i+2)||match(str, pattern, str_i+1, pat_i);//字符＋‘*’匹配1个字符串或多个重复字符
                return result;
            }else{
            /*处理‘.*’的情况*/
                result = match(str, pattern, str_i, pat_i+2)||match(str, pattern, str_i+1, pat_i+2)||match(str, pattern, str_i+1, pat_i);;//‘.*’匹配0个字符，1个字符，任意长度的任意类型的字符
                return result;
            }
        }
    };
}
{% endhighlight %}

思路2: 动态规划

用一个二维数组memo[pat_i+1][str_j+1]来记录长度为str_j和长度为pat_i的模版是否匹配
1. 先进行初始化
2. 状态转换方程

    * 碰到pattern[pat_i]为字母或‘.’时
    * 碰到pattern[pat_i]为为‘*’时
        - pattern[pat_i－1]为普通字符时
        - pattern[pat_i-1]为‘.’时
3. 返回memo[pat_i+1][str_j+1]

{% highlight c++ %}

bool match_dp(string & str,string & pattern){
        int str_size = (int)str.size(),pat_size = (int)pattern.size();
        bool ** memo =new bool*[pat_size+1];//二维数组的创建
        for(int i =0;i<=pat_size;i++){
            memo[i] = new bool[str_size+1];
        }
        for(int i = 0;i<=pat_size;i++)
            for(int j = 0;j<=str_size;j++)
                memo[i][j] = false;
        //Initialize初始化
        memo[0][0] = true;
        if(str_size>0&&pat_size>0){
            if(str[0] == pattern[0]||pattern[0] == '.')
                memo[1][1] = true;
        }
        if(pat_size<2){
            return memo[pat_size][str_size];
        }
        //Dynamic Programming，开始进行遍历
        bool result = false;
        for(int i = 2;i<=pat_size;i++)
        {
            for(int j = 0;j<=str_size;j++){
                result = false;
                if(pattern[i-1] == '*'){
                    if(pattern[i-2]!='.'){
                        result =result||memo[i-2][j];//字母＋*匹配0个字符
                        if(str[j-1] == pattern[i-2])
                            result = result || memo[i-2][j-1]||memo[i][j-1];//字母＋*匹配1个字符或多个字符
                    }else{
                    /* 处理情况‘.*’  */
                        result = memo[i][j-1]||memo[i-2][j];//.*匹配一个或多个字符，.*匹配0个字符
                    }
                }else{
                /* 处理情况‘非*’*/
                    if(str[j-1] == pattern[i-1]||pattern[i-1] == '.'){
                        result = memo[i-1][j-1];
                    }
                }
                memo[i][j] = result;
            }
        }
        return memo[pat_size][str_size];
    }

{% endhighlight %}

### LeetCode44

#### 字符串匹配："?*"(LeetCode44:Wildcard Matching)

描述：给定一个字符串匹配模式pattern，输入一个字符串判断是否与该pattern匹配。

'?'可以代替任意一个字符，'*'可以代替任意长度任意类型的字符串

方法有两种：
* 回溯法
* 动态规划二维数组
    - 优化版本：只用一维数组记录数据

{% highlight c++ %}

class Solution {
    
    public:
    //回溯法，比较耗时，递归调用
    bool isMatch(string s, string p) {
        int s_end = s.size();
        int p_end = p.size();
        return ismatch(s,p,0,0,s_end,p_end);
    }
    
    bool ismatch(string &s,string &p,int i,int j, int s_end,int p_end){
        bool result = false;
        if(i == s_end){
            if(j == p_end)
                return true;
            else if(p[j] == '*')
                return ismatch(s,p,i,j+1,s_end,p_end);
            else
                return false;
        }
        
        if(i>s_end || j>p_end)
            return false;
        if(j < p_end){
            if(p[j] == '?')
                result = ismatch(s,p,i+1,j+1,s_end,p_end);//匹配一个，均前进一步
            else if(p[j] == '*')
                result = ismatch(s,p,i,j+1,s_end,p_end)||ismatch(s,p,i+1,j+1,s_end,p_end)||ismatch(s,p,i+1,j,s_end,p_end);//'*'分别匹配0个，1个和多个
            else if(s[i] == p[j])
                result = ismatch(s,p,i+1,j+1,s_end,p_end);//匹配一个，均前进一步
            else
                result = false;
        }
        
        return result;
        
        
        
    }
    //二维数组进行动态规划
        bool isMatch_dp2(string s, string p) {
            const int s_end = s.size(),p_end = p.size();
            int** record = new int*[p_end+1];//二维数组纪录结果数据
            
            //初始化基础数据
            for(int i=0;i<=p_end;i++){
                record[i] = new int[s_end+1];
            }
            
            for(int i=0;i<=p_end;i++){
                for(int j = 0;j<=s_end;j++){
                    record[i][j] = 0;
                }
            }
            
            record[0][0] = true;
            if(p_end>0){
                //初始化基础数据
                if(p[0] == '*'){
                    for(int i = 0;i<=s_end;i++)
                        record[1][i] = 1;
                }else if(p[0] == '?'||p[0] == s[0]){
                    record[1][1] = 1;
                }
                
                for(int i = 0;i<p_end;i++)
                    if(p[i] == '*')
                        record[i+1][0] = record[i][0];
                
                //开始动态规划
                for(int i=2;i<=p_end;i++){
                    for(int j = 0;j<=s_end;j++){
                        if(p[i-1] == '*'){
                            for(int k = 0;k<=j;k++){
                                if(record[i-1][k])
                                    record[i][j] = 1;
                            }
                        }
                        else if(p[i-1] == '?'){
                            record[i][j] = record[i-1][j-1];
                        }else if(p[i-1] == s[j-1]){
                            record[i][j] = record[i-1][j-1];
                        }
                    }
                }
            }
            
            if(record[p_end][s_end]){
                return true;
            }
            else
                return false;
        }
    //一维数组进行动态规划
    bool isMatch_dp1(string s, string p) {
        int s_end = s.size(),p_end = p.size();
        int *record = new int[s_end+1];//用一维数组纪录结果
        record[0] = 1;
        if(s_end >0){//初始化基础数据
            for(int i = 1;i<s_end+1;i++){
                record[i] = 0;
            }
        }
        
        if(p_end>0){
            for(int i = 1;i<=p_end;i++){
                for(int j = s_end;j>=0;j--){//倒序进行确认
                    if(p[i-1] == '*'){
                        for(int k = 0;k<=j;k++){
                            if(record[k] == 1){
                                record[j] = 1;
                                break;
                            }
                        }
                    }
                    else if(p[i-1] == '?'){
                        record[j] = record[j-1];
                    }else if(p[i-1] == s[j-1]){
                        record[j] = record[j-1];
                    }else{
                        record[j] = 0;
                    }
                }
            }
        }
        
        return record[s_end];
    }


};


{% endhighlight %} 

### LeetCode38

#### 计数后用字符串表达（LeetCode38:Count and Say）

有一个字符串的序列，下一项为上一项的计数表达，从"1"开始计数

```
1. "1"
2. "11"  //1个1
3. "21"  //2个1
4. "1211"   //1个2，1个1
5. "111221"   //1个1，1个2，2个1
...
```

按照这个规律，求的第n项的字符串是什么

思路：动态规划，只需要一个字符串记录第n-1项字符串，然后开始计数后写入第n项字符串。

{% highlight c++ %}
class Solution {
public:
    string countAndSay(int n) {
        if(n<=0)
            return NULL;
        string record = "1";//用于记录上一项的字符串
        string tmp;//用于迭代得到本轮字符串
        int count;
        char num;
        if(n==1){
            return record;
        }
        for(int k = 1;k < n;k++){
            for(int i=0;i < record.size();i++){
                num = record[i];
                count = 0;
                while(i < record.size()&&record[i] == num){
                    count++;
                    i++;
                }
                i--;
                tmp.push_back(count+'0');
                tmp.push_back(num);
            }
            record = tmp;
            tmp.clear();
        }
        return record;
    }
};

{% endhighlight %}


### LeetCode53

#### 最大子序列和（LeetCode53:Maximum Subarray）

给一个数组，求出该数组中和最大的子序列。

思路：循环遍历数组，记录每一个数结尾的最大子序列和，当该**和小于0时重新从0开始求和**。遍历结束后获取最大的子序列和。

{% highlight c++ %}
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if(nums.empty())
            return 0;
        int sum = 0,sum_max = nums[0];
        for(int i = 0;i<nums.size();i++){
            sum += nums[i];
            if(sum > sum_max)//寻找最大的子序列和
                sum_max = sum;
            if(sum < 0)//小于0时从0开始重新求和
                sum = 0;
        }
        
        return sum_max;
    }
};

{% endhighlight %}

### LeetCode62

#### 机器人走格子路径（LeetCode62：Unique Paths）

有一个mxn的棋盘，机器人要从起点(1,1)走到终点(m,n)， 且机器人只能向右前进和向下前进。问机器人一共有多少种方式，或有多少条不同的路径可以到达终点？

![robot_path](/img/robot_path.png)

```
Input: m = 3, n = 2
Output: 3
Explanation:
From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Right -> Down
2. Right -> Down -> Right
3. Down -> Right -> Right
```

思路1：回溯法，递归耗时

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        int result = 0;
        int *result_ptr = &result;
        uniquePath_x(1,1,m,n,result_ptr);
        return result;
    }
    
    void uniquePath_x(int x, int y, int m, int n,int * count){
        if(x == m&&y==n ){
            *count +=1;
            return;
        }
        if(x < m )
            uniquePath_x(x+1,y,m,n,count);
        if(y < n )
        return;
    }
};
```

思路2:动态规划，用一维数组即可

```c++

class Solution {
public:
    int uniquePaths(int m, int n) {
        if(m<=0||n<=0)
            return 0;
        if(m == 1|| n == 1)
            return 1;
        int *record = (int *)malloc(m*sizeof(int));
        
        for(int i = 0;i<m;i++){
            record[i] = 1;
        }
        
        for(int i =1;i<n;i++)
            for(int j = 1;j<m;j++){
                record[j] = record[j-1]+record[j];
            }
        
        return record[m-1];
    }
    

};
```

### LeetCode91

#### 求解码方法总数（LeetCode91:Decode Ways）
给出一串字符串，按如下规则进行解码，问有多少解码的方法？

```
'A' -> 1
'B' -> 2
...
'Z' -> 26

Input: "12"
Output: 2
Explanation: It could be decoded as "AB" (1 2) or "L" (12).

Input: "226"
Output: 3
Explanation: It could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).

Input: "0"
Output: "0"

Input: "100"
Output: "0"
```

思路：动态规划，用一个数组记录从0开始记录字符串前n个字符构成的字符串有多少种方法解码，然后根据依赖关系求得前n+1个字符有多少种方法解码？

注意：因为0没有对应的解码，所以当碰到0时需要特殊注意，因为0只能和前一个元素进行结合，若结合失败，则返回0。

```c++

class Solution {
public:
    int numDecodings(string s) {
        if(s.empty())
            return 0;
        if(s.size() == 1){
            if(s[0] == '0')
                return 0;
            else
                return 1;
        }
        
        if(s[0] == '0')
                return 0;
        vector<int> record(s.size()+1,0);
        record[0] = 1;
        record[1] = 1;
        int num;
        for(int i = 1;i < s.size();i++){
            if(s[i-1] == '0'){//当前面的元素为0时的处理步骤
                if(s[i] == '0')//连续为0，返回0
                    return 0;
                record[i+1] = record[i];
            }
            else if(s[i]!='0'){//当前元素不为0时的处理步骤
                num = (s[i-1]-'0')*10 + s[i] - '0';//和前面的元素结合起来时的值
                if(num>0 && num <= 26)
                    record[i+1] = record[i-1] + record[i];//可以结合
                else
                    record[i+1] = record[i];//不可以结合
            }else if(s[i] == '0'){//当前元素为0时的处理步骤
                num = (s[i-1]-'0')*10 + s[i] - '0';//只能和前面的数结合
                if(num>0 && num <= 26)
                    record[i+1] = record[i-1];//结合的数合法
                else
                    return 0;//不合法时，返回0
            }
        }
        
        return record[s.size()];
    }
};
```
### LeetCode198
#### 入室抢劫（LeetCode198: House Robber）

给一个数组，数组中每个数字代表一个房间所拥有的钱的数量，现在一个抢劫犯要到房间里面抢钱，但相邻的房间会有警报器，改抢劫犯为了不触发警报器，应该如何行动，抢到最大数量的钱。
>>>>>>> 91a7459cc9573404b078ef43a13cdcd32b3f84ff

```
Input: [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.

Input: [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
             Total amount you can rob = 2 + 9 + 1 = 12.
```

思路：动态规划

代码实现：

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        vector<int> record;
        if(nums.empty()){
            return 0;
        }
        if(nums.size() == 1){
            return nums[0];
        }
        
        if(nums.size() == 2){
            return nums[0]>nums[1]?nums[0]:nums[1];
        }
        
        record.push_back(nums[0]);
        record.push_back(nums[0]>nums[1]?nums[0]:nums[1]);
        
        for(int i = 2;i<nums.size();i++){
                record.push_back((record[i-2]+nums[i])>record[i-1]?(record[i-2]+nums[i]):record[i-1]);
        }
        
        return record.back();
    }
};
```


### LeetCode139

#### 单词分割I(LeetCode139:Word Break)

给一个长串的字符串，和一个字典数组，将该字符串分割成若干个单词，使得每个单词都可以在字典中找到。

```
Input: s = "leetcode", wordDict = ["leet", "code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".


Input: s = "applepenapple", wordDict = ["apple", "pen"]
Output: true
Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
             Note that you are allowed to reuse a dictionary word.


Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
Output: false

```

思路：动态规划，使用一个**map结构**纪录递归过程中，字符串的子串是否可以被成功分割。

递归过程：

1. 分割点从字符串的首部开始，将字符串分为**两部分**：左子串和右子串
2. 判断左子串能否被成功分割，再判断右子串是否存在于字典中。
3. 只要当左子串能够被成功分割，且右子串存在与字典中，才说明字符串可以被成功分割
4. 分割点不断**向字符串尾部移动**，其实就是在寻找最右边的第一个分割点。
5. 所以左子串是一个**由小到大**的变化过程，所以使用map来纪录小规模的求解情况。

代码实现：

```c++

class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> dict_set(wordDict.begin(),wordDict.end());
        return wordBreak_x(s,dict_set);
            
    }
    
    bool wordBreak_x(string s,unordered_set<string>& dict_set){
        if(mem_.count(s)){
            return mem_[s];//如果记录中已经求解，则直接返回
        }
        
        if(dict_set.count(s)){
            return mem_[s] = true;//如果字典中存在，也直接返回
        }
        for(int i =0;i<= s.size();i++){
            string left(s.begin(),s.begin()+i);
            string right(s.begin()+i,s.end());
            if(dict_set.find(right)!=dict_set.end()){
                if(wordBreak_x(left,dict_set)){
                    return mem_[left] = true;//左子串可以分割，右子串存在于字典中，成功分割
                }
                
            }
        }
        return mem_[s]=false;//分割失败
    }
    
    private:
        unordered_map<string,bool> mem_; 
};
```

#### 单词分割II(LeetCode140:Word BreakII)

题目同上，但是要将所有可能的分割情况输出

```
Input:
s = "catsanddog"
wordDict = ["cat", "cats", "and", "sand", "dog"]
Output:
[
  "cats and dog",
  "cat sand dog"
]

Input:
s = "pineapplepenapple"
wordDict = ["apple", "pen", "applepen", "pine", "pineapple"]
Output:
[
  "pine apple pen apple",
  "pineapple pen apple",
  "pine applepen apple"
]
Explanation: Note that you are allowed to reuse a dictionary word.
```

思路相同，不过涉及到对结果的处理，以及将分割成功的子串添加到结果集

代码：

```
class Solution {
public:
    vector<string> wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> dict_set(wordDict.begin(),wordDict.end());
        vector<string> result;
        wordBreak_x(s,dict_set,result);
        return result;
        
    }
    
    bool wordBreak_x(string s,unordered_set<string>& dict_set,vector<string> &result){
        if(s.empty())
            return true;
        if(mem_.count(s)){
            if(mem_[s])
                result = mem_str[s];//如果记录中已经求解，则直接返回
            return mem_[s];
        }
        
        for(int i =0;i<= s.size();i++){
            string left(s.begin(),s.begin()+i);
            string right(s.begin()+i,s.end());
            if(dict_set.find(right)!=dict_set.end()){
                vector<string> result_tmp;
                if(wordBreak_x(left,dict_set,result_tmp)){
                    mem_[left] = true;//左子串可以分割，右子串存在于字典中，成功分割
                    mem_str[left] = result_tmp;
                    if(result_tmp.empty())
                        result_tmp.push_back(right);
                    else
                        for(int i = 0;i<result_tmp.size();i++){
                            result_tmp[i] +=" "+right; //result_tmp记录左子串所有的分割情况
                        }
                    if(!result_tmp.empty()){
                        result.insert(result.end(),result_tmp.begin(),result_tmp.end());//添加到结果集中
                    }
                }
                
            }
        }
        if(!result.empty()){
            mem_str[s] = result;
            return mem_[s]=true;
        }
        return mem_[s]=false;//分割失败
    }
    private:
    unordered_map<string,bool> mem_;
    unordered_map<string,vector<string>> mem_str;//记录所有可能的分割字符串
};
```



### LeetCode238
#### 剩余数组乘积（LeetCode238：Product of Array Except Self）

给出一个数组nums，给出当除掉nums[i]元素时，剩余元素的乘积。输出对每一个元素i的剩余乘积

```
Input:  [1,2,3,4]
Output: [24,12,8,6]
```

思路：动态规划

1. 先求出以每个元素作为结尾的前面元素乘积record1
2. 再求出以每个元素作为开头的后面元素的乘积record2
3. 根据这两个记录信息求出所有除掉nums[i]的乘积

进阶：使用常量空间解决问题

1. 将record1只用一个变量即可，存放到result中只有前半部分的乘积
2. 再将record2也只需要一个变量记录，再遍历一次将后半部分的乘积和结果集中前半部分相乘即可

代码实现（只实现普通解法部分，进阶解法也很简单，这里不做实现）

```c++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int> record1,record2,result;//record1和record2其实只用一个变量即可，因为一个记录用过一次就不会再使用
        if(nums.size()<=1) return result;
        record1.push_back(nums[0]);
        record2.push_back(nums[nums.size()-1]);
        int cur = 0;
        for(int i = 1;i<nums.size();i++){
            cur = nums[i]*record1[i-1];//记录前半部分的乘积
            record1.push_back(cur);
            cur = nums[nums.size()-1-i]*record2[i-1];//记录后半部分乘积
            record2.push_back(cur);
        }
        result.push_back(record2[nums.size()-2]);
         for(int i = 1;i<nums.size()-1;i++){
             result.push_back(record1[i-1]*record2[nums.size()-i-2]);//根据前半部分和后半部分来计算结果
         }
        result.push_back(record1[nums.size()-2]);
        
        return result;
        
    }
};
```

### LeetCode279

#### 完全平方和（LeetCode279：Perfect Squares）

给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

```
输入: n = 12
输出: 3 
解释: 12 = 4 + 4 + 4.

输入: n = 13
输出: 2
解释: 13 = 4 + 9.
```

[思路参考](https://github.com/guanjunjian/LeetCode/blob/master/Solution/279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.md)

思路：

求一个数n最少由多少个完全平方数组成，假设q为sqrt(n)：

* 如果这些数里面包含1，那么求出n-1*1最少由多少个完美平方数组成，然后加1就是结果
* 否则，如果这些数里面包含2，那么求出n-2*2最少由多少个完美平方数组成，然后加1就是结果
* ...
* 否则，如果这些数里面包含q,那么求出n-q*q最少由多少个完美平方数组成，然后加1就是结果

因此，这是一个动态规划问题。F(n) = min{F(n),F(n-1)+1,F(n-4)+1,...,F(n-q*q)+1}。如果递归求解会存在重复子问题，因此使用一个数组state保存状态，“从小到大”求出F(1)到F(n)，结果就是state[n] ，将state都初始化为INT_MAX


代码实现：

```c++
class Solution {
public:
    int numSquares(int n) {
        vector<int> state(n + 1, INT_MAX);//记录数据
        state[0] = 0;
        for (int i = 1; i <= n; ++i)
        {
            int q = (int)sqrt(i);//求可能的平方和范围
            //如果i刚好为完全平方数
            if (q*q == i) state[i] = 1;
            else
            {
                for (int j = 1; j <= q; ++j)
                    state[i] = min(state[i], state[i - j * j] + 1);
            }
        }
        return state[n];
    }
};
```

### LeetCode300
#### 最长升序序列（LeetCode300:Longest Increasing Subsequence）

给出一个未排序数组，给出该数组中最长的升序序列长度

```
Input: [10,9,2,5,3,7,101,18]
Output: 4 
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. 
```

要求：

时间复杂度保持在O(N^2)

进阶：

将时间复杂度降低为O(NlogN)

我的思路：动态规划，时间复杂度O(N^2),空间复杂度O(N^2)

1. 构造邻接关系表，（前后两个元素维持升序关系时，保持邻边关系）
2. 记录所有可能的起点，再遍历所有的起点，结合邻接关系表递归求该起点的最长路径
3. 返回所有路径中的最长长度
4. 并且在递归过程中，记录下每个节点开始的最长长度，提升速度

代码实现：

```c++

class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int** edge = new int*[nums.size()];
        int *record = new int[nums.size()];//动态规划记录，每个节点的最长路径
        for (int i = 0; i < nums.size(); i++) {
            edge[i] = new int[nums.size()];
            record[i] = -1;
        }

        for (int i = 0; i < nums.size(); i++) {
            for (int j = 0; j < nums.size(); j++) {
                edge[i][j] = 0;
            }
        }
        if (nums.empty())
            return 0;
        set<int> numset;//记录入度为0的点
        for (int i = 0; i<nums.size(); i++) {
            numset.insert(i);
        }
        for (int i = 0; i<nums.size(); i++) {
            for (int j = i+1; j<nums.size(); j++) {
                if (nums[i] < nums[j]) {
                    if (numset.find(j) != numset.end()) {
                        numset.erase(numset.find(j));
                    }//找到所有入度为0的集合
                    edge[i][j] = 1;//记录邻边关系，构建邻边关系表
                }

            }
        }

        int maxlen = 0;
        for (int start : numset) {//遍历每一个可能的起点
            int len = getMaxLen(start, edge,nums.size()-1,record);//获取每一个起点最长的路径
            if (len>maxlen)
                maxlen = len;
        }

        return maxlen;
    }

    int getMaxLen(int start, int** edge,int size,int* record) {
        if (start == size)
            return 1;
        if(record[start]!=-1)
            return record[start];
        int len_max = 0;
        int len_tmp = 0;
        for (int j = start+1; j <= size; j++) {
            if (edge[start][j]) {
                len_tmp = getMaxLen(j, edge,size,record);
                if (len_tmp>len_max)
                    len_max = len_tmp;
            }
        }
        record[start] = len_max+1;//记录每个元素开始的最长路径
        return len_max + 1;
    }
};
```

思路2：思路1过于复杂，空间复杂度也比较高，这个版本是思路1的优化版本,时间复杂度(O(N^2)),空间复杂度（O（N））

[思路参考](https://leetcode.com/problems/longest-increasing-subsequence/solution/)

1. record记录以每个节点作为结尾的最长升序长度
2. 其中的前后依赖关系为：当处理第n个元素时，比较前n个元素中所有小于n的元素的（最长序列长度+1）中的最大值，为当前n的最长序列长度
3. 最后遍历该record数组，找到最长升序序列长度

代码实现：

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if(nums.empty()) return 0;
        //用于记录前0~i-1中，nums[i]大于的数的state的最大值
        int maxOK = INT_MIN;
        vector<int> state(nums.size(),0);
        state[0] = 1;
        for(int i=1; i<nums.size(); ++i)
        {
            for(int j=0; j<i; ++j)
            {
                if(nums[i] > nums[j]) maxOK = max(maxOK,state[j]);
            }
            if(maxOK!=INT_MIN) state[i] = maxOK+1;
            else state[i] = 1;
            maxOK = INT_MIN;
        }
        int maxALL = INT_MIN;
        for(int i =0; i<state.size(); ++i)
            maxALL = max(maxALL, state[i]);
        return maxALL;
    }
};
```




思路3（非常精妙的想法）：（当碰到一个破坏升序序列的元素时，将其替换掉该升序序列中第一个大于它的元素，这样可以维持之前的升序序列长度，同时还可以扩展之前的升序序列，只要最大元素不被替换）

使用一个数组S保存最长升序序列的状态，它始终保持升序，每个元素插入S中时，替换掉S中大于等于这个插入元素的第一个元素，如果插入的元素大于S的最后一个元素，那么扩展S

举个例子：

```
nums = [5,6,7,1,2,8,3,4,0,5,9]
```

当处理到7时，因为前3个元素升序，所以组成一个升序序列：

```
S = [5,6,7]
```

当处理1时，它终止了序列持续上升的趋势，可能会引导出一个新的更长的升序序列。因此替换掉大于等于它的第一个元素5：

```
S = [1,6,7]
```

接着处理2：

```
S = [1,2,7]
```

处理8时，需要扩展升序序列：

```
S = [1,2,7,8]
```

然后处理3：

```
S = [1,2,3,8]
```

处理4：

```
S = [1,2,3,4]
```

处理最后3个元素:

```
S = [0,2,3,4,5,9]
```

因为只需遍历1遍数组，并且每次更新S可以使用二分查找（时间复杂度为O(logn)），对数组中每一个数进行一次二分查找，所以总时间复杂度为O(n*logn)

因为只需遍历一遍数组，所以可以直接在nums的前部进行修改，作为S，从而不需要额外的空间

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if(nums.empty()) return 0;
        //记录S最后一个元素的下一个位置，即S为[nums.begin(),end)
        auto end = nums.begin();
        for(auto n=nums.begin(); n!=nums.end(); ++n)
        {
            //lower_bound使用二分查找
            //获取[m.begin(),end)中大于n的第一个元素
            auto iter = lower_bound(nums.begin(),end,*n);
            *iter = *n;
            //如果n大于S中所有的数，则需要拓展S
            if(iter==end)
                end++;
        }
        return end - nums.begin();
    }
};
```

### LeetCode322

#### 最小硬币找零方案（LeetCode322:Coin Change）

给出一个数组，其中有所有硬币面值的数值，再给出一个数值，我们要根据给出的硬币面值，用最少数量的硬币凑成给定数值的零钱。

```c++
Input: coins = [1, 2, 5], amount = 11
Output: 3 
Explanation: 11 = 5 + 5 + 1

Input: coins = [2], amount = 3
Output: -1
```

思路：同完全平方和一样，使用动态规划，从0开始计算，一直计算到给定数值amount。其中状态转换方程为：record[n] = min{1+record[n-coins[j]]},j代表coins中所有小于n的面值下标

代码实现：

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> record(amount+1);
        sort(coins.begin(),coins.end());//排序
        record.push_back(0);
        for(int i = 1;i<=amount;i++){
            record[i] = -1;
        }
        for (int i = 1;i<=amount;i++){//动态规划记录从0到amount的最小硬币凑零方案
            int tmpcount = 0;
            for (int j = 0;j<coins.size();j++){
                if(i>=coins[j]){//只计算小于amount的面值
                    if(record[i-coins[j]]!=-1){
                        if(record[i] == -1)
                            record[i] = record[i-coins[j]]+1;
                        else
                            record[i] = record[i]< record[i-coins[j]]+1?record[i]:record[i-coins[j]]+1;//取较小值
                    }
                }else{
                    break;//因为排过序，所以所有大于amount的面值不用考虑
                }
            }
        }
        
        return record[amount];
            
    }
};
```

### LeetCode334
#### 递增三元子序列（LeetCode334: Increasing Triplet Subsequence）

给出一个数组，求该数组中是否可以找到三个元素的子序列（不一定连续），保持递增关系。

```
Given [1, 2, 3, 4, 5],
return true.

Given [5, 4, 3, 2, 1],
return false.
```

思路：可以参考[LeetCode300:最长升序子序列](#leetcode300)

维护一个二元数组，参考LeetCode300中的思路三。也可以使用动态规划来求解这题

代码实现：

```c++
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        if(nums.size()<3){
            return false;
        }
        int *record = new int[2];
        for (int i = 0;i<2;i++){
            record[i] = INT_MAX;
        }
        bool res = true;
        for(int i = 0;i<nums.size();i++){
            res = true;
            for(int j = 0;j<2;j++){
                if(record[j]>=nums[i]){//将当前遍历到的元素和二元数组中的元素逐个比较，若二元数组中的元素大于该元素，则替换，直到当二元数组的元素均小于当前元素时，说明出现三元递增序列
                    res = false;
                    record[j] = nums[i];
                    break;
                }
            }
            if(res)
                return res;
        }
        return res;
    }
};
```

### 动态规划ending


## 递归

### LeetCode17

#### 手机号码的字符串组合（LeetCode17:Letter Combinations of a Phone Numbe）
按手机输入法的格式，输入一串数字，得到所有可能的字符串:
![leetcode_phonenum.png](/img/leetcode_phonenum.png)

简单的递归思路：需要注意的点就是传入参数时，传入引用可以节省大部分运行时间

代码:

{% highlight c++ %}
class Solution {
public:
    map<int,string> num_map = { {2,"abc"},{3,"def"},{4,"ghi"},{5,"jkl"},{6,"mno"},{7,"pqrs"},{8,"tuv"},{9,"wxyz"} };//关联容器的初始化
    
    vector<string> letterCombinations(string digits) {
        string str;
        vector<string> vs;
        if(digits.size() == 0)
            return vs;
        vs = letterCombinations_x(digits,vs,str,0,digits.size());
        return vs;
    }
    vector<string> &letterCombinations_x(string &digits,vector<string> & vs,string &str,int n,int size) {
        if(n == size){
            vs.push_back(str);
            return vs;
        }
        string num_str = num_map[digits[n]-'0'];
        for(int i=0;i<num_str.size();i++){
            string str_tmp = str;
            str_tmp.push_back(num_str[i]);
            letterCombinations_x(digits,vs,str_tmp,n+1,size);//开始递归
        }
        return vs;
    }
};

{% endhighlight%}

### LeetCode 46

#### 排列组合（LeetCode 46: Permutations）

给出一个整形数组，输出该整形数组的排列组合：

思路：将首元素和所有的元素（包括它自己）进行交换后，递归求解剩余元素的排列组合，具体思路可以见剑指offer的面试题38，字符串的排列组合。

{% highlight c++%}

class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
         vector<vector<int>> result;
        if(nums.empty()){
            return result;
        }
        int start = 0,end = nums.size()-1;
        permute_x(start,end,nums,result);
        return result;
        
    }
    
    void permute_x(int start,int end,vector<int>& vec,vector<vector<int>>& result ){
        if(start == end){
            result.push_back(vec);
            return;
        }
        
        for(int i = start;i<=end;i++){
            vector<int> vec1 = vec;
            int tmp = vec1[start];//首元素和其余元素交换后
            vec1[start] = vec1[i];
            vec1[i] = tmp;
            permute_x(start+1,end,vec1,result);//递归进行排列组合
        }
        
        return;
        
    }
    
};

{% endhighlight %}

### LeetCode48

#### n x n矩阵的旋转（LeetCode48: Rotate Image）

给一个nxn矩阵matrix，输出它向右旋转90度的新的nxn矩阵：

```
如input matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
]
输出：
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

思路：将外围的部分进行旋转后，剩下的部分依然是一个(n-2)x(n-2)的矩阵，递归求解

{% highlight c++ %}
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        if(matrix.empty()){
            return;
        }
        int size = matrix[0].size();
        rotate_x(matrix,size,size);
    }
    
    void rotate_x(vector<vector<int>>& matrix,int n,int size){
        if(n==0||n==1){
            return;
        }
        int start = (size-n)/2;
        int end = start+n-1;
        //将外围进行旋转操作
        for(int i = 0;i<n-1;i++){
            int tmp = matrix[start][start+i];
            matrix[start][start+i] = matrix[end-i][start];
            matrix[end-i][start] = matrix[end][end-i];
            matrix[end][end-i] = matrix[start+i][end];
            matrix[start+i][end] = tmp;
        }
        //递归求解更小规模的矩阵
        rotate_x(matrix,n-2,size);
    }
};

{% endhighlight %}


### LeetCode54

#### 旋转打印矩阵（LeetCode54：Spiral Matrix）

给一个mxn二维矩阵,顺时针的顺序将所有元素打印出来：

```
Input:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
Output: [1,2,3,6,9,8,7,4,5]

Input:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]
```

思路：递归，每次打印分为四个步骤：横向，纵向，再横向逆序，纵向逆序，然后递归打印剩余部分，依然是一个矩形。

注意：需要考虑最小问题的求解

1. 高为1的矩形打印，只需要一部
2. 长度为1的矩形打印，只需要一步
3. 高为2的矩形打印，只需要三部

```c++

class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> result;
        if(matrix.empty())
            return result;
        int height = matrix.size()-1;
        int len = matrix[0].size()-1;
        spiralOrder_x(matrix,0,len,height,result);
        return result;
        
    }
    
    void spiralOrder_x(vector<vector<int>>& matrix , int n, int len, int height , vector<int>& result){
        
        if(n>len/2 || n>height/2)
            return;
        int start_i = n,start_j = n,end_i = height - n,end_j = len - n;
        if((height - 2*n + 1)==1){//子问题1
            for(int j = start_j;j<=end_j;j++)
                result.push_back(matrix[start_i][j]);
            return;
        }
        
        if((len -2*n + 1) == 1){//子问题2
            for(int i = start_i;i<=end_i;i++){
                result.push_back(matrix[i][end_j]);
            }
            return;
        }
        
        if((height-2*n +1) == 2){//子问题3
            for(int j =start_j;j<=end_j;j++)
                result.push_back(matrix[start_i][j]);
            result.push_back(matrix[start_i+1][end_j]);
            for(int j = end_j-1;j>=start_j;j--)
                result.push_back(matrix[end_i][j]);
            return;
        }
        //常规四步打印
        for(int j = start_j;j<=end_j;j++)
                result.push_back(matrix[start_i][j]);
        for(int i = start_i+1;i<=end_i;i++)
            result.push_back(matrix[i][end_j]);
        for(int j = end_j-1;j>=start_j;j--)
            result.push_back(matrix[end_i][j]);
        for(int i = end_i-1;i>start_i;i--)
            result.push_back(matrix[i][start_j]);
        
        spiralOrder_x(matrix,n+1,len,height,result);//递归打印小规模矩形
        
    }
};

```

### LeetCode78

#### 求数组所有可能的子集（LeetCode78：Subsets）

给出一个没有重复元素的数组，输出它所有可能的子集：

```
Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```

递归：处理第一个元素，存在和不存在两种情况，如此循环处理数组的每一个元素

```c++

class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> result;
        vector<int> empty;
        if(nums.empty()){
            result.push_back(empty);
            return result;
        }
        int start = 0,end = nums.size();
        subsets_x(nums,start,end,result,empty);//从头开始遍历
        return result;
        
    }
    
    void subsets_x(vector<int>& nums,int start,int end,vector<vector<int>>& result,vector<int> cur){
        if(start == end){
            result.push_back(cur);
            return;
        }
        subsets_x(nums,start+1,end,result,cur);//当前元素在该子集中的情况
        cur.push_back(nums[start]);
        subsets_x(nums,start+1,end,result,cur);//当前元素不在子集中的情况
        return;
    }
};
```

### LeetCode79

#### 二维数组中的字符串匹配（LeetCode79:Word Search）

给出一个二维数组，和一个匹配字符串，求得该二维数组中有没有相连（上下左右）的字符和所给的字符串匹配。相连的字符不可以重复使用。

```
board =
[
  ['A'->,'B'->,'C',  'E'],
  ['S',  'F',  |'C',  'S'],
  ['A',  'D',<-|'E',  'E']
]

Given word = "ABCCED", return true.
Given word = "SEE", return true.
Given word = "ABCB", return false.

```

思路：先匹配第一个字符，然后递归匹配“匹配字符串”的其它字符，并且创建一个visited数组记录匹配过程中是否被访问，防治重复访问。

```c++

class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        if(board.empty()){
            if(word.empty())
            return true;
            return false;
        }
        bool result = false;
        int col = board.size();
        int raw = board[0].size();
        int **visited = new int*[col];
        for(int i = 0;i<col;i++){
            visited[i] = new int[raw];
        }
        
        for (int i = 0 ;i< col;i++){
            for (int j = 0 ; j < raw ; j++){
                visited[i][j] = 0;//记录是否被访问
            }
        }
        
        
        
        
        for (int i = 0 ;i< col;i++){
            for (int j = 0 ; j < raw ; j++){
                if(board[i][j] == word[0]){//先找到第一个匹配的字符
                    result = match(board,visited,word,0,i,j,word.size(),col,raw);
                    if(result)
                    return result;
                }
            }
        }
        
        return result;
    }
    
    bool match(vector<vector<char>>& board, int** visited ,string& word,int k, int i, int j,int size,int col, int raw){
        bool success = false;
        if(board[i][j] == word[k] ){
            visited[i][j] = 1;
            if(k == size-1){
                return true;
            }
            //四个方向进行回溯
            if(i<col-1 && !visited[i+1][j])
                success = match(board,visited,word,k+1,i+1,j,size,col,raw);
            if(!success && j<raw-1 && !visited[i][j+1])
                success = match(board,visited,word,k+1,i,j+1,size,col,raw);
            if(!success && i>0 && !visited[i-1][j])
                success = match(board,visited,word,k+1,i-1,j,size,col,raw);
            if(!success && j>0 && !visited[i][j-1])
                success = match(board,visited,word,k+1,i,j-1,size,col,raw);
            if(success)
                return success;
            else{
                visited[i][j] = 0;//如果匹配失败，消除访问记录
                return success;
            }
        }
        else
        return success;
    }
};
```


### LeetCode131

#### 回文分割（LeetCode131:Palindrome Partitioning）

给出一个字符串，给出该字符串所有可能的分割情况，使得每一个子串都是回文：

```
Input: "aab"
Output:
[
  ["aa","b"],
  ["a","a","b"]
]
```

* 思路：回文结构一共只有两种情况
    1. 以单个字符为中心
    2. 以两个相同的字符为中心
* 所以遍历该数组，尝试以每**一个字符为中心**进行回文合并
* 并测试是否有连续两个相同的字符，并以该**两个相同**的字符进行合并

代码实现（代码优化）：

```c++

class Solution {
public:
    vector<vector<string>> partition(string s) {
        vector<vector<string>> result;
        vector<string> start;
        
        for(auto c:s){
            char s[2] = {c, 0};
            start.push_back(s);
        }
        result.push_back(start);
        merge(start,result,0);
        return result;
    }
    
    void merge(vector<string>& vec,vector<vector<string>>& result,int start){
        for(int i = start; i<vec.size()-1;i++){
            
            if(i > 0){
                if(vec[i-1] == vec[i+1]){//以单个字符为中心进行回文合并
                    vector<string> vec_tmp = vec;//极大提高了运行效率，变量要在使用时再定义
                    vec_tmp[i-1] +=vec_tmp[i]+vec_tmp[i+1];
                    vec_tmp.erase(vec_tmp.begin()+i);
                    vec_tmp.erase(vec_tmp.begin()+i);
                    result.push_back(vec_tmp);
                    merge(vec_tmp,result,i-1);//合并后的一种分割方式路径
                }
            }
            
            if(vec[i] == vec[i+1]){//以两个相同字符为中心进行回文合并
                vector<string> vec_tmp2 = vec;
                vec_tmp2[i] += vec_tmp2[i+1];
                vec_tmp2.erase(vec_tmp2.begin()+i+1);
                result.push_back(vec_tmp2);
                merge(vec_tmp2,result,i);//合并后的一种分割方式路径
            }
        }
    }
};
```

### LeetCode200
#### 岛屿的数量 （LeetCode200:Number of Islands）

给定一个二位数组，每一个数字非1即0,1代表陆地，0代表海水，当1的四周被海水包围时才形成一个岛屿，多个1可以连接成一个岛屿。我们假设二维数组的周边都是海水，问该二位数组中有多少个岛屿？

```
Input:
11110
11010
11000
00000

Output: 1 //所有的1连接成了一个岛屿

Input:
11000
11000
00100
00011

Output: 3
```

思路：使用深度优先遍历dfs，将所有连在一起的1全部找到，然后构成一个岛屿

```c++
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        if(grid.empty()){
            return 0;
        }
        int col_size = grid.size();
        int raw_size = grid[0].size();
        //初始化访问数组
        int ** visited = new int *[col_size];
        for(int i = 0;i<col_size;i++){
            visited[i] = new int [raw_size];
        }
        
        for(int i = 0;i< col_size;i++){
            for (int j = 0;j<raw_size;j++){
                visited[i][j] = 0;
            }
        }
        
        int count = 0;
        for(int i = 0;i< col_size;i++){
            for (int j = 0;j<raw_size;j++){
                
                if(visited[i][j]== 0&&grid[i][j] == '1'){
                    numIslandx(grid,visited,i,j,col_size-1,raw_size-1);//深度优先遍历，将所有连在一起的1全部标记为已访问
                    count++;
                }
            }
        }
        return count;
    }
    //深度优先遍历
    void numIslandx(vector<vector<char>>& grid,int** visited,int col,int raw,int col_end,int raw_end){
        if(visited[col][raw] == 0 && grid[col][raw] == '1'){
            visited[col][raw] =1;//要先改变访问权限，否则会出现循环访问错误
            //四个方向
            if(col>0)
                numIslandx(grid,visited,col-1,raw,col_end,raw_end);
            if(raw>0)
                numIslandx(grid,visited,col,raw-1,col_end,raw_end);
            if(col<col_end)
                numIslandx(grid,visited,col+1,raw,col_end,raw_end);
            if(raw<raw_end)
                numIslandx(grid,visited,col,raw+1,col_end,raw_end);
        }
        return;
    }
};
```

### LeetCode207

#### 课程安排 （LeetCode207：Course Schedule）

有n门课需要学生学习，但其中有一些课之间存在先后顺序的依赖关系如(0,1)表示课程1需要在课程0之后学习，给出所有课程的依赖关系后，问学生能否按这种依赖关系学习完所有的课程。

```
Input: 2, [[1,0]] 
Output: true
Explanation: There are a total of 2 courses to take. 
             To take course 1 you should have finished course 0. So it is possible.

Input: 2, [[1,0],[0,1]]
Output: false
Explanation: There are a total of 2 courses to take. 
             To take course 1 you should have finished course 0, and to take course 0 you should
             also have finished course 1. So it is impossible.

```

我的思路：能否上完所有的课程取决于这些依赖关系是否构成回环

1. 所以我们给所有的课程设置一个访问记录
2. 先将所有的边按起点进行排序，从第一条边开始dfs深度优先遍历，遍历过程中设置课程的访问情况，回溯时需要消除对课程的访问记录
3. 若在深度遍历过程中碰到一个曾经访问过的课程，说明出现回环。
4. 并且每条边也有访问信息的记录，只要曾经访问过的边没有出现回环，之后也不用再进行深度优先遍历
5. 如此将所有的边遍历一边后，都没有出现回环，则说明可以学习所有的课程

PS:

1. 排序算法sort的使用
2. 搜索函数equal_range的使用

代码实现：

```c++
class Solution {
public:
    bool canFinish(int numCourses, vector<pair<int, int>>& prerequisites) {
        int *visited = new int[numCourses];
        int *visited_edge = new int[prerequisites.size()];
        sort(prerequisites.begin(),prerequisites.end(),[](pair<int,int> p1,pair<int,int> p2){
            return p1.first<p2.first;
        });//现将所有的依赖关系边，按起点进行排序，因为，我们之后需要根据排序好的这些边，搜索相邻的边
        
        for (int i = 0;i<numCourses;i++){
            visited[i] = 0;
        }
        
        for (int i = 0;i<prerequisites.size();i++){
            visited_edge[i] = 0;
        }
        int end = prerequisites.size()-1;
        bool result = true;
        for(int i = 0;i<end;i++){//遍历所有的边
            if(visited_edge[i] == 0){//若该边已经被访问过了，则无需再次验证
                visited[prerequisites[i].first] = 1;//设置该边起点的访问记录
                result &= edge_dfs(visited,visited_edge,prerequisites,prerequisites[i].second);//开始进行深度优先遍历
                if(!result)
                    return false;
                visited[prerequisites[i].first] = 0;//消除该起点的访问记录
            }
        }
        
        return result;
    }
    
    bool edge_dfs(int *visited,int *visited_edge,vector<pair<int, int>>& prerequisites,int value){
        pair<int, int> valuepair(value,1);
        pair<vector<pair<int, int>>::iterator,vector<pair<int, int>>::iterator> range = equal_range(prerequisites.begin(),prerequisites.end(),valuepair,[](pair<int, int> p1,pair<int, int> p2){
            return p1.first<p2.first;
        });//根据排好序的边，搜索以起点value开始的所有边，也就是邻边
        bool result = true;
        int len = range.second - range.first;//计算邻边个数，为0，说明没有回环
        if(len == 0)
            return true;
        int newstart = range.first-prerequisites.begin();
        for(int i = newstart,j=0;i<newstart+len;i++,j++){//在以所有的邻边为起点开始深度优先遍历
            if(visited[(range.first+j)->first] == 1){//访问到重复节点，说明有环
                return false;
            }
            if(visited[(range.first+j)->first] ==1)
                return true;//访问到之前访问过的边，该边之前访问时无环，无需重复访问
            visited[(range.first+j)->first] = 1;
            visited_edge[i] = 1;//设置边的访问记录
            result = edge_dfs(visited,visited_edge,prerequisites,prerequisites[i].second);//开始深度优先遍历
            if(!result)
                return false;
            visited[(range.first+j)->first] = 0;//消除对点的访问记录
            
        }
        
        return true;
    }
};

```

思路2：使用DFS的拓扑排序，使用栈来实现
![参考](https://github.com/guanjunjian/LeetCode/blob/master/Solution/207.%E8%AF%BE%E7%A8%8B%E8%A1%A8.md)

1.计算所有点的入度
2.将入度为0的顶点入栈
3.出栈，获取顶点A，并将以A顶点为起始点的顶点B的入度减一，如果减一后，B的入度为0，则将B入栈
4.如果还没有将numCourses个顶点输出完，就已经空栈，则说明有环

```c++
class Solution {
public:
    bool canFinish(int numCourses, vector<pair<int, int>>& prerequisites) 
    {
        int* inDgree = new int[numCourses];
        memset(inDgree,0,sizeof(int)*numCourses);
        //记录每个顶点的入度
        for(auto p : prerequisites)
        {
            ++inDgree[p.first];
        }
        int top = -1;
        //将度为0的顶点入栈
        for(int i=0; i<numCourses; ++i)
        {
            if(!inDgree[i])
            {
                inDgree[i] = top;
                top = i;
            }
        }
        bool isOK = true;
        for(int i=0; i<numCourses; ++i)
        {
            //如果还没输出numCourses个点，栈就为空，说明有环
            if(top==-1) 
            {
                isOK = false;
                break;
            }
            //出栈
            int j = top; 
            top = inDgree[top];
            for(auto p : prerequisites)
            {
                if(p.second==j) 
                {
                    --inDgree[p.first];
                    if(!inDgree[p.first])
                    {
                        inDgree[p.first] = top;
                        top = p.first;
                    }
                }
                
            }  
        }
        delete[] inDgree;
        return isOK;
    }
};
```
### LeetCode210
#### 课程表II（LeetCode210：Course ScheduleII）

题目同LeetCode207，只不过这里需要输出课程的可能的安排顺序。

思路同LeetCode207，需要将栈中弹出的课程进行保存

```c++
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {
        int *inDegrees = new int[numCourses];
        stack<int> sta;
        //初始化所有的入度数组
        for(int i = 0;i<numCourses;i++){
            inDegrees[i] = 0;
        }
        //设置所有课程节点的入度
        for(auto pair:prerequisites){
            inDegrees[pair.first]++;
        }
        
        for(int i = 0;i<numCourses;i++){
            if(!inDegrees[i]){
                sta.push(i);
            }
        }
        vector<int> course_order;
        vector<int> empty_order;
        while(course_order.size()!=numCourses){
            if(sta.empty()){//栈为空
                delete[] inDegrees;
                return empty_order;
            }
            course_order.push_back(sta.top());
            int course_tmp = sta.top();
            sta.pop();//弹出后，对应元素的入度减少
            for(auto pair:prerequisites){
                if(pair.second == course_tmp){
                    inDegrees[pair.first]--;//入度减少
                    if(inDegrees[pair.first]==0)
                        sta.push(pair.first);//入度为0，压入栈
                }
            }
                
        }
        delete[] inDegrees;
        return course_order;
        
        
    }
};
```

### LeetCode329
#### 二维数组最长递增路径（LeetCode329:Longest Increasing Path in a Matrix）

给出一个二维数组，找出其中一条最长的递增序列的路径，返回其长度。

```
Input: nums = 
[
  [9*,9 ,4],
  [6*,6 ,8],
  [2*,1*,1]
] 
Output: 4 
Explanation: The longest increasing path is [1, 2, 6, 9].

Input: nums = 
[
  [3*,4*,5*],
  [3 ,2 ,6*],
  [2 ,2 ,1 ]
] 
Output: 4 
Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.

```

思路：使用递归加深度优先搜索，进一步可以使用动态规划优化递归过程。不需要使用访问记录表，因为在递归递增序列的过程当中不会对一个元素进行重复遍历。

代码实现：

```c++
class Solution {
public:
    int longestIncreasingPath(vector<vector<int>>& matrix) {
        if(matrix.empty())
            return 0;
        int col_size = matrix.size();
        int raw_size = matrix[0].size();
        int **record = new int*[col_size];
        for(int i = 0;i<col_size;i++){
            record[i] = new int[raw_size];
        }
        
        for(int i = 0;i<col_size;i++){
            for(int j = 0;j<raw_size;j++){
                record[i][j] = 0;//初始化记录以每个节点开始的最长递增序列的长度
            }
        }
        
        int maxlen = 0;
        for(int i = 0;i<col_size;i++){
            for(int j = 0;j<raw_size;j++){
                if(record[i][j] == 0){//若最长递增路径长度记录中没有改记录，则进行递归深度遍历
                    int len = dfs(matrix,record,i,j,col_size,raw_size);
                    maxlen = len>maxlen?len:maxlen;
                }
                
            }
        }
        
        return maxlen;
        
        
    }
    
    int dfs(vector<vector<int>>& matrix,int **record,int i,int j,int col_size,int raw_size){
        int maxlen = 1;
        //四个方向进行深度优先遍历
        if(i-1>=0 && matrix[i][j]<matrix[i-1][j]){
            int len = 0;
            if(record[i-1][j]==0){
                len = 1+dfs(matrix,record,i-1,j,col_size,raw_size);
                maxlen = len>maxlen?len:maxlen;
            }else{
                len = 1+record[i-1][j];
                maxlen = len>maxlen?len:maxlen;
            }       
        }
        
        if(j-1>=0 && matrix[i][j]<matrix[i][j-1]){
            int len = 0;
            if(record[i][j-1]==0){
                len = 1+dfs(matrix,record,i,j-1,col_size,raw_size);
                maxlen = len>maxlen?len:maxlen;
            }else{
                len = 1+record[i][j-1];
                maxlen = len>maxlen?len:maxlen;
            }       
        }
        
        if(i+1<col_size && matrix[i][j]<matrix[i+1][j]){
            int len = 0;
            if(record[i+1][j]==0){
                len = 1+dfs(matrix,record,i+1,j,col_size,raw_size);
                maxlen = len>maxlen?len:maxlen;
            }else{
                len = 1+record[i+1][j];
                maxlen = len>maxlen?len:maxlen;
            }       
        }
        
        if(j+1<raw_size && matrix[i][j]<matrix[i][j+1]){
            int len = 0;
            if(record[i][j+1]==0){
                len = 1+dfs(matrix,record,i,j+1,col_size,raw_size);
                maxlen = len>maxlen?len:maxlen;
            }else{
                len = 1+record[i][j+1];
                maxlen = len>maxlen?len:maxlen;
            }       
        }
        
        record[i][j] = maxlen;//记录到表格中
        return maxlen;
        
    }
};
```


### 递归ending





## 位运算,数学边界问题

### LeetCode7

#### 整型数反转(LeetCode7:Reverse Integer)

将一个整型数的高位和低位进行反转，负数不变号，如果一个整型数反转后溢出后则返回0:

例子：
* 123  ＝》321
* －12 ＝》－21
* －120 ＝》－21

注意点：

* 整型数的范围为 **[-2^31,2^31-1];所以可能出现－2^31在范围内，而它的绝对值却不在整型范围内**
* 要计算2^31次方：long upper = **(2L<<30);//L不能掉**

{% highlight c++ %}
class Solution {
public:
    int reverse(int x) {
        bool positive = true;
        long x2 = (long)x;
        long upper = (2L<<30)-1;
        //处理正负号
        if(x2<0){
            positive = false;
            upper = upper-1;
            x2 = labs(x2);//这里不能用abs，abs无法处理-2^31的绝对值，因为它处理整型数，转换过来的正数会溢出
        }
        if(x2 == 0)
            return 0;
        //处理末端为0的情况
        while(!(x2%10))
            x2 /= 10;
        vector<long> digit;
        while(x2>=10)
        {
            digit.push_back(x2%10);
            x2 = (x2-x2%10)/10;
        }
        digit.push_back(x2);
        long result = 0;
        for(int k = 0;k<digit.size();k++){
            result = result*10 + digit[k];
            if(result>upper){
                return 0;
            }
        }
        if(positive)
            return result;
        else
            return -result;
    }
};
{% endhighlight %}

### LeetCode29

#### 两个整型数做除法，不使用乘除运算符(LeetCode29:Divide Two Integers)

给两个整数相除，得到除数，但不能使用乘除运算符

要求：

1. 除数和被除数都是32位的整型数
2. 除数不能为0
3. 整型数的范围为：**[-2^31,2^31-1]**,当相除后的结果溢出时，返回2^31-1

思路：使用位运算，逐个将结果中的每一位（二进制位）数求出。将除数向左<<逐个移位(将除数乘以2)与被除数进行比较。如15/2的计算过程：

1. 2乘以2等于4，小于15
2. 4乘以2等于8，小于15
3. 8乘以2等于16，大于15
4. 所以这里累计4（2*2），然后用15-8=7
5. 2乘以2等于4，小于7
6. 4乘以2等于8，大于7，这里累计2。且7-4 = 3。
7. 2乘以2等于4，大于3，累计1。且3-2 =1
8. 1小于2，循环结束。将所有累计相加得到4+2+1=7
9. 所以最后相除的结果等于7 

{% highlight c++ %}
class Solution {
public:
    int divide(int dividend, int divisor) {
        //处理边界问题
        long int_max = (2L<<30)-1,int_min = -(2L<<30);
        if(dividend == int_min && divisor == -1){
            return int_max;
        }
        
        long tmp ,res = 0,res_tmp = 0;
        //判断正负号
        bool positive = true;
        if((dividend > 0 && divisor<0)||(dividend < 0 && divisor > 0)){
            positive = false;
        }
        long divd = labs((long)dividend);
        long divs = labs((long)divisor);
        
        
        while(divd>=divs){
            tmp = divs;
            res_tmp = 1;
            while(divd >= (tmp <<= 1))
            {
                res_tmp <<= 1;
            }
            divd -= tmp >> 1;//循环一次，被除数减去一次移位后的除数
            res += res_tmp;
        }
        if(positive)
            return res;
        else
            return -res;
    }
};
{% endhighlight %}

### LeetCode50

### 求幂myPow()(LeetCode50: Pow(x, n))

题目要求：实现pow(x,n)

* -100.0 < x < 100.0
* n 是一个32位有符号整数。

```
Input: 2.00000, -2
Output: 0.25000
Explanation: 2-2 = 1/22 = 1/4 = 0.25
```

思路：扫描n的二进制上的为1的bit,来计算幂的结果，例如：n为139，则其二进制为10001011，那么x^n == x^(1+2+8+128) == (x^1) * (x^2) * (x^8) * (x^128)

PS:需要考虑的特殊情况

1. x取值为0时，0的正数次幂是1，而负数次幂是没有意义的；判断x是否等于0不能直接用“==”。
2. 对于n取值INT_MIN时，**-n并不是INT_MAX**，这时需要格外小心。
3. 尽量使用**移位运算来代替除法运算**，加快算法执行的速度。

判断double变量是否为零是否正确的题目。判断double变量是否为零 **不能像我们直观想象的那样double d;if( d == 0 );**这种做法是极其错误的,因为double是双精度的，他表示本身就是有精度误差的，所以这样判断零不正确。应正确步骤应该是先 **定义一个精度范围**，当double小于该精度范围时就可以判定double变量是否为0了。代码如下：

```
#define MIN_VALUE 1e-8
#define IS_DOUBLE_ZERO(d)  (abs(d) < MIN_VALUE)
```

代码：

{%highlight c++%}
class Solution {
public:
    double myPow(double x, int n) {
        if(n<0){
            if(n == INT_MIN)
                return 1/(myPow(x,INT_MAX)*x);
            else
                return 1/myPow(x,-n);
        }
        double ans = 1;
        if(n>0){
            while(n!=0){
                if(n&1) //只在bit为1的位乘如到结果中去
                    ans *= x;
                x *=x;
                n >>=1;
            }
        }
        
        return ans;
    }
};

{% endhighlight %}

### LeetCode69

#### 求平方根（LeetCode69:Sqrt(x)）

如题，给出一个数，求它的平方根，若平方根不为整数，则返回小于该平方根的最大的整数。

思路：二分法求值

注意特殊情况：

1. 乘以2时可以用位运算替代
2. 注意二分法求平方根的过程中，可能出现有的**数的平方大于整型数的最大可能的值INT_MAX**，所以应该用long 来保存临时结果。

```c++
class Solution {
public:
    int mySqrt(int x) {
        if (x==0)
            return 0;
        long pre = 1, back = 1;
        long tmp = 1;//用long保存临时结果
        while(tmp < x){
            pre = back;
            back <<= 1;//位运算替代乘以2
            tmp =back*back;
        }
        long mid;
        while(pre <= back){// 二分法求值
            mid = (pre+back)/2;
            tmp = mid*mid;
            if(tmp > x)
                back = mid - 1;
            else if(tmp < x )
                pre = mid + 1;
            else
                return mid;
        }
        if(pre*pre>x)
            return pre-1;
        else
            return pre;
    }
};
```
### LeetCode172

#### n的阶乘尾部0的个数（LeetCode172:Factorial Trailing Zeroes）
给定一个数n，求它的阶乘结果尾部0的个数

```
Input: 3
Output: 0
Explanation: 3! = 6, no trailing zero.

Input: 5
Output: 1
Explanation: 5! = 120, one trailing zero.
```

思路：

1. 只有当乘数中包含一对2和5时，尾部才可能增加一个0
2. 在n递增的过程中，5的个数肯定多于2，所以我们需要求出1~n中包含的因数5的个数
3. 注意如25包含两个5，125包含3个5

代码实现

```c++
class Solution {
public:
    int trailingZeroes(int n) {
         return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);//递归深一层，相当于先求有多少个5，再求有多少个25，。。。
        
    }
};
```
### LeetCode179

#### 将所有数字拼成一个最大数（LeetCode179：Largest Number）

给出一个整型数组，将这些数字按一定顺序排放，组成一个最大的数字

```
Input: [10,2]
Output: "210"

Input: [3,30,34,5,9]
Output: "9534330"
```

思路：见剑指offer面试题45:把数组排成最小的数

PS:

1. lamada表达式的使用
2. sort函数的使用
3. 数字到字符串的转换

代码实现：

```c++
class Solution {
public:
    string largestNumber(vector<int>& nums) {
        sort(nums.begin(),nums.end(),[](int nums1,int nums2){
            return to_string(nums1)+to_string(nums2)>to_string(nums2)+to_string(nums1);
        });//传入一个自定义比较函数
        if(nums[0] == 0) return "0";
        string result;
        for(int i= 0;i<nums.size();i++)
            result +=to_string(nums[i]);
        return result;
    }
};
```

### LeetCode190

#### 翻转bits(LeetCode190: Reverse Bits)

给出一个数，输出将其二进制bit翻转后的数字。

```
Input: 43261596
Output: 964176192
Explanation: 43261596 represented in binary as 00000010100101000001111010011100, 
             return 964176192 represented in binary as 00111001011110000010100101000000.
```

思路：

1. 对n从低位到高位进行逐位检测
2. 将检测结果放入result低位后向前移动一位
3. 检测结束后，所有bit都完成了翻转

```c++
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        int result = 0;
        for(int i = 0;i<32;i++){
            result <<= 1;//将所得到的结果向前移动存放
            result |= (n&1);//位检测
            n >>= 1;//进行下一位的检测
        }
        return result;
    }
};
```

### LeetCode191

#### 位为1的个数（LeetCode191:Number of 1 Bits）

检测一个数n的二进制位中为1的个数

```
Input: 11
Output: 3
Explanation: Integer 11 has binary representation 00000000000000000000000000001011 

Input: 128
Output: 1
Explanation: Integer 128 has binary representation 00000000000000000000000010000000
```

思路同上LeetCode190

代码：

```c++
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int count = 0 ;
        for(int i = 0;i<32;i++){
            if(n&1)
                count++;
            n >>=1;
        }
        return count;
    }
};
```
### LeetCode202
#### 快乐数（LeetCode202: Happy Number）

快乐数的定义如下：如下循环，最后循环的平方和结果为1即为快乐数

```
Input: 19
Output: true
Explanation: 
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
```

思路：

1. 循环求解
2. 同求商LeetCode166，求循环小数的思路一致，使用record记录
3. 当出现循环时，说明不为快乐数

代码实现：

```c++
class Solution {
public:
    int calculate(int n)//求平方和
    {
        int res = 0;
        while(n)
        {
            int temp = n%10;
            res += temp*temp;
            n /= 10;
        }
        return res;
    }
    bool isHappy(int n) {
        unordered_set<int> res;//用于记录
        while(n!=1)
        {
            if(res.find(n)!=res.end()) return false;//出现重复数，说明不为快乐数
            res.insert(n);
            n = calculate(n);
        }
        return true;
    }
};
```
### LeetCode204

#### 质数计数（LeetCode204：Count Primes）

给出一个数n，计算小于n的正数中有多少个质数

```
Input: 10
Output: 4
Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.
```

思路：

![](http://img.blog.csdn.net/20150625165121090) 

1. 因为所有的数如果不是质数，肯定可以由比它小的数相乘得到。
2. 所以我们**由小（最小从2开始）到大**遍历，每遍历到一个数时，将小于n的**所有可能的倍数**都标记为已访问
3. 所以只要再遍历到已访问的数时，就知道他不是一个质数
4. 当遍历到一个数没有访问时，说明它不能由比它小的数相乘得到,则是一个质数

代码实现：

```c++
class Solution {
public:
    int countPrimes(int n) {
        if(n<=2)
            return 0;
        int* record = new int[n];
        for(int i = 0;i<n;i++){
            record[i] = 0;//初始化访问数组
        }
        int count = 0;
        for(int i=2;i<n;i++){
            if(record[i] == 0){//没有访问说明为质数
                for(int j = i,k=2;j<n;j=i*k,k++){//遍历当前数的所有的倍数
                    record[j] = 1;
                }
                count++;
            }
        }
        return count;
    }
};
```

### LeetCode227

#### 基础计算器II（LeetCode227：Basic Caculator II）
给出一个字符串，其中涉及到+ - * /的基础运算，根据运算符的优先级计算其运算后的结果

```
Input: "3+2*2"
Output: 7

Input: " 3/2 "
Output: 1

Input: " 3+5 / 2 "
Output: 5
```

思路1：比较直接不建议使用

1. 先将所有的* /计算得到结果
2. 然后进行+ - 的运算

```c++
class Solution {
public:
    int calculate(string s) {
        vector<int> num;
        vector<char> op;
        string numstr;
        int restmp;
        //处理乘除
        for (int i = 0; i<s.size(); i++) {
            if(!isdigit(s[i])){
                if(s[i] == ' '){
                    continue;
                }else{
                    op.push_back(s[i]);
                    continue;
                }
            }
            numstr.clear();
            while (isdigit(s[i]) && i<s.size()) {
                numstr = numstr + s[i];
                i++;
            }//循环结束时，要么字符串遍历结束，要么指向下一个运算符
            i--;
            if (!num.empty() && !op.empty()) {
                if (op.back() == '*') {
                    restmp = stoi(numstr)*num.back();
                    num.pop_back();
                    op.pop_back();
                    num.push_back(restmp);
                }else if (op.back() == '/') {
                    restmp = num.back() / stoi(numstr);
                    num.pop_back();
                    op.pop_back();
                    num.push_back(restmp);
                }
                else {
                    num.push_back(stoi(numstr));
                }
            }
            else {
                num.push_back(stoi(numstr));
            }
        }
        //处理加减
        int result = num.front();
        for (int i = 0; i<num.size() - 1; i++) {
            if (op[i] == '+')
                result += num[i + 1];
            if (op[i] == '-')
                result -= num[i + 1];
        }

        return result;
    }
};
```

思路2：

1. 先将中序表达式转换成后缀表达式
2. 然后根据后缀表达式进行依次计算

中序表达式转换成后序表达式的过程：

1. 遇到数字直接输出
2. 遇到操作符先压入栈，若该操作符优先级高于栈顶的操作符，则先输出栈顶操作符，直到栈顶操作符的优先级低于或等于要压入的操作符
3. 循环1,2将字符串遍历完后，再讲栈内的操作符依次弹出得到后缀表达式

[代码实现参考](https://github.com/guanjunjian/LeetCode/blob/master/Solution/227.%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8II.md)


### LeetCode268
#### 缺失数字（LeetCode268： Missing Number）

给出一个长度为n数组，所有数组内所有元素的范围在0~n之间，且没有重复的数字，求哪个数字缺失了。

```
Input: [3,0,1]
Output: 2

Input: [9,6,4,2,3,5,7,0,1]
Output: 8
```

思路1：哈希表

思路2：求和后相减

思路3：异或运算

![leetcode268](/img/leetcode268.png)

代码实现：

思路2：

```c++
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int sum = 0;
        for(int num:nums)
            sum+=num;
        return ((nums.size()+1)*nums.size()/2)-sum;
    }   
};
```

思路3：

```c++
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int res = 0;
        int n = nums.size();
        for(int i=0; i<=n; ++i)
        {
            res ^= i;
            if(i!=n) res ^= nums[i];
        }
        return res;
    }
};
```


### LeetCode326

#### 判断是否为3的幂（LeetCode326：Power of Three）

给定一个整数，判断该整数是否为3的幂

```c++
Input: 27
Output: true

Input: 0
Output: false

Input: 9
Output: true

Input: 45
Output: false

```

要求：不使用循环和递归

思路：

1. 先求整数范围INT_MAX内，3的幂可以达到的最大幂maxpower
2. 所有能被maxpower整除的数即为3的幂

PS：使用power函数，和log函数，求3的幂可以到达的最大幂

换底公式：![leetcode326](/img/leetcode326.png)

因此要求int的表示的最大的3的幂，设为maxPower = 3^exp，exp = log3(INT_MAX)

根据换底公式有： log3(INT_MAX) = log2(INT_MAX) / log2(3)

因此，maxPower = power(3, (int)log2(INT_MAX) / log2(3))

 代码实现：

```c++
class Solution {
public:
    bool isPowerOfThree(int n) {
        if(n<=0) return false;
        int maxpower = pow(3,(int)(log(INT_MAX)/log(3)));//求3的幂在整型数范围内的最大数
        return maxpower%n?false:true;//判断是否可以整除
    }
};
```


### 位运算,数学,边界问题ending













## 数据分类

### LeetCode49

#### 字符串分类(LeetCode49：Group Anagrams)

给一个数组，将所有字符相同的字符串分到一个数组里面去

```
Input: ["eat", "tea", "tan", "ate", "nat", "bat"],
Output:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
```

思路：利用unordered_map(**哈希表**)**索引**的性质，先将所有字符串**进行排序**，排序后一样的字符串放到一个数组。

{% highlight c++ %}
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>> result;
        if(strs.empty()){
            return result;
        }
        unordered_map<string,vector<string>> diff;
        for(int i= 0 ;i<strs.size();i++){
            string sorted_str = strs[i];
            sort(sorted_str.begin(),sorted_str.end());//对字符串进行排序
            if(diff.count(sorted_str)){//查看当前map中有没有出现过该索引
                diff[sorted_str].push_back(strs[i]);
            }else{
                vector<string> new_vec;
                new_vec.push_back(strs[i]);
                diff.insert(make_pair(sorted_str,new_vec));
            }
        }
        
        for(auto pair : diff){//map遍历的方法
            result.push_back(pair.second);
        }
        
        return result;
    }
};
{% endhighlight %}

### 数据分类ending


## 树

### LeetCode94

#### 二叉树的中序遍历（LeetCode94:Binary Tree Inorder Traversal）

给一个二叉树，输出它的中序遍历序列，不使用递归，而是迭代的方法来求其序列：

```
Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,3,2]
```

思路：递归都可以使用栈来代替：

1. 先向左遍历，将沿路径的所有节点压入栈结构，遇到空节点时弹出栈顶元素，输出到序列
2. 检测其右节点是否为空,不为空，重复步骤1
3. 如此循环迭代，直到栈为空。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> stack;
        TreeNode *cur = root;
        
        while(true){
            if(cur!=NULL){
                stack.push(cur);
                cur = cur->left;//向左遍历，沿路所有节点压入栈
            }else{
                if(stack.empty()){//栈为空时遍历结束
                    break;
                }
                cur = stack.top();
                result.push_back(cur->val);
                stack.pop();
                if(cur->right!=NULL){//检测右节点是否为空
                    cur = cur->right;
                }else{
                    cur = NULL;
                }  
            } 
        }
        return result;
    }
};
```

### LeetCode98

#### 验证是否是二叉搜索树（LeetCode98:Validate Binary Search Tree）

如题，思路：中序遍历是否为递增序列,借鉴题94的求中序遍历的做法。

注意：

1. NULL为0，0=＝NULL
2. INT_MIN = -2147483648

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        long curnum = -2147483649;
        stack<TreeNode*> stack;
        TreeNode *cur = root;
        bool result = true;
        
        while(true){
            if(cur!=NULL){
                stack.push(cur);
                cur = cur->left;//向左遍历，沿路所有节点压入栈
            }else{
                if(stack.empty()){//栈为空时遍历结束
                    break;
                }
                cur = stack.top();
                if(cur->val > curnum){//比较，是否是递增序列
                    curnum = cur->val;
                }else{
                    result = false;
                    break;
                }
                stack.pop();
                if(cur->right!=NULL){//检测右节点是否为空
                    cur = cur->right;
                }else{
                    cur = NULL;
                }  
            } 
        }
        return result;
    }
};


```

### LeetCode101

#### 验证是否是对称树（LeetCode101:Symmetric Tree）

给出一个树的结构，判断它是否是对称树：

```
True:

    1
   / \
  2   2
 / \ / \
3  4 4  3

False:

    1
   / \
  2   2
   \   \
   3    3
```

思路：**按层遍历**，使用栈作为辅助结构，一个从左到右遍历，一个从右到左遍历，在弹出的同时比较节点值是否相等。**不能忽略空节点**。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        stack<TreeNode *> sta;
        stack<TreeNode *> sta_sym;
        TreeNode * cur = nullptr,* cur_sym = nullptr;
        sta.push(root);
        sta_sym.push(root);
        bool result =false;
        while(true){
            //只有当两个栈同时为空，才算对称树
            if(sta.empty() && sta_sym.empty()){
                result = true;
                break;
            }else if(sta.empty() || sta_sym.empty()){
                break;
            }
            cur = sta.top();
            cur_sym = sta_sym.top();
            //比较栈顶元素
            if(cur == nullptr && cur_sym == nullptr){
                sta.pop();
                sta_sym.pop();
            }else if((cur != nullptr && cur_sym != nullptr)&&(cur->val == cur_sym->val)){
                sta.pop();
                sta_sym.pop();
                //从左到右顺序，层次遍历入栈
                if(cur->left != NULL || cur->right != NULL){
                if(cur->left == NULL)
                    sta.push(nullptr);
                else
                    sta.push(cur->left);
                
                if(cur->right == NULL)
                    sta.push(nullptr);
                else
                    sta.push(cur->right);
                }
                
                //从右到左的顺序，层次遍历入栈
                if(cur_sym->left != NULL || cur_sym->right != NULL){
                if(cur_sym->right == NULL)
                    sta_sym.push(nullptr);//空指针也要入栈
                else
                    sta_sym.push(cur_sym->right);
                
                if(cur_sym->left == NULL)
                    sta_sym.push(nullptr);
                else
                    sta_sym.push(cur_sym->left);
                }
            }else{
                break;
            }
            
        }
        
        return result;
    }
};

```

### LeetCode102

#### 层次遍历打印（LeetCode102:Binary Tree Level Order Traversal）

描述：给一棵树，层次遍历打印其元素

```
    3
   / \
  9  20
    /  \
   15   7

[
  [3],
  [9,20],
  [15,7]
]
```

思路：使用队列，记录每一层最后一个元素last

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        if(root == NULL){
            return result;
        }
        TreeNode *last = root,*cur;
        queue<TreeNode*> que;
        vector<int> cur_vec;
        que.push(root);
        
        
        while(!que.empty()){
            cur  = que.front();
            cur_vec.push_back(cur->val);
            
            if(cur == last){//打印到该层最后一个节点时
                result.push_back(cur_vec);
                cur_vec.clear();
                que.pop();
                if(cur->left != NULL)
                    que.push(cur->left);
                if(cur->right != NULL)
                    que.push(cur->right);
                last = que.back();
            }else{
                que.pop();
                if(cur->left != NULL)
                    que.push(cur->left);
                if(cur->right != NULL)
                    que.push(cur->right);
            }
        }
        
        return result;
    }
};
```


### LeetCode103

#### Zigzag打印(LeetCode103:Binary Tree Zigzag Level Order Traversal)

之字型打印，和Leetcode102略有区别。

```
    3
   / \
  9  20
    /  \
   15   7

[
  [3],
  [20,9],
  [15,7]
]
```
思路：使用双端队列，打印一层后换向打印，使用bool变量seq来控制打印方向。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> result;
        if(root == NULL){
            return result;
        }
        TreeNode *last = root,*cur;
        deque<TreeNode*> que;
        vector<int> cur_vec;
        que.push_back(root);
        bool seq = true;
        
        
        while(!que.empty()){
            if(seq){//seq控制打印方向
                cur  = que.front();
                cur_vec.push_back(cur->val);
                if(cur == last){//打印到该层最后一个节点时
                    result.push_back(cur_vec);
                    cur_vec.clear();
                    que.pop_front();
                    if(cur->left != NULL)
                        que.push_back(cur->left);
                    if(cur->right != NULL)
                        que.push_back(cur->right);
                    last = que.front();
                    seq = !seq;
                }else{
                    que.pop_front();
                    if(cur->left != NULL)
                        que.push_back(cur->left);
                    if(cur->right != NULL)
                        que.push_back(cur->right);
                }
            }else{//逆序打印
                cur  = que.back();
                cur_vec.push_back(cur->val);
                if(cur == last){//打印到该层最后一个节点时
                    result.push_back(cur_vec);
                    cur_vec.clear();
                    que.pop_back();
                    if(cur->right != NULL)
                        que.push_front(cur->right);
                    if(cur->left != NULL)
                        que.push_front(cur->left);
                    last = que.back();
                    seq = !seq;
                }else{
                    que.pop_back();
                    if(cur->right != NULL)
                        que.push_front(cur->right);
                    if(cur->left != NULL)
                        que.push_front(cur->left);
                }
            }
        }
        
        return result;
    }
};
```

### LeetCode104

#### 求二叉树的高度（LeetCode104:Maximum Depth of Binary Tree）

给出一棵二叉树，求其高度

思路：

1. 深度优先，递归求解
2. 广度优先，利用队列，按层遍历，求层的数目即可

1. 深度优先，两种解法

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root == NULL)
            return 0;
        int r_height = 0,l_height = 0;
        int height = 0;
        if(root->right!=NULL){
            r_height = maxDepth(root->right);
        }
        if(root->left!=NULL){
            l_height = maxDepth(root->left);
        }
        height = r_height >= l_height?r_height+1:l_height+1;
        return height;
        
    }
};



//一行代码即可

int maxDepth(TreeNode *root)
{
    return root == NULL ? 0 : max(maxDepth(root -> left), maxDepth(root -> right)) + 1;
}
```

2. 广度优先：

```c++

int maxDepth(TreeNode *root)
{
    if(root == NULL)
        return 0;
    
    int res = 0;
    queue<TreeNode *> q;
    q.push(root);
    while(!q.empty())
    {
        ++ res;
        for(int i = 0, n = q.size(); i < n; ++ i)
        {
            TreeNode *p = q.front();
            q.pop();
            
            if(p -> left != NULL)
                q.push(p -> left);
            if(p -> right != NULL)
                q.push(p -> right);
        }
    }
    
    return res;
}
```


### LeetCode105

#### 根据前序和中序遍历序列构造树结构（LeetCode105： Construct Binary Tree from Preorder and Inorder Traversal）

思路：递归求解，根据前序遍历第一个元素为根节点的特点，再在中序遍历中寻找这个元素，根据该元素将中序遍历和前序遍历的序列划分为两个序列。然后依次递归求解

难点：处理序列划分时的边界问题

```c++

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if(preorder.empty()){
            return NULL;
        }
        TreeNode* root = buildTree_x(preorder,inorder,0,preorder.size()-1,0,inorder.size()-1);
        return root;
    }
    
    TreeNode* buildTree_x(vector<int>& preorder, vector<int>& inorder,int pstart,int pend,int istart,int iend){
        TreeNode * cur = new TreeNode(preorder[pstart]);
        if(pstart == pend){
            return cur;
        }
        int new_pstart1 = pstart + 1,new_pend1,new_pstart2,new_pend2 = pend;
        int new_istart1 = istart,new_iend1,new_istart2,new_iend2 = iend;
        
        auto iter = find(inorder.begin(),inorder.end(),preorder[pstart]);
        int len = iter-inorder.begin()-istart;
        
        new_pend1 = pstart + len;
        new_pstart2 = new_pend1+1;
        
        new_iend1 = new_istart1+len-1;
        new_istart2 = new_iend1+2;
        //左右子树构成的新序列的边界确定
        
        if(len>0){
            cur->left = buildTree_x(preorder,inorder,new_pstart1,new_pend1,new_istart1,new_iend1);
        }
        
        if(new_pend1 < pend){
            cur->right = buildTree_x(preorder,inorder,new_pstart2,new_pend2,new_istart2,new_iend2);
        }
        
        return cur;
    }
};
```


### LeetCode108

#### 根据递增序列构造二叉查找树（LeetCode108:Convert Sorted Array to Binary Search Tree）

给一个递增序列，根据该序列构造一棵二叉查找树

```c
Given the sorted array: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5

```


思路：递归不断寻找中点作为根节点，构造该树。

```c++

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        if(nums.empty())
            return nullptr;
        TreeNode * root = sortedArrayToBST_x(nums,0,nums.size()-1);
        return root;
    }
    
    TreeNode* sortedArrayToBST_x(vector<int>& nums,int start, int end) {
        int mid = (start+end)/2;
        TreeNode* cur = new TreeNode(nums[mid]);
        if(mid > start)
            cur->left = sortedArrayToBST_x(nums,start, mid-1);
        if(mid < end)
            cur->right = sortedArrayToBST_x(nums,mid+1, end);
        return cur;
    }
};
```


### LeetCode116 

#### 将树每一层用链表连接（LeetCode116:Populating Next Right Pointers in Each Node）

将树的每一层从左到右由链表连接，最后一个节点指向NULL

```
struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}

     1
   /  \
  2    3
 / \  / \
4  5  6  7

连接为：

    1 -> NULL
   /  \
  2 -> 3 -> NULL
 / \  / \
4->5->6->7 -> NULL


```


思路：层次遍历，记录最后一个节点last，然后每弹出一个节点，设置其NEXT指针。


```c++

/**
 * Definition for binary tree with next pointer.
 * struct TreeLinkNode {
 *  int val;
 *  TreeLinkNode *left, *right, *next;
 *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
 * };
 */
class Solution {
public:
    void connect(TreeLinkNode *root) {
        if(root == NULL){
            return ;
        }
        TreeLinkNode *last = root,*cur;
        queue<TreeLinkNode*> que;
        que.push(root);
        
        
        while(!que.empty()){
            cur  = que.front();
            
            if(cur == last){//打印到该层最后一个节点时
                que.pop();
                cur->next = NULL;
                if(cur->left != NULL)
                    que.push(cur->left);
                if(cur->right != NULL)
                    que.push(cur->right);
                last = que.back();
            }else{
                que.pop();
                cur->next = que.front();
                if(cur->left != NULL)
                    que.push(cur->left);
                if(cur->right != NULL)
                    que.push(cur->right);
            }
        }
        
        return ;
    }
};
```


### LeetCode124

#### 求树中最大路径和（LeetCode124：Binary Tree Maximum Path Sum）

给出一棵树结构，求出该树结构中，使得节点值总和最大的路径。返回该最大值总和，至少要有一个节点，不必经过根节点。

```

Input: [1,2,3]

       1
      / \
     2   3

Output: 6

Input: [-10,9,20,null,null,15,7]

   -10
   / \
  9 *20*
    /  \
  *15* *7*

Output: 42
```

思路：递归，用一个record记录节点的左右子树经过根节点的路径的最大总和。

1. 先求左子树的最大路径和，和到左子树根节点路径的最大路径和
2. 再求右子树的最大路径和，和到右子树根节点路径的最大路径和
3. 比较左子树和右子树的最大路径和，及左子树到根节点的最大路径＋右子树到根节点的最大路径＋当前节点值。去其最大值，作为当前节点为根节点的子树的最大路径和。

```c++

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int maxPathSum(TreeNode* root) {
        int* record = new int();
        int result = maxPathSum_x(root,record);
        delete record;
        return result;
    }
    
    int maxPathSum_x(TreeNode* cur,int* record){
        if(cur == NULL){
            *record = 0;
            return INT_MIN ;
        }
        
        int lMax = maxPathSum_x(cur->left,record);//左子树最大路径和
        int maxfromleft = *record;//到左根节点的最大路径和
        if(maxfromleft<0)
            maxfromleft = 0;
        int rMax = maxPathSum_x(cur->right,record);//右子树最大路径和
        int maxfromright = *record;//到右根节点的最大路径和
        if(maxfromright<0)
            maxfromright = 0;
        
        *record = max(maxfromleft,maxfromright)+cur->val;
        return max(max(lMax,rMax),maxfromleft+maxfromright+cur->val);//返回该树的最大路径和

    }
};
```

### LeetCode230
#### 求树中第k大的元素（LeetCode230：Kth Smallest Element in a BST）

给出一个二叉搜索树，求出该树中第k大的元素。

```
Input: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
Output: 1


Input: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
Output: 3
```

思路：中序遍历的过程中，遍历到第k个元素时，返回即可

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        stack<TreeNode *> sta;
        TreeNode * cur = root;
        while(true){//迭代进行中序遍历
            if(cur){
                sta.push(cur);
                cur = cur->left;
            }
            else{
                k--;
                if(k==0)//当遍历到第k个元素时返回
                    return sta.top()->val;
                cur = sta.top()->right;
                sta.pop();
            }
            
        }
        
        return 0;
    }
    
};
```



### LeetCode236
#### 求两个节点的第一个公共祖先（LeetCode236：Lowest Common Ancestor of a Binary Tree）

给出一棵树，及其树上的两个节点，求这两个节点的第一个公共祖先

```
        _______3______
       /              \
    ___5__          ___1__
   /      \        /      \
   6      _2       0       8
         /  \
         7   4

Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of of nodes 5 and 1 is 3.


Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself
             according to the LCA definition.
```


思路：

1. 采用一次后序遍历的方式（迭代遍历），记录从根节点到两个节点的路径
2. 从根节点开始比较两条路径，路径上最后一个相同的节点即为第一个公共祖先节点

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode * lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        vector<TreeNode*> path_p;
        vector<TreeNode*> path_q;
        bool pfound = false, qfound = false;

        TreeNode*cur = root;
        TreeNode*pre_popp = NULL,*pre_popq = NULL;
        //中序遍历
        while (!pfound || !qfound) {//一次后序遍历，直到两个节点都被找到
            if (cur) {
                if (cur->val == p->val){
                    path_p.push_back(cur);
                    pfound = true;//找到p节点，做相应标记
                }
                    
                if (cur->val == q->val){
                    path_q.push_back(cur);
                    qfound = true;//找到q节点，做相应标记
                }
                    
                if (!pfound)
                    path_p.push_back(cur);
                if (!qfound)
                    path_q.push_back(cur);
                cur = cur->left;//先向左遍历
            }
            else {
                if (!pfound) {
                    if (path_p.back()->right&&path_p.back()->right != pre_popp)//同下
                     {
                        cur = path_p.back()->right;
                    }
                    else {
                        pre_popp = path_p.back();
                        path_p.pop_back();
                    }
                }

                if (!qfound) {
                    if (path_q.back()->right&&path_q.back()->right!= pre_popq) //若当前节点为空，且前一个被弹出的节点不是该节点的右节点，则获取其右节点。相当于后序遍历的第二步
                    {
                        cur = path_q.back()->right;
                    }
                    else {
                        //到这里，要么是没有右节点，要么是从右子树遍历完后回到该节点，则继续回溯寻找，且弹出该节点，因为该节点不在路径上
                        pre_popq = path_q.back();
                        path_q.pop_back();
                    }
                }
            }
        }

        TreeNode *first_root = root;
        int size = path_p.size()<path_q.size()?path_p.size():path_q.size();
        for (int i = 1; i<size; i++) {
            //确定从根节点到两个节点的路径后，然后从根节点开始比较，找到最后一个相同的节点为第一个公共祖先节点
            if (path_q[i] != path_p[i]) {
                break;
            }
            first_root = path_q[i];
        }

        return first_root;

    }
};
```

### LeetCode297
#### 二叉树的序列化和反序列化（LeetCode297：Serialize and Deserialize Binary Tree）

思路：见剑指offer

我的实现：使用栈代替了递归

```c++
class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        string result = "[";
        TreeNode *cur = root;
        stack<TreeNode*> sta;
        if (root != NULL) {
            result = result + to_string(root->val);
            sta.push(root);
        }else{
            result = result + "]";
            return result;
        }
        cur = cur->left;
        while (true) {//利用栈进行递归处理
            if (cur) {
                result = result + ",";
                result = result + to_string(cur->val);
                sta.push(cur);
                cur = cur->left;
            }
            else {
                result = result + ",";
                result = result + "#";
                if (sta.empty()) {
                    break;
                }
                cur = sta.top()->right;
                sta.pop();
            }
        }

        result = result + "]";
        return result;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        if (data.empty()||data.size()==2) {
            return NULL;
        }
        int *len = new int();
        int start = 1;
        stack<TreeNode*> sta;
        string val = getval(data, start, len);
        TreeNode* root = new TreeNode(stoi(val));
        TreeNode** cur = &(root->left);
        sta.push(root);
        start += *len+1;
        val = getval(data, start, len);
        while (!val.empty()) {//利用栈进行递归处理
            if (val != "#") {
                *cur = new TreeNode(stoi(val));
                sta.push(*cur);
                cur = &((*cur)->left);
            }
            else {
                if (!sta.empty()) {
                    cur = &((sta.top())->right);
                    sta.pop();
                }
                else {
                    break;
                }
            }
            start += *len+1;
            val = getval(data, start, len);
        }

        return root;
    }
    string getval(string data, int index, int *len) {//获取下一个树节点的值
        string res;
        if (index == data.size() - 1) {
            return "";
        }
        int start = index;
        while ((data[index]>='0'&&data[index]<='9')|| data[index] == '-') {
            res = res + data[index];
            index++;
        }

        if (data[index] == '#') {
            res = res + data[index];
            index++;
        }

        *len = index - start;
        return res;
    }
};
```

[思路参考](https://github.com/guanjunjian/LeetCode/blob/master/Solution/297.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.md)

1. 需要使用到ostringstream和istringstream

* 直接使用字符串传递
* 转为二进制再转为字符串传递
    - 优势：
        + 当节点值都非常大时，可以更节省空间
        + 不需要字符串到整型的转换
    - 缺点：
        + 不同系统（32位或64位）的整型的大小不一致

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        ostringstream out;
        serialize(root,out);
        return out.str();
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        istringstream in(data);
        return deserialize(in);
    }
private:
    void serialize(TreeNode* root, ostringstream& out)
    {
        if(!root)
        {
            out << "# ";
            return;
        }
        out << root->val << " ";//不需要字符串到int的转换
        serialize(root->left, out);
        serialize(root->right, out);
    }
    TreeNode* deserialize(istringstream& in)
    {
        string val;
        in >> val;
        if(val=="#") return nullptr;
        TreeNode* root = new TreeNode(stoi(val));
        root->left = deserialize(in);
        root->right = deserialize(in);
        return root;
    }
};
```

### 树ending




## 图

### LeetCode127

#### 单词接龙（LeetCode127:Word Ladder）

[链接](https://leetcode-cn.com/problems/word-ladder/description/)

给定两个单词（*beginWord* 和 *endWord*）和一个字典，找到从 *beginWord* 到 *endWord* 的最短转换序列的长度。转换需遵循如下规则：

1. 每次转换只能改变一个字母。
2. 转换过程中的中间单词必须是字典中的单词。

**说明:**

- 如果不存在这样的转换序列，返回 0。
- 所有单词具有相同的长度。
- 所有单词只由小写字母组成。
- 字典中不存在重复的单词。
- 你可以假设 *beginWord* 和 *endWord* 是非空的，且二者不相同。

**示例 1:**

```
输入:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

输出: 5

解释: 一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog",
     返回它的长度 5。
```

**示例 2:**

```
输入:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]

输出: 0

解释: endWord "cog" 不在字典中，所以无法进行转换。
```

思路分析：将所有的单词放在一张图中，所以可以通过一个字母的变化进行转换的两个单词之间具有一条边。使用BFS广度优先遍历，来找到**最短变化路径**。

我的实现：

1. 使用队列进行广度优先遍历
2. 使用map记录节点遍历所在层
3. 逐个将变化过程中的当前单词和wordList中的所有单词进行比较，找出只有一个字母不同的所有单词集合（也就是下一层次的节点集合）
4. 直到找到搜索目标endWord,然后返回map记录的层次数即可

结果：超时

原因：第三步中寻找下一层次的单词集合过于耗时。

```
class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        
        map <string,int> visited;
        for(auto word:wordList)
            visited.insert(make_pair(word,0));
        
        if(!visited.count(endWord))
            return 0;
        queue<string> que;
        que.push(beginWord);
        
        if(count(wordList.begin(),wordList.end(),beginWord)){
            visited[beginWord] = 1;
        }else{
            visited.insert(make_pair(beginWord,1));
        }
        
        
        
        int word_len = beginWord.size();
        int diff = 0;
        bool found = false;
        int length = 1;
        string cur_word;
        
        while(!que.empty()){
            cur_word = que.front();//队列实现广度优先遍历
            que.pop();
            for(int i = 0;i<wordList.size();i++){//在list寻找所有邻边的下一层次的单词
                if(visited[wordList[i]] == 0){
                    diff = 0;
                    for(int j = 0;j < word_len;j++){
                        if(cur_word[j] != wordList[i][j])
                            diff++;
                        if(diff > 1)
                            break;
                    }
                    if(diff==1){//找到邻边单词，压入队列
                        if(wordList[i] == endWord){//找到搜索目标
                            found = true;
                            visited[wordList[i]] = visited[cur_word]+1;
                            break;
                        }
                        visited[wordList[i]] = visited[cur_word]+1;
                        que.push(wordList[i]);
                        wordList.erase(wordList.begin()+i);
                        i--;// 擦除当前元素后，调整下标
                    }
                    
                }
            }
            if(found)
                break;
        }
        
        return visited[endWord];//返回层次信息
        
    }
    
};
```

未超时实现：主要优化的是第三步的寻找下一层次节点集合

* 将变化过程中的当前单词逐个字母（a-z）变化，穷尽所有邻边节点的可能，然后在wordList中进行搜索所有可能节点是否存在。
* 并且将wordList的单词**存放到unordered_set红黑树**结构中加快搜索速度

```c++
class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        unordered_set<string> wordDict(wordList.begin(),wordList.end());//利用红黑树的特性提高搜索速度
        
        queue<string> que;
        que.push(beginWord);
        
        if(wordDict.find(endWord) == wordDict.end()){
            return 0;
        }
        int word_len = beginWord.size();
        int diff = 0;
        int length = 0;
        string cur_word;
        
        while(!que.empty()){
            length++;
            for(int k = que.size();k>0;k--){//按层遍历，每一层que.size()固定遍历
                cur_word = que.front();
                que.pop();
                for(int i = 0;i< word_len;i++){
                    char ch = cur_word[i];
                    for(int j = 'a';j <= 'z';j++){//穷尽所有邻边节点的可能单词
                        cur_word[i] = j;
                        if(wordDict.find(cur_word)!=wordDict.end()){//List存在该邻边单词
                            if(cur_word == endWord){
                                return length+1;
                            }
                            que.push(cur_word);
                            wordDict.erase(cur_word);
                        }
                   }
                    cur_word[i] = ch;
                }
                
            }
        }
        
        return 0;
        
    }
    
};
```


### LeetCode130

#### 被围绕的区域（LeetCode130:Surrounded Regions）

给出一个二维数组，其中的元素要么为'X'要么为'O',将其中被'X'包围的所有'O'替换成'X'。其实就是找出边界上的'O',除了边界上的'O'和与其区域进行连通的'O'不被替换为'X'，其余都被替换成'X'。

```
X X X X
X O O X
X X O X
X O X X

输出结果：

X X X X
X X X X
X X X X
X O X X
```

思路：

1. 找出四条边界中所有的'O'
2. 根据找出的'O'进行DFS深度优先遍历，找到所有与其连通的'O'
3. 将这些'O'替换成'#'
4. 最后遍历该二维数组，'O'替换为'X'，'#'替换为'O'

代码实现(可以使用递归，也可以使用栈)：

其实深度优先遍历就是一种回溯法，可以直接用递归实现。

这里我们使用栈进行实现
```c++

class Solution {
public:
    void solve(vector<vector<char>>& board) {
        stack<pair<int,int>> index_stack;
        if(board.empty())
            return;
        int raw_end = board[0].size()-1;
        int col_end = board.size()-1;
        
        if(raw_end<2||col_end<2)
            return;//边界问题的考虑
        
        //初始化visit二维数组，记录被访问信息
        int ** visit = new int*[col_end+1];
        for(int i = 0;i< col_end+1;i++){
            visit[i] = new int[raw_end+1];
        }
        
        for(int i = 0; i< col_end+1;i++){
            for (int j = 0;j < raw_end+1;j++){
                visit[i][j]  = 0;
            }
        }
        
        for(int j = 0;j<raw_end+1;j++){
            if(board[0][j] == 'O')
                index_stack.push(make_pair(0,j));
            if(board[col_end][j] == 'O')
                index_stack.push(make_pair(col_end,j));
        }
        
        for(int i = 1;i<col_end;i++){
            if(board[i][0] == 'O')
                index_stack.push(make_pair(i,0));
            if(board[i][raw_end] == 'O')
                index_stack.push(make_pair(i,raw_end));
        }
        
        //开始深度优先遍历
        
        while(!index_stack.empty()){
            auto curpair = index_stack.top();
            index_stack.pop();
            board[curpair.first][curpair.second] = '#';
            if(!visit[curpair.first][curpair.second]){
                visit[curpair.first][curpair.second] = 1;//设置为已访问
                //向下
                if(curpair.first<col_end && !visit[curpair.first+1][curpair.second] && board[curpair.first+1][curpair.second]=='O'){
                    index_stack.push(make_pair(curpair.first+1,curpair.second));
                }
                //向上
                if(curpair.first>0 && !visit[curpair.first-1][curpair.second] && board[curpair.first-1][curpair.second]=='O'){
                    index_stack.push(make_pair(curpair.first-1,curpair.second));
                }
                
                //向右
                if(curpair.second>0 && !visit[curpair.first][curpair.second-1] && board[curpair.first][curpair.second-1]=='O'){
                    index_stack.push(make_pair(curpair.first,curpair.second-1));
                }
                
                //向左
                if(curpair.second<raw_end && !visit[curpair.first][curpair.second+1] && board[curpair.first][curpair.second+1]=='O'){
                    index_stack.push(make_pair(curpair.first,curpair.second+1));
                }
            }
            
        }
        
        //最后进行替换
        for(int i =0;i<=col_end;i++){
            for(int j = 0;j<=raw_end;j++){
                if(board[i][j] == 'O'){
                    board[i][j] = 'X';
                }else if(board[i][j] == '#'){
                    board[i][j] = 'O';
                }
            }
        }
        
        return;
    }
};
```


## 链表

### LeetCode138

#### 复制带有随机指针的链表（LeetCode138:Copy List with Random Pointer）

给出一个链表，每个节点带有一个随机指针，指向链表中的任意一个节点，复制该链表

思路：

1. 在原链表在每个节点后复制一份。
2. 设置每个节点的随机指针
3. 分开新旧链表

PS：注意只有单个节点及其随机指针的情况

```c++
class Solution {
public:
    RandomListNode *copyRandomList(RandomListNode *head) {
        if(!head) return nullptr;
        RandomListNode* old = head;
        //1.在每个旧节点后复制一个节点
        while(old)
        {
            RandomListNode* tn = new RandomListNode(old->label);
            tn->next = old->next;
            old->next = tn;
            old = tn->next;
        }
        //2.设置每个复制节点的random值
        old = head;
        while(old)
        {
            if(old->random)
                old->next->random = old->random->next;
            old = old->next->next;
        }
        //3.将新旧链表拆开
        old = head;
        RandomListNode* copy = nullptr;
        RandomListNode* curCopy = nullptr;
        while(old)
        {
            if(old == head)
            {
                copy = old->next;
                curCopy = copy;
                old->next = curCopy->next;
            }else
            {
                curCopy->next = old->next;
                old->next = curCopy->next->next;
                curCopy = curCopy->next;
            }
            old = old->next;
        }
        return copy;
    }
};
```

### LeetCode148

#### 链表排序（LeetCode148:Sort List）

给一个链表，将其排序，要求时间复杂度为O(NlogN),空间复杂度为0

我的思路：使用插入排序，时间复杂度超过要求O(N^2)

正确思路：归并排序

分治，将大链表拆分成2个长度相等的小链表，递归处理，每次递归返回后，两个小链表已经有序，然后将2个小链表进行归并

每次将链表分成2个长度相等的链表时，需要找到中间节点，可以使用1个快指针和1个慢指针

如果考虑递归调用的函数栈帧，那么空间复杂度为O(n)，不考虑则空间复杂度为O(1)

递归是“从上往下”的思想，也可以“从下往上”，避免函数栈帧的开销

“从下往上”的代码：

```c++
/**
 * Merge sort use bottom-up policy, 
 * so Space Complexity is O(1)
 * Time Complexity is O(NlgN)
 * stable sort
*/
class Solution {
public:
    ListNode *sortList(ListNode *head) {
        if(!head || !(head->next)) return head;
        
        //get the linked list's length
        ListNode* cur = head;
        int length = 0;
        while(cur){
            length++;//计算长度
            cur = cur->next;
        }
        
        ListNode dummy(0);
        dummy.next = head;
        ListNode *left, *right, *tail;
        for(int step = 1; step < length; step <<= 1){//步数逐渐增大1->2->4,从小到大增加
            cur = dummy.next;
            tail = &dummy;
            while(cur){
                left = cur;
                right = split(left, step);//根据step进行链表划分
                cur = split(right,step);
                tail = merge(left, right, tail);
            }
        }
        return dummy.next;
    }
private:
    /**
     * Divide the linked list into two lists,
     * while the first list contains first n ndoes
     * return the second list's head
     */
    ListNode* split(ListNode *head, int n){
        //if(!head) return NULL;
        for(int i = 1; head && i < n; i++) head = head->next;
        
        if(!head) return NULL;
        ListNode *second = head->next;
        head->next = NULL;
        return second;
    }
    /**
      * merge the two sorted linked list l1 and l2,
      * then append the merged sorted linked list to the node head
      * return the tail of the merged sorted linked list
     */
    ListNode* merge(ListNode* l1, ListNode* l2, ListNode* head){//合并两个排序链表
        ListNode *cur = head;
        while(l1 && l2){
            if(l1->val > l2->val){
                cur->next = l2;
                cur = l2;
                l2 = l2->next;
            }
            else{
                cur->next = l1;
                cur = l1;
                l1 = l1->next;
            }
        }
        cur->next = (l1 ? l1 : l2);
        while(cur->next) cur = cur->next;
        return cur;
    }
};

```


### LeetCode234
#### 回文链表（LeetCode234：Palindrome Linked List）

给出一个链表，判断该链表是否为回文链表，要求时间复杂度为O(N),空间复杂度为O（1）

思路：

1. 先用快慢指针找到中间节点
2. 再讲后半部分进行反转
3. 最后进行前半部分和后半部分进行比较

由于我的代码比较笨重，这里使用一份参考代码：

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
 class Solution {
 public:
     bool isPalindrome(ListNode* head) {
         if (!head || !head->next) return true;
         ListNode* fast = head;
         ListNode* slow = head;
         //找到中间节点
         while (fast->next && fast->next->next)//判断是否可以前进
         {
             fast = fast->next->next;
             slow = slow->next;
         }
         ListNode* reverse = slow->next;
         slow->next = nullptr;
         ListNode* before = nullptr;
         //将后半部分反转
         while (reverse)
         {
             ListNode* next = reverse->next;
             reverse->next = before;
             before = reverse;
             reverse = next;
         }
         //从左右两边向中间靠拢，翻转后的尾节点为null
         bool isOK = true;
         while (before)
         {
             if (head->val != before->val)
             {
                 isOK = false;
                 break;
             }
             head = head->next;
             before = before->next;
         }
         return isOK;
     }
 };
```
### LeetCode237

#### 删除链表给定节点（LeetCode237：Delete Node in a Linked List）

给出一个链表中节点，删除该链表中的该节点，该节点不会是该链表的最后一个节点。

```
Input: head = [4,5,1,9], node = 5
Output: [4,1,9]
Explanation: You are given the second node with value 5, the linked list
             should become 4 -> 1 -> 9 after calling your function.
```

思路：将该节点的后面所有节点的值向前移动一个节点，再将倒数第二个节点的next指向空

代码实现：

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        while(node->next->next!=NULL){
            node->val = node->next->val;
            node = node->next;
        }
        
        node->val = node->next->val;
        node->next = NULL;
    }
};
```

### LeetCode328
#### 奇偶链表（LeetCode328:Odd Even Linked List）

给定一个链表，将所有奇数位置的链表放到链表前面，偶数位置的链表放在链表后端，且不打乱之前奇数位置节点顺序以及偶数位置上的节点顺序

```
Input: 1->2->3->4->5->NULL
Output: 1->3->5->2->4->NULL

Input: 2->1->3->5->6->4->7->NULL
Output: 2->3->6->7->1->5->4->NULL
```

思路：遍历一遍，直接拆开为两个链表即可

代码实现：

```c++
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        if(head == NULL)
            return NULL;
        ListNode* oddhead = head,*oddtail = head;//奇数链表头，尾
        ListNode* evenhead,*eventail;//偶数链表头，尾
        if(head->next){
             evenhead = head->next;
             eventail = head->next;
        }  
        else
            return head;
        
        ListNode* cur = eventail->next;
        
        while(cur){//开始遍历
            oddtail->next = cur;
            oddtail = cur;
            if(cur->next){
                eventail->next = cur->next;
                eventail = cur->next;
            }else{
                eventail->next = NULL;
                break;
            }
            cur = cur->next->next;
        }      
        oddtail->next = evenhead;
        return oddhead;
        
    }
};
```




### 链表ending


## 数据结构


### LeetCode150

#### 求得逆波兰表达式的值（LeetCode150:Evaluate Reverse Polish Notation）

逆波兰表达式：后缀表达式。在通常的表达式中，二元运算符总是置于与之相关的两个运算对象之间，这种表示法也称为中缀表示。所以逆波兰表达式的二元运算符位于与之相关的两个运算对象之后

```
Input: ["2", "1", "+", "3", "*"]
Output: 9
Explanation: ((2 + 1) * 3) = 9

Input: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]
Output: 22
Explanation: 
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
```

思路：使用栈结构即可

```c++

class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> nums;
        for(int i = 0;i< tokens.size();i++){
            
            int tmp;
            if(tokens[i] == "+"){
                tmp = nums.top();
                nums.pop();
                tmp += nums.top();
                nums.pop();
            }else if(tokens[i] == "-"){
                tmp = nums.top();
                nums.pop();
                tmp = nums.top()-tmp;
                nums.pop();
            }else if(tokens[i] == "*"){
                tmp = nums.top();
                nums.pop();
                tmp *= nums.top();
                nums.pop();
            }else if(tokens[i] == "/"){
                tmp = nums.top();
                nums.pop();
                tmp = nums.top()/tmp;
                nums.pop();
            }else{
                tmp = stoi(tokens[i],nullptr,10);
            }
            
            nums.push(tmp);
        }
        
        return nums.top();
    }
};
```

### LeetCode239

#### 滑动窗口最大值（LeetCode239: Sliding Window Maximum）

给出一个数组和一个窗口大小，该窗口在数组结构滑动过程中的所有最大值

```
Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3
Output: [3,3,5,5,6,7] 
Explanation: 

Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

思路：双端队列 ，见剑指offer：[面试题59:队列的最大值](http://blog.xbblfz.site/2018/04/09/%E5%89%91%E6%8C%87offer%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/#面试题59队列的最大值)

代码实现：

```c++

class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<pair<int,int>> record;
        vector<int> max_vec;
        if(nums.empty())
            return max_vec;
        record.push_back(pair<int,int>(0,nums[0]));
        if(k == 1){//因为从i=1开始，所以要考虑k==1的情况
            max_vec.push_back(nums[0]);
        }
        for(int i = 1; i< nums.size();i++){
            if(record.back().second>=nums[i]){
                record.push_back(pair<int,int>(i,nums[i]));//当队尾元素大于当前元素，直接压入
            }else{
                while(!record.empty()&&record.back().second<nums[i]){//弹出队尾所有小于当前元素的值
                    record.pop_back();
                }
                record.push_back(pair<int,int>(i,nums[i]));
            }
            
            if(i>=k-1){//当滑到第k个元素时，开始记录最大值
                if(record.front().first<i-k+1){
                    record.pop_front();
                }
                max_vec.push_back(record.front().second);        
            }  
        }
        
        return max_vec;
    }
};
```

### LeetCode295

#### 数据流中的中位数（LeetCode295：Find Median from Data Stream）

实现一个类，可以添加数据，可以获取所有添加数据中的中位数

```
addNum(1)
addNum(2)
findMedian() -> 1.5
addNum(3) 
findMedian() -> 2
```

思路：见剑指offer[面试题41:数据流中的中位数](http://blog.xbblfz.site/2018/04/09/%E5%89%91%E6%8C%87offer%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/面试题41数据流中的中位数)

1. 用数组vector实现
2. 用链表实现
3. 用二叉搜索树实现
4. 用堆来实现，大小堆

我的实现（链表）

```c++
struct ListNode_x{
    public:
        ListNode_x *prev;
        ListNode_x *next;
        double val;
        ListNode_x(int value):val(value),prev(NULL),next(NULL){}
};

class MedianFinder {
public:
    /** initialize your data structure here. */
    MedianFinder() {
        head = new ListNode_x(NULL);
        mid = head;
        count = 0;
    }
    
    void addNum(int num) {
        ListNode_x *cur = head;
        while(cur->next!=NULL&&cur->next->val<=num) cur = cur->next;
        if(cur->next!=NULL){
            ListNode_x *nextptr = cur->next;
            cur->next = new ListNode_x(num);
            cur->next->prev = cur;
            cur->next->next = nextptr;
            nextptr->prev = cur->next;
        }else{
            cur->next = new ListNode_x(num);
            cur->next->prev = cur;
        }
        
        if(mid == head){
            mid = mid->next;
        }else{
            if(count&1){
                if(mid->val>num)
                    mid = mid->prev;
            }else{
                if(mid->val<=num)
                    mid = mid->next;
            }
        }
        count++;
    }
    
    double findMedian() {
        if(mid!=head)
            if(count&1)
                return mid->val;
            else
                return (mid->val+mid->next->val)/2;
        else
            return NULL;
    }
    ListNode_x *head;
    ListNode_x *mid;
    int count;
    
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder obj = new MedianFinder();
 * obj.addNum(num);
 * double param_2 = obj.findMedian();
 */
```

实现2：用堆来实现

```c++
class MedianFinder {
public:
    /** initialize your data structure here. */
    MedianFinder() : count(0){}
    
    void addNum(int num) {
        ++count;
        int temp = num;
        if(count%2==1) //奇数个
        {
            if(!rightHeap.empty() && num>rightHeap.top())
            {
                temp = rightHeap.top();
                rightHeap.pop();
                rightHeap.push(num);
            }
            leftHeap.push(temp);
        }
        else //偶数个
        {
            if(!leftHeap.empty() && num<leftHeap.top())
            {
                temp = leftHeap.top();
                leftHeap.pop();
                leftHeap.push(num);
            }
            rightHeap.push(temp);
        }
    }
    
    double findMedian() {
        if(leftHeap.size()==rightHeap.size())
            return (leftHeap.top()+rightHeap.top()) / 2.0;
        else
            return leftHeap.top();
    }
private:
    //最大堆
    priority_queue<int, vector<int>, less<int>> leftHeap;
    //最小堆
    priority_queue<int, vector<int>, greater<int>> rightHeap;
    int count;
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder obj = new MedianFinder();
 * obj.addNum(num);
 * double param_2 = obj.findMedian();
 */
```

### LeetCode347
#### 前K个高频元素（LeetCode347:Top K Frequent Elements）

给定一个元素，其中有部分元素出现重复，根据每个元素重复出现的次数，来获取前K个重复出现次数最多的元素。

```
Given [1,1,1,2,2,3] and k = 2, return [1,2].
```

要求时间复杂度为： O(n log n)

思路实现：

1. 先用红黑树结构map统计每个元素重复出现的次数
2. 再用multimap结构并以重复出现的次数为key值来对之前统计的map结构中的元素进行排序


```c++
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        map<int,int> fre_map;
        for(int i = 0;i<nums.size();i++){//将所有元素统计重复出现的次数
            if(fre_map.find(nums[i]) == fre_map.end()){
                fre_map.insert(pair<int,int>(nums[i],1));
            }else{
                fre_map[nums[i]]++;
            }
        }
        
        multimap<int,int> topkmap;
        
        for(auto p:fre_map){
            topkmap.insert(pair<int,int>(p.second,p.first));//以重复出现的次数为key值，来讲所有统计的元素插入到multimap中进行排序
        }
        vector<int> res;
        auto pairtmp = --topkmap.end();
        while(k){
            res.push_back(pairtmp->second);//排序后，倒序输出前k个高频元素
            k--;
            pairtmp--;
        }
        
        return res;
    }
};
```

### 数据结构ending


## 其它

### LeetCode11

#### 装水最多的容器(LeetCode11:Container with most water)




描述：给定一个整型数组｛a1,a2,a3...an｝;这些点代表在坐标轴上的n个点，（i，ai）。根据这些点画出垂直于x轴的直线，这些直线中任取两条直线构成一个容器，求两条直线使得构成的容器可以装水的体积最大。

![container_water](/img/container_water.png)

如图灰色部分就是两条加粗的线构成容器的所装水的容量。

思路：两点法，从两端开始front =1 ,back = end,构成容器的大小为size,只要比较这两条直线的长度，在front和back的范围里想要**找到另一条线**和这两条线其中一条构成的容器大于size,则只能和**较长的一端**进行组合，所以我们将**较短的一端向中间移动**找到一条比它长的直线作为容器的一端，然后计算容器大小，如此循环移动直到front和back重合,在这个过程中**记录容器容量的最大值**。

[解法链接](https://leetcode.com/problems/container-with-most-water/solution/)

代码参考：

{% highlight c++%}

class Solution {
public:
    int maxArea(vector<int>& height) {
        if(height.empty()||height.size()==1){
            return 0;
        }
        int front = 0,back = height.size()-1;
        int max_size = (height[back]>height[front]?height[front]:height[back])*(back-front);
        //移动直到两端重合
        while(front<back){
            int front_tmp = front;
            int back_tmp = back;
            int h = 0;
            //向中间移动较短的一端
            if(height[front]>=height[back]){
            //将尾端向前移动
                while(height[back_tmp] >= height[back] && back>front)
                    back--;
                if(height[back_tmp]<height[back]){
                //计算容器大小，记录最大容器容量
                    h = height[back]>height[front]?height[front]:height[back];
                    max_size = h*(back-front)>max_size?h*(back-front):max_size;
                }
                    
            }else{
            //将首段向后移动
                while(height[front_tmp] >= height[front] && back>front)
                    front++;
                if(height[front_tmp] < height[front]){
                    h = height[back]>height[front]?height[front]:height[back];
                    max_size = h*(back-front)>max_size?h*(back-front):max_size;
                }
            }
            
        }
        
        return max_size;
        
    }
};
{% endhighlight %}


### LeetCode42

#### 计算容器可以装多少水(LeetCode42:Trapping Rain Water)

描述：给出一个整形数数组，每个数代表一个柱子，柱子的宽度为1，两根柱子之间可以装水，问该数组中的所有数字构成的所有柱子能装多少水？

![rainwatertrap](/img/rainwatertrap.png)

如上图，给出数组[0,1,0,2,1,0,1,3,2,1,2,1],输出：6（装水的容量）

我的解法：笨拙复杂，使用两个栈，一个栈记录高度，一个栈记录该减去的水的容量，其实和标准的使用栈解法的思路类似，只不过思路过于复杂。

* 我的思路和标准解法的思路都是求两根柱子，超出其他矮柱子的高度的部分装的水的容量，这部分的水就只和这两根柱子相关，和其他的柱子没有关系，所以就不会导致重复计算。
    - 但我的思路是先求两根柱子所能装的水的最大容量，然后减去两根柱子中间被其他柱子所影响的容量，这就比较复杂
    - 标准解法的思路就比较直接，直接求超出的高度，计算只与这两根柱子相关的水容量

{% highlight c++ %}
class Solution{
    public:
    int trap(vector<int>& height) {
        if(height.empty()||height.size()==1){
            return 0;
        }
        
        stack<pair<int, int>> height_stack;
        stack<int>  minus_stack;
        int water_tmp = 0,water_sum = 0,water_max = 0;
        int minus_tmp = 0;
        
        for(int i = 0;i< height.size();i++){
            if(height[i]!=0){
                if(height_stack.empty()){
                
                    height_stack.push(make_pair(height[i], i));
                    minus_stack.push(0);
                }else{
                    while(!height_stack.empty()){
                        pair<int, int> pair_tmp = height_stack.top();
                        if(pair_tmp.first > height[i]){
                            minus_tmp = minus_stack.top();
                            water_tmp = height[i]*(i-pair_tmp.second-1)-minus_tmp;
                            water_sum += water_tmp;
                            minus_tmp +=water_tmp;
                            minus_stack.pop();
                            minus_stack.push(minus_tmp);
                            break;
                        }
                        minus_tmp = minus_stack.top();
                        water_tmp = pair_tmp.first*(i-pair_tmp.second-1)-minus_tmp;//只与目前的两根柱子相关的水容量
                        water_max = water_tmp + minus_tmp;
                        water_sum += water_tmp;
                        height_stack.pop();
                        minus_stack.pop();
                        if(!height_stack.empty()){
                            minus_tmp = minus_stack.top();
                            minus_stack.pop();
                            minus_tmp = minus_tmp + water_max + pair_tmp.first;
                            minus_stack.push(minus_tmp);
                        }
                    }
                    height_stack.push(make_pair(height[i], i));
                    minus_stack.push(0);
                }
            }
        }
        
        return water_sum;
    }
};


{% endhighlight %}

* 思路1: 标准的栈解法：

{% highlight c++ %}

int trap(vector<int>& height)
{
    int ans = 0, current = 0;
    stack<int> st;
    while (current < height.size()) {
        while (!st.empty() && height[current] > height[st.top()]) {
            int top = st.top();
            st.pop();//当压入一个数时，会把所有小于该数的数全部弹出栈
            if (st.empty())
                break;
            int distance = current - st.top() - 1;
            int bounded_height = min(height[current], height[st.top()]) - height[top];//求超出的高度部分，必须有三个数参数，两个相邻的数是无法装水的
            ans += distance * bounded_height;//直接计算超出的高度部分所装的水容量
        }
        st.push(current++);
    }
    return ans;
}

{% endhighlight %}

* 思路2: 计算每一根柱子的顶部空间有多少会被淹没在水里，这样计算每根柱子顶部被淹没在顶部的空间，然后累加起来就是整个水的容量。

    - 解法1:暴力计算，为每根柱子计算左右两边的最高的高度，然后用左右最高高度中的较小者减去该柱子的高度，就是该柱子顶部被淹没的空间
    - 解法2:动态规划，先记录每根柱子的左右最高高度到两个vector中，这样可以避免重复计算。

{% highlight c++ %}
//解法1:
int trap(vector<int>& height)
{
    int ans = 0;
    int size = height.size();
    for (int i = 1; i < size - 1; i++) {
        int max_left = 0, max_right = 0;
        for (int j = i; j >= 0; j--) { //Search the left part for max bar size
            max_left = max(max_left, height[j]);
        }//计算左边的最高高度
        for (int j = i; j < size; j++) { //Search the right part for max bar size
            max_right = max(max_right, height[j]);
        }//计算右边的最高高度
        ans += min(max_left, max_right) - height[i];//累加每根柱子顶部别淹没的空间
    }
    return ans;
}

//解法2:

int trap(vector<int>& height)
{
    if(height == null)
        return 0;
    int ans = 0;
    int size = height.size();
    vector<int> left_max(size), right_max(size);
    left_max[0] = height[0];
    for (int i = 1; i < size; i++) {
        left_max[i] = max(height[i], left_max[i - 1]);
    }//记录每根柱子左边的最高高度到left_max
    right_max[size - 1] = height[size - 1];
    for (int i = size - 2; i >= 0; i--) {
        right_max[i] = max(height[i], right_max[i + 1]);
    }//记录每根柱子右边的最高高度到right_max
    for (int i = 1; i < size - 1; i++) {
        ans += min(left_max[i], right_max[i]) - height[i];//累加每根柱子顶部被淹没的部分
    }
    return ans;
}
{% endhighlight %}

思路三：两点法，从两端找到左边最大的和右边最大的，然后两端向中间移动，遇到短的就可以计算水的容量。https://leetcode.com/problems/trapping-rain-water/solution/

{% highlight c++ %}
int trap(vector<int>& height)
{
    int left = 0, right = height.size() - 1;
    int ans = 0;
    int left_max = 0, right_max = 0;
    while (left < right) {
        if (height[left] < height[right]) {
            height[left] >= left_max ? (left_max = height[left]) : ans += (left_max - height[left]);
            ++left;
        }
        else {
            height[right] >= right_max ? (right_max = height[right]) : ans += (right_max - height[right]);
            --right;
        }
    }
    return ans;
}

{% endhighlight %}

### LeetCode13

#### 罗马数转化为整数（LeetCode13:Roman to Integer）

```
Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```
如上所示，罗马表示数字的字符一一对应，数字规则如下：

* 规则1:较小字符可以放在较大字符前面构成一个数：如IX(10-1 = 9),XLC(100-50-10 = 40)
* 规则2:将一串罗马字符串根据规则1得到若干数字然后进行相加如：“MCMXCIV”,得到数字： M=1000,CM=900,XC=90,IV=4。最后相加结果为：1000+900+90+4 ＝ 1994

思路1：从正面将所有数字分开，然后再一个个相加

{% highlight c++%}
class Solution {
public:
    int romanToInt(string s) {
        if(s.empty())
            return 0;
        int result = 0;
        map<char,int> roman;
        roman['I'] = 1;
        roman['V'] = 5;
        roman['X'] = 10;
        roman['L'] = 50;
        roman['C'] = 100;
        roman['D'] = 500;
        roman['M'] = 1000;
        
        int num = roman[s[0]];
        int size = s.size();
        for(int i = 1;i<size;i++){
            //分割字符串得到数字
            while(i < size && roman[s[i]] >= roman[s[i-1]]){
                if(roman[s[i]] == roman[s[i-1]]){
                    num += roman[s[i]];
                }else{
                    num = roman[s[i]] - num;
                }
                i++;
            }
            //将得到的数字相加
            result+=num;
            num = 0;
            
            if(i<size){
                num = roman[s[i]];
            }
        }
        if(num != 0)
            result+=num;
        return result;
    }
};
{% endhighlight %}

思路2:从反方向来进行遍历，因为字符串构成数字的方向也是从后到前构成的：只有当后面的字符大于前面时才能构成一个数字。
{% highlight c++%}
int romanToInt(string s) 
{
    unordered_map<char, int> T = { { 'I' , 1 },
                                   { 'V' , 5 },
                                   { 'X' , 10 },
                                   { 'L' , 50 },
                                   { 'C' , 100 },
                                   { 'D' , 500 },
                                   { 'M' , 1000 } };
                                   
   int sum = T[s.back()];
   //从后向前遍历即可
   for (int i = s.length() - 2; i >= 0; --i) 
   {
       if (T[s[i]] < T[s[i + 1]])
       {
           sum -= T[s[i]];
       }
       else
       {
           sum += T[s[i]];
       }
   }
   
   return sum;
}
{% endhighlight %}

### LeetCode15

#### 三个数相加为0(LeetCode15:3Sum)

给定一个数组，从中找到所有可能的三元组，使得这三个加起来的总和为0。

思路1（暴力求解）:首先将数组进行排序，然后**三次循环**遍历确定找到使和为0的三元组。
    - 优化：最后一次循环可以用**关联容器**来确定，将所有的数据放到一个关联容器multiset,在前两次循环后，三元组中的第三个数也就可以确定下来，我们可以直接判断该数是否在multiset存在

**代码见LeetCode15.3Sum**


思路2（O(N^2)）:同样需要先将数组进行排序，然后确定三元组中的**第一个元素**（一次循环），然后我们可以知道后两个元素的和，然后利用**两点法（见剑指offer面试题57:和为s的数字）**,来确定后两个元素的值。

代码（Java）:
{% highlight java%}
public List<List<Integer>> threeSum(int[] num) {
    Arrays.sort(num);
    List<List<Integer>> res = new LinkedList<>(); 
    for (int i = 0; i < num.length-2; i++) {
        if (i == 0 || (i > 0 && num[i] != num[i-1])) {
            int lo = i+1, hi = num.length-1, sum = 0 - num[i];
            while (lo < hi) {
                if (num[lo] + num[hi] == sum) {
                    res.add(Arrays.asList(num[i], num[lo], num[hi]));
                    while (lo < hi && num[lo] == num[lo+1]) lo++;
                    while (lo < hi && num[hi] == num[hi-1]) hi--;
                    lo++; hi--;
                } else if (num[lo] + num[hi] < sum) lo++;
                else hi--;
           }
        }
    }
    return res;
}
{% endhighlight %}

### LeetCode22

#### 产生所有可能的有效括号组合（LeetCode22:Generate Parentheses）

题目描述：给定一个数字n，给出n个括号所有有效的组合方式。如给定3，则输出结果是：

```
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```

回溯法：见剑指offer中机器人的运动范围，这个题目也可以用一样的思路来考虑:

![tracing_back.png](/img/tracing_back.png)

和机器人走格子类似，横坐标是'('的已使用个数，纵坐标是')'的已使用个数，机器人走到的每一个格子都必须满足横坐标x>=纵坐标y。求有多少条路径满足从start走到end格子。

回溯法和递归的区别：

* 回溯不断调用自身，调用到最后即得到问题的答案。(将问题不断深入，穷尽每一种可能)
* 递归则是不断调用自身，直到最小问题得到解决后，在通过**不断返回**解决大问题，返回到第一次调用的函数才得到答案。（将问题不断分解，解决最小问题，再逐个解决大问题，最后得到整个问题的答案。）

本题代码：
{% highlight c++ %}

class Solution {
public:
    vector<string> generateParenthesis(int n) {
        string str = "(";
        vector<string> result;
        generateParenthesis_x(result,n-1,n,str);
        return result;
        
    }
    
    void generateParenthesis_x(vector<string> & vec,int s_count,int e_count,string &str){
        if(s_count<e_count&&s_count>0){//两个方向
            string tmp1 = str;
            tmp1.push_back('(');
            generateParenthesis_x(vec,s_count-1,e_count,tmp1);
            string tmp2 = str;
            tmp2.push_back(')');
            generateParenthesis_x(vec,s_count,e_count-1,tmp2);
            return;
        }else if(s_count<e_count&&s_count==0){//一个方向
            string tmp3 = str;
            tmp3.push_back(')');
            generateParenthesis_x(vec,s_count,e_count-1,tmp3);
        }else if(s_count==e_count&&s_count>0){//一个方向
            string tmp4 = str;
            tmp4.push_back('(');
            generateParenthesis_x(vec,s_count-1,e_count,tmp4);
        }else{
            vec.push_back(str);//走到end
        }
        
    }
};

{% endhighlight %}

### LeetCode23

#### 合并k个排序链表（LeetCode23: Merge k Sorted Lists）

将k个排序链表合并成一个排序链表：

```
Input:
[
  1->4->5,
  1->3->4,
  2->6
]
Output: 1->1->2->3->4->4->5->6
```
解决方法：https://leetcode.com/problems/merge-k-sorted-lists/solution/

思路1：用优先级队列，或红黑树实现的multimap结构保存每条链表的第一个元素，然后从这些元素中获取最小值（基于multimap或优先级队列很容易实现）插入新的链表。

PS:注意当创建来的链表为空时的处理

代码：

{% highlight c++ %}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        multimap<int,ListNode*> first_map;
        ListNode* new_list = NULL;
        ListNode* cur= NULL;
        ListNode* cur_ptr = NULL;
        for(int i=0;i<lists.size();i++){
            if(lists[i]!=NULL)
                first_map.insert(make_pair(lists[i]->val,lists[i]));
        }
        //初始化链表头
        if(!first_map.empty()){
            auto iter0 = first_map.begin();
            new_list = cur = new ListNode(iter0->first);
            cur_ptr = iter0->second;
            first_map.erase(iter0);
            if(cur_ptr->next!=NULL){
                first_map.insert(make_pair(cur_ptr->next->val,cur_ptr->next));
        }
        //每获取一个最小值，需要将对应链表下一个最小值添加到map中来
        while(!first_map.empty()){
            auto iter = first_map.begin();
            ListNode *tmp = new ListNode(iter->first);
            cur->next = tmp;
            cur = tmp;
            cur_ptr = iter->second;
            first_map.erase(iter);
            if(cur_ptr->next!=NULL){
                first_map.insert(make_pair(cur_ptr->next->val,cur_ptr->next));
            }
            
        }
        }
        
        return new_list;
    }
};
{% endhighlight %}

思路2:暴力求解，逐个将两条链表合并成一条，直到所有链表都被合并

思路3:归并法，将所有链表分为两两一组，然后合并之后，继续分组合并。。直到最后合并成一条链表

### LeetCode55

#### 跳跃游戏（LeetCode55: Jump Game）

给一个非负数组，每个元素中的数值代表可以向前跳跃的最大步数，从第一个元素开始起跳，在每个元素的跳跃步数的限制下问能否跳到最后一格。

```
Input: [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
```

思路1：关注为0的元素，因为只要不能到达，肯定是有一个**跳跃步数为0的元素**限制了向前跳跃的步伐。所以我们遍历该数组，并记录遍历到当前元素可以到达的**最远距离**，只要遇到0时，判断当前可以到达的距离**是否可以越过该0节点**。不能越过则说明无法到达终点。

需要注意的特殊情况：0点出现在数组的**最后一个元素**上。

思路2:动态规划，可以实现但较复杂

思路1的代码实现：
```
class Solution {
public:
    bool canJump(vector<int>& nums) {
        if(nums.empty()||nums.size() == 1){
            return true;
        }
        bool success = true;//最远距离
        int max_reach = 0,cur_reach = 0;
        int len = nums.size();
        for(int i = 0;i<len;i++){
            if(nums[i]==0 && max_reach<=i && i!=len-1){//遇到0时，判断是否可以越过，并判断是否为最后一个元素
                success = false;
                break;
            }
            cur_reach = i+nums[i];
            if(cur_reach > max_reach)
                max_reach = cur_reach;//更新可以到达的最远距离
        }
        
        return success;
        
    }
};
```


### LeetCode56

#### 区间合并(LeetCode56: Merge Intervals)

给出一个区间数组，将所有具有重叠情况的数组合并到一个数组，再输出一个没有重叠现象的数组

```
Input: [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].

Input: [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considerred overlapping.
```

思路：先排序，再逐个进行合并。

注意：尾部的处理，不能忘记最后一个区间的处理

```c++
/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
class Solution {
public:
    vector<Interval> merge(vector<Interval>& intervals) {
        vector<Interval> result;
        if(intervals.empty()){
            return result;
        }
        
        multimap<int,Interval> in_map;
        int size = intervals.size();
        for(int i = 0;i<size;i++){
            in_map.insert(make_pair(intervals[i].start,intervals[i]));//插入到红黑树机制的multimap结构中进行排序
        }
        
        Interval *cur = &((*(in_map.begin())).second);
        for(auto iter = in_map.begin();iter!=in_map.end();iter++){
            if(iter->second.start <=cur->end)//逐个进行合并操作
                cur->end = iter->second.end>cur->end?iter->second.end:cur->end;
            else{
                result.push_back(*cur);//合并失败则说明再没有重叠的区间，直接压入结果数组
                cur = &(iter->second);       
            }
        }
        result.push_back(*cur);//尾部的处理
        return result;
        
    }
};
```


### LeetCode75

#### 颜色排序（LeetCode75:Sort Colors）

给一个数组，其中只有三类颜色：0代表红色，1代表黄色，2代表蓝色。将这数组中的颜色按0，1，2的顺序进行排序，将相同的颜色放在一起。

```
Input: [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
```

要求：使用一次遍历和常数空间复杂度完成排序

思路：两点法，将0放在首端，2放在尾端，自然1就在中间部分

```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int start = 0,end = nums.size()-1;
        int tmp;
        for(int i = 0;i <= end;i++){
            if(nums[i] == 0)//将0放在首端
            {
                tmp = nums[start];
                nums[start] = 0;
                nums[i] = tmp;
                start++;
            }
            
            if(nums[i] == 2){//将2放在尾端
                tmp = nums[end];
                nums[end] = 2;
                nums[i] = tmp;
                end--;
                i--;//和尾部数据进行交换时还要再检测一次
            }
        }
    }
};
```

### LeetCode76

#### 最小匹配窗口（LeetCode76:Minimum Window Substring）

给出一个字符串s,和一个子字符串t,在s中找到一个最小的子字符串容纳t中所有字符。

```
Input: S = "ADOBECODEBANC", T = "ABC"
Output: "BANC"
```

如果没有符合条件的子字符串，返回""

思路：

* 使用哈希表为匹配字符串t的每一个字符建立索引，并记录出现的次数（该字符要在s的子字符串中出现的次数，其他均设置为0）和所有字符的个数count。
* 然后遍历s,匹配一个hash表中对应的索引记录的次数减1（减为0时不用匹配），总次数也对应减1。
* 当总次数减为0时，说明所有要求出现的字符都出现了，然后纪录距离
* 将该子字符串的前面下班向后移动，所有移出的字符对应索引纪录的次数再加1，当次数大于1时（说明要求子字符串缺少t中的部分字符），count大于0，再移动子字符串的尾部下标寻找新的字符来满足对t的匹配
* 在如此循环的遍历过程中，记录每一个匹配的子字符串的最小长度和对应的起始下标，最后输出即可

```c++

class Solution {
public:
    string minWindow(string s, string t) {
        vector<int> map(128,0);
        int count = 0;
        for(auto c:t) {
            map[c]++;//记录t中每个字符出现的次数
            count++;//记录字符个数
        }
        
        int begin = 0,end = 0,d = INT_MAX;
        int head = 0;
        while (end < s.size()){
            if(map[s[end++]]-->0)
                //说明end位置上的字符在t中有出现
                count--;
            while(count == 0){
                //说明t中的字符均已经出现
                if(end-begin<d){
                    d = end-begin;
                    head = begin;
                }
                if(map[s[begin++]]++==0)
                    //移动前面的下标，但移出一个t中的字符时，增加count，然后继续向后遍历集齐所有的字符，再计算距离
                    count++;
            }
        }
        
        return d==INT_MAX?"":s.substr(head,d);
        
    }
};
```

### LeetCode84

#### 求最大面积子矩阵

给出一个整型数组，每个数字代表一根柱子的高度，这些柱子的宽度均为1，求在这些柱子中找到可以构成的最大面积的矩阵。

![LeetCode84.png](/img/LeetCode84.png)

思路1:遍历每一根柱子，以柱子高度为矩形的高度，求得左边和右边可以扩展的宽度，然后求面积，遍历结束后访问最大面积。

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        if(heights.empty())
            return 0;
        int left = 0,right = 0;
        int maxarea = 0,area = 0;
        int size = heights.size();
        for(int i = 0;i<size;i++){//遍历每一根柱子
            if(i>0){
                if(heights[i] == heights[i-1])
                    continue;
            }
            left = right = i;
            while(left>0){ //向左扩展
                left --;
                if(heights[left]<heights[i]){
                    left++;
                    break;
            
                }
            }
            
            while(right < size-1){//向右扩展
                right++;
                if(heights[right]<heights[i]){
                    right--;
                    break;
                }
            }
            area = heights[i]*(right-left+1);
            if(area>maxarea)
                maxarea = area;
        }
        
        return maxarea;
    }
};
```

思路2:想法和思路1一致，求左边和右边的可扩展距离

* 但这里使用栈来实现，栈中记录当前元素h左边第一个高度小于x的元素下标
* 压入h的下标
* 之后**右边**当碰到第一个高度小于h的元素，弹出h的下标
* 此时左右两边第一个小于h的元素均已经确定。弹出时计算其面积即可。
* 关键:heights数组中要在**尾部压入一个元素0**，这样可以弹出栈内所有元素。

```c++

class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        //思路和第一种解法一致，求每一根柱子向左和向右可以扩展的距离，然后求得最大面积
        //我们使用一个栈，栈内的元素记录左边第一个小于当前柱子高度x的元素
        //右边的元素当中，第一个小于x的高度压入栈时，会将x弹出，从而可以得到对于x左右可以扩展的长度
        //从而可以计算其面积
        //关键在于heights中压入一个0元素，这样可以弹出栈内所有的高度元素
        
        heights.push_back(0);
        vector<int> left_vec;
        int h = 0,wid = 0;
        int left = 0;
        int maxarea = 0,area = 0;
        for(int i = 0;i < heights.size();i++){
            while(left_vec.size()>0 && heights[left_vec.back()] > heights[i]){//当栈内有一个元素，且对应的高度小于将压入栈的下标对应的高度
                h = heights[left_vec.back()];
                left_vec.pop_back();//弹出该元素
                left = left_vec.empty()?-1:left_vec.back();//记录左边第一个小于当前高度的元素下标
                wid = i - left -1;
                area = h*wid;//计算以弹出元素高度为基础，左右扩展后的面积
                if(area > maxarea)
                    maxarea = area;
            }
            left_vec.push_back(i);//压入当前元素下标
        }
        return maxarea;
        
    }
};
```


### LeetCode122

#### 股票交易（LeetCode122:Best Time to Buy and Sell Stock II）

* 给出一个数组，第i个元素代表着第i天的股票价格，选择合适的买入和卖出的日期进行交易，交易一次使得利润最大化
* 进阶：可交易多次，使得利润最大化。但买入之前必须要先全部卖出。

思路：这里直接给出代码，主要看进阶版的简洁的代码思路：

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int ret = 0;
        for (size_t p = 1; p < prices.size(); ++p) 
            ret += max(prices[p] - prices[p - 1], 0); //累加，若只要该天的价格大于前一天的价格就累加其中的利润，就算之后有利润更大的时候，通过  prices[p] - prices[p - 1]一样可以正确得到最大利润 
        return ret;
    }
};
```

### LeetCode125

#### 有效回文（LeetCode125:Valid Palindrome）

给一个字符串，忽略大小写并只考虑字母和数字，判断该字符串是否为回文

```
Input: "A man, a plan, a canal: Panama"
Output: true

Input: "race a car"
Output: false
```

思路：简单，用栈即可

注意：对字符串的判断及操作，详见幕布：C++基础学习三：字符串，向量，数组。

1. 判断是否为数字或字符：isalnum(c);
2. 转换为对应小写字母：tolower(c);

```c++
class Solution {
public:
    bool isPalindrome(string s) {
        if(s.empty())
            return true;
        vector<char> vec,re_vec;
        int end = s.size()-1;
        for(int i = 0;i<=end;i++){
            if(isalnum(s[i]))//判断是否为数字和字母
                vec.push_back(tolower(s[i]));//转换为对应小写字母
            if(isalnum(s[end-i]))
                re_vec.push_back(tolower(s[end-i]));
        }
        
        int vec_end = vec.size()-1;
        for(int i = 0;i<= vec_end;i++){
            if(vec[i] != re_vec[i])
                return false;
        }
        
        return true;
    }
};
```

### LeetCode134

#### 汽油站（LeetCode134:Gas station）

给两个整型数组，一个数组代表一个环形路径中的汽油站所拥有的汽油总量，另一个数组表示从当前汽油站到下一个汽油站需要耗费的汽油。求是否有一个汽油站可以作为起点跑完整个环形路径。若不能跑完全程则返回-1

```
Input: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

Output: 3


Input: 
gas  = [2,3,4]
cost = [3,4,3]

Output: -1
```

思路1:利用循环，模拟每一个节点为起点的情况。

```c++

class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int left = 0;
        bool success = true;
        int size = gas.size();
        for(int i = 0;i<size;i++){
            success = true;
            if(gas[i]>=cost[i]){//以i为起点的条件
                int j = (i==size-1)?0:i+1;
                left = gas[i] - cost[i];//计算剩余汽油量
                while( j != i ){
                    left += gas[j] - cost[j];//模拟路程过程中的汽油消耗情况
                    if(left < 0){
                        success = false;
                        break;
                    }
                    j = (j==size-1)?0:j+1;//到下一个汽油站
                }
                
                if(success){
                    return i;
                }
            }
        }
        
        return -1;
    }
};
```

思路2:

非常经典的一道题。可以转换成求最大连续和做，但是有更简单的方法。基于一个数学定理：

>如果一个数组的总和非负，那么一定可以找到一个起始位置，从他开始绕数组一圈，累加和一直都是非负的

有了这个定理，判断到底是否存在这样的解非常容易，只需要把全部的油耗情况计算出来看看是否大于等于0即可。

那么如何求开始位置在哪？

注意到这样一个现象：

1. 假如从位置i开始，i+1，i+2...，一路开过来一路油箱都没有空。说明什么？说明从i到i+1，i+2，...肯定是正积累。
2. 现在突然发现开往 **位置j**时油箱空了。这说明什么？说明从位置i开始没法走完全程(废话)。那么，我们要 **从位置i+1开始重新尝试吗？不需要！**为什么？因为前面已经知道，位置i肯定是正积累，那么，如果从位置i+1开始走更加没法走完全程了，因为没有位置i的正积累了。同理，也不用从i+2，i+3，...开始尝试。所以我们可以放心地**从位置j+1**开始尝试。

代码：

```c++
int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {
  int start = 0; // 起始位置
  int remain = 0; // 当前剩余燃料
  int debt = 0; // 前面没能走完的路上欠的债

  for (int i = 0; i < gas.size(); i++) {
    remain += gas[i] - cost[i];
    if (remain < 0) {//油箱空了，以下一个位置为起点开始重新判断
      debt += remain;//跑完前面部分所需要的油耗
      start = i + 1;
      remain = 0;
    }
  }

  return remain + debt >= 0 ? start : -1;//以start为起点时，当剩余积累下的油量可以满足start之前的油耗时，说明可以跑完全程
}
```

### LeetCode149

#### 求在同一条直线上的点的最大个数（LeetCode149:Max Points on a Line）
如题

```
Input: [[1,1],[2,2],[3,3]]
Output: 3
Explanation:
^
|
|        o
|     o
|  o  
+------------->
0  1  2  3  4


Input: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
Output: 4
Explanation:
^
|
|  o
|     o        o
|        o
|  o        o
+------------------->
0  1  2  3  4  5  6
```


思路：

1. 用斜率记录在同一直线上的点
2. 从第一个点为起点，和其他点构成直线，计算一条直线拥有最多点的个数
3. 如此循环计算其它的点的最多的点，后面的点不用再和前面的点重复计算斜率
4. 得到最多点的个数

知识点：

1. 斜率的表达：使用pair< int , int>
2. 求最大公约数 :y==0?x:gcd(y,x%y);

代码实现：

```c++
/**
 * Definition for a point.
 * struct Point {
 *     int x;
 *     int y;
 *     Point() : x(0), y(0) {}
 *     Point(int a, int b) : x(a), y(b) {}
 * };
 */
class Solution {
public:
    int maxPoints(vector<Point>& points) {
        int res = 0;
        for(int i = 0;i<points.size();i++){
            map<pair<int,int>,int> lines;
            int localmax = 0;
            int samePoints = 1;
            for(int j = i+1;j<points.size();j++){
                if(points[i].x == points[j].x && points[i].y == points[j].y)
                    samePoints++;
                else
                    localmax = max(localmax ,++lines[getSlope(points[i],points[j])]);
            }
            res = max(res,localmax+samePoints);
        }
        return res;
        
    }
    //求斜率
    pair<int,int> getSlope(Point& p1,Point&p2){
        int dx = p2.x - p1.x;
        int dy = p2.y - p1.y;
        
        if(dx == 0)
            return pair<int,int>(0,p1.y);
        if(dy == 0)
            return pair<int,int>(p1.x,0);
        
        int d = gcd(dx,dy);
        return pair<int,int>(dx/d,dy/d);
        
    }
    
    int gcd(int x,int y){
        return y == 0?x:gcd(y,x%y);//求最大公约数
    }
    
};
```

### LeetCode152

#### 求最大乘积子序列（LeetCode152:Maximum Product Subarray）

```
Input: [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.

Input: [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.
```

思路：动态规划，需要记录两个信息，当前最大乘积和最小乘积（用于负数）。

```c++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int minLocal = nums[0];
        int maxLocal = nums[0];
        
        int maxGlobal = maxLocal;
        int tmp1,tmp2;
        for(int i = 1;i<nums.size();i++){
            tmp1 = max(max(maxLocal*nums[i],minLocal*nums[i]),nums[i]);
            tmp2 = min(min(maxLocal*nums[i],minLocal*nums[i]),nums[i]);
            maxLocal = tmp1;
            minLocal = tmp2;
            if(maxLocal > maxGlobal) maxGlobal = maxLocal;
        }
        
        return maxGlobal;

```

### LeetCode169

#### 求数组中的主元素（LeetCode169：Majority Element）

给出一个数组，求出该数组中出现次数超过数组总数一半的元素。

思路：见剑指offer题面试题39:数组中出现次数超过一半的数字

代码实现

```c++

class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int num = nums[0],count = 1;
        for(int i = 1;i<nums.size();i++){
            if(nums[i] == num){
                count++;
            }else{
                if(count == 0)//为0时更换元素
                    num = nums[i];
                else
                    count--;
                
            }
        }
        
        return num;
    }
};
```

### LeetCode171

#### Excel列号转换（LeetCode171:Excel Sheet Column Number）
给出一个Excel编码，将其转换为对应的列号

```
    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 
    ...
```

```
Input: "ZY"
Output: 701
```

思路（滑铁卢。。。）：循环求解

```c++
class Solution {
public:
    int titleToNumber(string s) {
        int result = 0;
        int cur;
        for(int i=0;i<s.size();i++){
            cur = s[i]-'A'+1;
            result = 26*result+cur;
        }
        return result;
    }
};
```


### LeetCode189

#### 循环移动数组（LeetCode189:Rotate Array）

给出一个数组，将整个数组向右移动k步，溢出的尾部向头部循环移动。求移动k步之后的数组

```
Input: [1,2,3,4,5,6,7] and k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]


Input: [-1,-100,3,99] and k = 2
Output: [3,99,-1,-100]
Explanation: 
rotate 1 steps to the right: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]


```

思路：见剑指Offer面试题58:翻转字符串

代码实现：

```c++

class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int start = 0,end = nums.size()-1;
        k = k%(end+1);
        rotatex(nums,start,end-k);
        rotatex(nums,end-k+1,end);
        rotatex(nums,start,end);
    }
    
    void rotatex(vector<int>& nums,int start,int end){
        int i = 0;
        int tmp;
        while (i<((end-start+1)/2)){
            tmp = nums[start+i];
            nums[start+i] = nums[end-i];
            nums[end-i] = tmp;
            i++;
        }
    }
};
```


### LeetCode166

#### 计算循环小数的分数（LeetCode166:Fraction to Recurring Decimal）

给出一个分数的分子和分母，用字符串来表达该分数的小数形式的结果，如果出现循环小数，则用括号将循环的部分括起来

```
Input: numerator = 1, denominator = 2
Output: "0.5"

Input: numerator = 2, denominator = 3
Output: "0.(6)"
```


思路：

1. 先判断正负值
2. 需要防止溢出（因为INT_MIN转换为正值会溢出）
3. 求分数的整数部分
4. 求小数部分，先将小数部分存放到一个queue中
    * 如何求小数：将余数乘以10再和除数相除，循环得到小数上的每一位
5. 使用一个map记录记录计算小数部分时所有的被除数，如果重复出现，说明进入循环，并记录下循环开始的位置

```c++
class Solution {
public:
    string fractionToDecimal(int numerator, int denominator) {
        string result;
        long num = numerator,denum = denominator;
        int beginIndex = -1;
        int count = 0;
        if((num>0&&denum<0)||(num<0&&denum>0))
            result.append("-");//判断正负号
        if(num == 0){
            result.append("0");
            return result;
        }
            
        num = abs(num);
        denum = abs(denum);
        map<int,int> record;
        queue<int> decimal;
        
        long val = num/denum;
        result.append(to_string(val));//整数部分
        num = (num%denum)*10;
        
        while(num){//循环求小数部分
            if(record.count(num)){//发现相同的除数，开始进入循环
                beginIndex = record[num];
                break;
            }else{
                //记录每个除数所在的下标count
                record.insert(pair<int,int>(num,count++));
                val = num/denum;
                decimal.push(val);
                num = (num%denum)*10;
            }
        }
        if(!decimal.empty()){//将小数部分添加到结果字符串
            result.append(".");
            for(int i =0;i<count;i++){
                if(i == beginIndex){
                    result.append("(");
                }
                result.append(to_string(decimal.front()));
                decimal.pop();
            }
        }
        
        if(beginIndex!=-1){
            result.append(")");
        }
         return result;
        }
};
```

### LeetCode283

#### 移动0元素（LeetCode283：Move Zeros）

给出一个数组，将数组中的所有0元素移动到数组末端，但是不更改其它元素的相关顺序：

```
Input: [0,1,0,3,12]
Output: [1,3,12,0,0]
```

* 不能使用额外的空间

思路：使用两个指针从头开始向后遍历，一个指针指向为0的元素，第二个指针指向该0元素后面第一个非零元素，然后替换两个元素位置，如此遍历整个数组后即可

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        vector<int>::iterator start1,start2,end;
        start1 = start2 = nums.begin();
        end = nums.end();
        while(start1<end && start2<end){
            while(*start1!=0 && start1<end) start1++;
            start2 = start1;//要找到该0元素后面的第一个非0元素
            while(*start2==0 && start2<end) start2++;
            if(start1<end&&start2<end)
                iter_swap(start1,start2);//交换两个迭代器所指元素的值，与swap不同，swap是交换两个迭代器的变量的值
        }
    }
};
```

### LeetCode289
#### 生命游戏（LeetCode289：Game of Life）

给出一个二维数组，该数组中不是0（死亡） 就是1（存活），下一时刻的生命状态取决于如下规则：

1. 一个存活单位的四周八个单位如果有少于2个存活或多于3个存活，则死亡
2. 一个存活单位的四周八个单位如果有正好2个或3个存活单位，则继续存活
3. 一个死亡单位四周八个如果有正好三个存活单位则可以复活

思路：

1. 先遍历整个二维数组，计算每个单位的四周的存活个数，然后标记是否死亡或是否存活
2. 标记2代表有死亡到复活，标记3由存活到死亡，而不是直接进行变化，这样就不影响其它单位的生命变化的判断
3. 最后遍历一遍二维数组，将所有的2改为1，将3 改为0即可

代码实现：

```c++

class Solution {
public:
    void gameOfLife(vector<vector<int>>& board) {
        int count = 0;
        int col_end = board.size();
        int raw_end = board[0].size();
        for(int i = 0;i<col_end;i++){
            for(int j = 0;j<raw_end;j++){
                count = count_one(board,i,j,col_end-1,raw_end-1);
                if(board[i][j]){
                    if(count<2||count>3)
                        board[i][j] = 3;//标记变化状态，3代表由存活到死亡
                }else{
                    if(count == 3)
                        board[i][j] = 2;//2代表由死亡到存活
                }
            }
        }
        
        for(int i = 0;i<col_end;i++){
            for(int j = 0;j<raw_end;j++){
                if(board[i][j] == 2)//根据状态标记进行状态更新
                    board[i][j] = 1;
                if(board[i][j] == 3)
                    board[i][j] = 0;
            }
        }
    }
    
    //计算四周有多少个存活单位
    int count_one(vector<vector<int>>& board,int i,int j,int col,int raw){
        int result = 0;
        if(i+1<=col&&(board[i+1][j]==1||board[i+1][j]==3)){
            result++ ;
        }
        if(j+1<=raw&&(board[i][j+1]==1||board[i][j+1]==3)){
            result++ ;
        }
        if(i-1>=0&&(board[i-1][j]==1||board[i-1][j]==3)){
            result ++ ;
        }
        if(j-1>=0&&(board[i][j-1]==1)||board[i][j-1]==3){
            result ++;
        }
        if(i+1<=col&&j+1<=raw&&(board[i+1][j+1]==1||board[i+1][j+1]==3)){
            result ++ ;
        }
        if(i+1<=col&&j-1>=0&&(board[i+1][j-1]==1||board[i+1][j-1]==3)){
            result ++ ;
        }
        if(i-1>=0&&j+1<=raw&&(board[i-1][j+1]==1||board[i-1][j+1]==3)){
            result ++ ;
        }
        if(i-1>=0&&j-1>=0&&(board[i-1][j-1]==1||board[i-1][j-1]==3)){
            result ++ ;
        }
        return result;
    }
};
```

### LeetCode324
#### 摆动排序（LeetCode324：Wiggle SortII）
给定一个数组nums，将该数组内的元素进行排序，满足如下规则： nums[0] < nums[1] > nums[2] < nums[3]...

```c++
Input: nums = [1, 5, 1, 1, 6, 4]
Output: One possible answer is [1, 4, 1, 5, 1, 6].

Input: nums = [1, 3, 2, 2, 3, 1]
Output: One possible answer is [2, 3, 1, 3, 1, 2].
```

思路：向将数组进行排序，然后分成前后两部分，前部分为下标为偶数要放置的数，后部分为下标为奇数位要放置的数

代码实现：

```c++
class Solution {
public:
    void wiggleSort(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        
        vector<int> copy(nums);
        
        int n = nums.size();
        int m = (n+1)/2;//偶数下标的个数，需要放置前半部分较小的数
        
        
        for(int i = m-1,j = 0;i>=0;i--,j+=2)//放置偶数下标位置的元素
            nums[j] = copy[i];
        
        for(int i = n-1,j = 1;i>=m;i--,j+=2)//放置奇数下标的元素
            nums[j] = copy[i];
    }
};
```

进阶实现：使用快排找到分割前后两个部分的中间元素并分为两部分即可，因为前后两部分的元素我们并不要求严格排序。

### 其它ending


---
layout:     post
title:      "计算机网络基础"
subtitle:   "计算机网络基础－自顶向下"
date:       2018-03-14 15:00:00
author:     "Xu"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - 计算机网络基础
---
# 计算机网络

## 计算机网络和因特网

### 分组交换

**分组交换**：为了从源端系统向端系统发送一个报文，源将长报文划分成较小的数据块，称之为分组。每个分组通过通信链路和分组交换机（交换机主要有两类：路由器和链路交换机）传送。

**存储转发机制**：多数分组交换机在链路的输入端使用存储转发传输机制，存储转发机制是指在发送该分组的第一个比特之前必须先接收到整个分组

正是由于分组转发机制，所以**端到端的时延**为:  **d = N(L/R);**L为要发送的数据包的比特数，R为端到端的每条链路的传输速率，N为端到端经过路径上的交换机的个数。

**输出缓存**（输出队列）：交换机会存储那些将要发送到链路上的分组，这就会造成**排队延时**，因为缓存的空间是有限的，一个到达的分组可能发现缓存已满，这就会出现**分组丢失（丢包）**的情况

**转发表**：每台路由器都具有一个转发表，用于将目的地址映射为输出链路。**路由选择协议**会自动的设置这些转发表。

**电路交换**：在通信之前需要建立一条专用的端到端连接

电路交换中的复用：**频分复用**和**时分复用**

分组交换中的时延：总时延＝ **结点处理时延**（处理分组首部和决定分组导向等） ＋ **排队时延** ＋ **传输时延**（路由器的发送速度） ＋ **传播时延**（链路上的传播速度，基于媒介）

排队时延和**流量强度**密切相关：流量强度衡量了一个结点分组到达队列的速率La和该节点路由器发送分组速率R之比  －－ La/R.

* 明显流量强度>1，排队队列越来越长，时延也就越来越长
* 当流量强度≤1时，则排队延时在于流量的性质，如果分组是以**突发**形式(每N秒同时到达N组分组)到达，而不是周期形式则会有很大排队延时。

**吞吐量**：表示实际情况下确实发生数据传输的时候，主机接受数据速率的情况，而不是理想情况，有可能发送端的速率小于接受端的理想速率，实际情况下吞吐量即为发送端的速率。

* 瞬时吞吐量：主机在某一时刻接受数据的速率
* 平均吞吐量：主机在某一段时间T内接收到F比特数据的平均速率(F/T)

### 协议层

五层因特网协议栈和七层ISO OSI参考模型：

![protocol_stack](/img/protocol_stack.png)

**应用层**(应用相关的数据，更贴近应用，业务)：网络应用程序及其应用层协议存留的地方，例如HTTP,SMTP和FTP，DNS，我们把这种位于应用层的协议信息分组称为**报文**

**运输层**（保证数据的传输，以及控制）：应用程序端点之间要确保应用层**报文**成功传输且进行流量控制和拥塞控制的协议，如TCP,UDP协议.这些用于运输层协议的分组我们称为**报文段**

**网络层**（获取传输数据的目的地址IP）：负责将**数据报**的网络层分组从一台主机移动到另一台主机。传输层会向网络层传递运输层的报文段及目的地址。然后网络层根据目的地址和**IP协议**来确定该数据报的传输方向。网络层还包含**路由选择协议**，来生成网络层的转发表，确定发送地址。

**链路层**(传输数据的形式)：网络层通过网络层的分析确定了要发送的目的IP地址，然后将数据报交由链路层实现**具体的数据传输**。链路层包括**以太网，WIFI,和电缆接入网协议**等，我们把链路层的分组称之为**帧**

**物理层**（传输数据的物理实现）：链路层实现了数据帧在网络上的移动，物理层的任务就是实现**如何一个一个比特从一个节点移动到下一个节点**，结合具体的传输媒介：双绞铜线，光纤等。

国际标准化组织ISO提出计算机网络组织为7层，多加了两层：

**表示层**：使应用程序能够解释交换数据的含义，如一些**数据压缩和加密的协议**，一种对应用数据的解释机制
**会话层**：提供了数据交换定界和同步功能，包含了检查点和恢复方案，一种对应用数据的**保障机制**

#### 封装

五个协议层通过层层的协议封装，添加相应层的协议头部信息由上到下构成报文，报文段，数据报，帧然后发送，发送到目的端后，帧会经过链路层，网络层，运输层以及应用层的层层解析分别得到数据报，报文段，报文和应用数据
![stack_ex](/img/stack_ex.png)

### 网络攻击
拒绝服务攻击（Dos）：
1. 弱点攻击：攻击易受到攻击的应用程序和操作系统
2. 带宽洪泛：想目标主机发送大量分组，导致拥塞，从而使合法分组无法到达服务器
3. 连接洪泛：在目标主机中创建大量的半开或全开TCP连接，主机因这些伪造的连接而陷入困境，停止接受合法的协议

分布式Dos(DDos)：攻击源控制多个源向目标猛烈发送流量，导致其拒绝服务。

分组嗅探器：可以生成网络中某个分组的副本，从而离线分析造成商业数据被盗

IP哄骗（IP spoofing）:我们可以自己生成任意源地址，分组内容和目的地址的分组，从而让主机执行我们想要的命令。

## 应用层

进程：一个进程可以被认为是运行在端系统中的一个程序，相对于任务而言的概念，而线程是相对于操作系统而言，是一个操作系统调度资源的最小单位

运输层为应用程序提供的服务分为四个部分：可靠数据传输，吞吐量，定时，安全性

* 可靠数据传输：如果一个协议提供了可以确保数据交付的服务，就认为提供了可靠数据传输
* 吞吐量：具有吞吐量要求的应用应用程序被称为带宽敏感应用
* 定时：保证一定时间内传输数据
* 安全性：安全性协议，保证数据传输安全

TCP服务：面向连接的服务和可靠的数据传送服务
UDP服务：无连接的轻量级运输协议

五个重要的应用：Web,文件传输，电子邮件，目录服务，和P2P

#### 超文本传输协议http（80端口）

HTTP是利用TCP作为支撑运输协议。HTTP客户首先发起一个与服务器的TCP连接，HTTP服务器并不保存客户的任何信息，所以我们说HTTP是一个无状态协议

**非持续连接和持续连接**：非持续连接是所有请求都经过单独的TCP连接发送，持续连接则是通过同一个TCP连接发送， HTTP默认使用持续连接，但也可以配置成非持续连接

RTT(Round-Trip Time)：往返时间的定义，这个时间是指一个短分组从客户端到服务器然后返回客户端所花的时间

##### HTTP 报文格式：请求报文和响应报文
* 请求报文

```
	Get   /somedir/page.html HTTP/1.1
	Host: www.someschool
	Connection:close
	User-Agent:Mozilla/5.0
	Accept-language:fr
```
第一行为请求行：方法字段   URL字段   HTTP版本字段

后继行为首部行：Host指明对象所在主机，Connection指明服务器发送完请求后就关闭这条连接 User-Agent指明用户代理，Accept-language指明对象语言版本。首部行是非必须的

一个HTTP请求报文通用格式：
![http_request](/img/http_request.png)

* HTTP响应报文（三个部分：初始状态行，首部行，实体体）
```
HTTP/1.1  200  OK
Connection:close
Date: Tue,09 Aug 2011 15:44:04 GMT
Server:Apache/2.2.3
Last-Modified:Tue,09 Aug 2011 15:11:03 GMT
Content-Length:6821
Content-Type:text/html
...(实体体)

```
![http_response](/img/http_response.png)

一些常用的状态码：

* 200:请求成功
* 301:Moved Permanently 请求的对象已经被永久转移了，新的URL会定义在首部行中的Location字段
* 400:通用差错代码，表示该请求不能被服务器理解
* 404:Not Found,被请求的文档不在服务器上
* 505:HTTP Version Not Suported: 服务器不支持请求报文使用的HTPP版本

##### 用户与服务器的交互cookie

因为HTTP是无状态的，没有记录用户的信息，有的情况下一个Web站点想要希望能够识别用户，希望把内容与用户身份联系起来，为此HTTP使用cookie

四个组件：

* HTTP响应报文中的一个cookie首部行
* HTTP请求报文中的一个cookie首部行
* 在用户端系统保留一个cookie文件并由浏览器进行管理
* 位于Web站点的一个后端数据库

cookies通信流程：浏览器第一次访问服务器，服务器会生出一个识别码，并将该识别码通过set-cookies字段发送给浏览器，浏览器根据该识别码在特定的cookies文件中添加一行，随后就用该识别码cookie字段去访问服务器，服务器根据该识别码确认用户身份，于是建立一个用户会话层

##### Web缓存器

Web缓存起也叫代理服务器，会缓存一些请求过程中的对象加快访问速度。Web缓存器相当于一个中间件，既是客户端也是服务器。它可以大大减少对客户请求的响应时间，特别是当客户与初始服务器之间的带宽远低于客户与WEB缓存器的带宽，效果更明显。

由于Web缓存器中的副本内容可能过时，我们可以通过条件GET来确定该内容是否被修改了

**条件GET**:请求报文使用GET方法，并且请求报文中包含一个"If-Modified-Since"字段

#### 文本传输协议FTP（21端口）
用户首先提供一个用户标识和口令，确认身份后即可通过一个FTP用户代理与FTP进行交互传输文件到相应文件系统中去，同样FTP也是通过TCP连接来传输数据

FTP和HTTP有很多共同点也有一些重要的区别，其中最显著的就是FTP使用来两个TCP连接来传输文件：

* **控制连接**:用于传输控制信息，如用户标识，口令，改变远程目录以及存放盒获取文件的命令
* **数据连接**:实际发送一个文本数据

因为FTP又一个单独的控制连接，所以也叫做**带外**传送的

FTP的数据传输是非连续的，因为在一个会话中的每个文件传输都是要建立一个新的数据连接

FTP一些常见命令

* USER username:传送用户标识
* PASS password:传送口令
* LIST:请求当前远程目录中的所有文件列表
* RETR filename:用于在远程主机检索（get）该文件
* STOR filename:远程主机存放该文件

FTP一些常用回答响应

* 331 Username OK,Password required  (用户名OK,需要口令)
* 125 Data connection already open;transfer starting(数据连接已经打开，开始传送文件)
* 425 Can't open data connection (无法打开数据连接)
* 452 Error writing file(写文件差错) 

#### 电子邮件SMTP（25端口）
电子邮件系统包括：用户代理，邮件服务器，简单邮件传输协议（SMTP）

SMTP使用TCP可靠数据传输服务，使用一些命令用于通信HELO,MAIL FROM,RECPT TO,DATA,CRLF,QUIT等。且SMTP要求报文使用7比特ASCLL码格式，并且把所有报文对象都放倒一个报文中

邮件服务器将邮件发送到接受方的协议:POP3(第三版邮局协议),IMAP(因特网邮局访问协议)

#### DNS（53端口）

一种主机名到IP地址转换的目录服务，域名系统，一台用户主机运行着DNS应用的客户端，将主机名经由客户端发送给DNS服务器，服务器会反悔该主机名对应的IP地址，然后用户主机和该IP地址80端口建立TCP连接

DNS服务器分为

* 根服务器（13个根服务器，标号从A到M）
* 顶级域服务器:国家级，com,org,net,edu等
* 权威DNS服务器

DNS缓存和DNS报文不做具体描述见P93

#### P2P网络和TCP，UDP套接字编程见书

### 运输层

网络层提供的是两个主机之间的逻辑通信（邮政服务，邮车），运输层则是提供两个主机之间进程的逻辑通信（发送和接收并确认，相当于发件人和收件人发信和收信，并相互确认），运输层主要负责将从网络层接收到的报文段交付给应用程序进程

**套接字**：网络向进程传递数据和从进程向网络传递数据的门户，套接字位于**应用层和运输层之间**，用于两层的数据交互。所以运输层将从网络层获取到的报文段解析获取报文通过套接字传递给应用层

* 多路分解：将运输层的报文段中的数据交付到正确的套接字称为多路分解
* 多路复用：将多个套接字中的数据封装到首部信息生出报文段，然后将报文段传递给网络层叫多路复用

多路复用和分解的要求：

1. 套接字有唯一标示符
2. 报文段有特殊字段如源端口号字段，目的端口号字段来指示该报文段所要交付的套接字。

端口号：16bit，0～65535之间

* 0～1023: 为周知端口号，受限制的端口，只被诸如HTTP,FTP等周知应用层协议使用
* 其他的端口可以人为使用

#### UDP 无连接运输
DNS是一个通常使用UDP的例子，来发送一个DNS查询报文

UDP无需建立连接，没有连接状态，分组首部开销小

UDP报文段结构：源端口号＋目的端口号＋长度＋检验和＋应用数据（应用层报文）

**UDP检验和**：将应用数据中的所有字的16bit相加，通过回卷及**反码运算**获取检验和，所以这些应用数据和检验和（反码）全部加到一起，如果没有bit出错的话，则得到的和应该全为**111111111111111**，只要有一个bit为0说明出现了差错。这可以发现差错，但不能恢复差错

#### 可靠数据传输
可靠数据传输不仅仅会在运输层出现，也会出现在应用层和链路层，也许可靠数据传输的下层协议是不可靠的，所以这是一件相当困难的任务，比如TCP就是建立在不可靠的IP端到端网络层之上实现的可靠数据传输协议。

一层可靠数据传输协议需要在这一层实现四个接口：

* rdt_send():从上层接收要发送的数据
* udt_send():上层接收到的数据经过可靠数据传输协议处理检验交付给下层
* rdt_rcv():接收方从下层接收数据（下层协议可能是不可靠的数据传输，我们需要这一层的协议保障数据传输的可靠性）
* deliver_data():下层数据经过可靠数据传输协议处理检验后交付给接受方上层

![reliable_data_transfer](/img/reliable_data_transfer.png)

构造可靠信道传输协议

1.假设底层信道完全可靠，rdt1.0版本传输协议

2.底层信道可能出现差错，比特受损，当出现差错时，要自动请求重传(ARQ协议)，rdt2.0版本协议

* * 差错检测
* * 接收方反馈：肯定反馈(ACK),否认确定(NAK)
* * 重传

由于当反馈ACK,NAK出现差错时，我们无法知道接受方是否正确的接收到了数据。我们可以通过在数据分组中添加一个字段，然发送方对数据分组进行编号，接收方只需要检察序号即可确定分组是否是一次重传。

3.底层信道可能出现丢包，rdt3.0版本
发送一个分组后，启动一个定时器，等待一定时间RTT，如果没有接收到ACK响应，则重传。有可能是因为网络的状况导致分组没有及时到达接收方，或ACK没有及时到达发送方。这样就会出现**冗余的数据分组**


由于这个版本属于停等协议，即当分组发送后，必须要等到接收到ACK反馈才能发送下一个分组，这样就会严重降低发送方的数据发送效率，所以我们提出一种**流水线**的可靠数据传输协议，即不需要等待ACK反馈就可以连续发送多个分组，要求：

* 必须增加序号范围
* 协议的接收方和发送方也许能缓存多个分组，发送方最低限度应当缓存那些发送了但没有确认的分组
* 处理丢失损坏及延时过大的分组的两种基本方法：回退N步和选择重传。

##### 回退N步（滑动窗口协议）

发送方维持一个N个分组的窗口，该窗口维护的分组为那些已经发送但是没有接收到确认的分组，当该分组满时，不能再向接受方发送分组，需要等待响应ACK。否则可以发送分组。

接收方当接收到一个序号为n的分组时，如果是按序接收，即前面接收的分组序号为n-1则为分组n发送一个ACK，否则发送最近接收到分组序号的ACK，比如最近接收到的分组是n-2,当收到n分组时，发送一个序列号为n-2的ACK。

窗口会为最早发送的分组启动一个计时器，发现超时后会将窗口维持的所有分组重传。而当接收到最早发送的ACK时，则会为下一个分组重启该定时器，窗口向前滑动一格。

![GBN](/img/GBN.png)

回退N步当分组很大时会出现信道利用率低的问题，因为可能因为分组的差错导致重传大量的分组。这就需要用到下面的选择重传

##### 选择重传 
区别：

**发送方**：发送方维持的窗口中不仅仅包含的数据分组不全是未确认的，可能有部分分组已经确认正确发送。并且每个未确认的分组都有一个逻辑定时器，当出现超时时，则重传那些未确认的分组，而不需要将分组中的数据全部重传。并且当接收到ACK，且该ACK对应该窗口的最早发送的分组，则窗口向前移动，移动到最近没有确认的分组。

**接收方**:接收方同样维持一个窗口，该窗口维持的是没有按序交付的分组，窗口的第一个分组肯定是还没有正确接收的序号，而窗口中也可能缓存了那些失序但正确接收的分组。并且当接收方接收到一个序号为n的分组（在窗口内）都会对该序号为n的分组进行响应并缓存，而不是对最近未接收的分组响应。

![SR](/img/SR.png)

接收方的窗口大小必须小于或等于序号空间的一半，否则会出现序号n的分组还没正确接收到时，下一个序列回滚已经发送新的序列同样为n的分组，这样接收方无法判断该分组是重传的分组还是新的分组。

#### TCP 面向连接的运输

TCP提供的连接不是真实的链路连接，TCP所有的连接状态都保存在两个**端系统**中，之前我们类比过，TCP这类运输层协议，只能让**发信人和收信人**确认信息发送的一套机制，或者说是一套端到端的暗语，来确保对方已经收到了信的内容。

TCP建立连接的通信过程：

1. 三次握手，端到端来回发送三次特殊TCP报文段来确认连接建立。
2. 建立连接后，客户端通过套接字发送数据到运输层，这里开始由TCP协议接管，TCP首先将这些数据引导到发送缓存里，接下来TCP将不定时的从缓存中取出数据并放入到报文段（添加TCP首部）发送
3. 报文段的大小（**MSS,最大报文段长度**）受限于**最大链路层帧长度(MTU,最大传输单元)**，即报文段大小MSS加上**TCP/IP协议首部长度(通常40)**要小于最大传输单元MTU

所以涉及到TCP连接的部分包括端和端的:缓存，变量和套接字

##### TCP报文段结构

![TCPSegment](/img/TCPSegment.png)

**序号和确认号**：实现全双工

* **序号**（用于发送数据）：TCP的序号是建立在字节编号的基础上，而不是报文段序列的基础，TCP会默认为数据流中的每一个字节进行编号，然后报文段中的序号是根据数据中的一个字节编号来确定的。
* **确认号**（用于接收数据）：因为TCP是全双工的，所以在主机A给B发送数据的同时也可能接收到B发送来的数据，确认号就是用于告诉B主机期望下一个接收的字节编号
* TCP并没有为接收到失序报文段时规定处理过程，而是将这一结果交给编程人员实现，可以选择丢弃，或缓存失序报文段。为节约带宽一般采取后者

**超时/重传机制**：

* 由于TCP是采取的超时/重传机制，所以如何定义超时是我们需要解决的问题
* 自然我们需要估计往返时间(RTT),我们只对**传输一次**就成功的报文取样往返时间**SampleRTT**,根据指数加权移动平均来估计往返时间:EstimatedRTT = 0.875\*EstimatedRTT + 0.125\*SampleRTT。
* DevRTT用于衡量EstimatedRTT波动的程度
* 超时间隔：TimeoutInterval = EstimatedRTT+4\*DevRTT,当出现超时后，**一般会将超时间隔加倍**

* 快速重传：当接收方接收到一个失序的报文段时，会重复发送按序接受的最后一个报文段的响应ACK，这样发送方就会接受到冗余的ACK，当发送方一旦收到**三个**冗余ACK，TCP就会执行快速重传
* TCP是回退N步GBN和选择重传SR的混合体，为什么是GBN?因为TCP才有累积确认的方式，当收到一个失序的报文段时，只会对正确接收的有序报文段的最后一个做重复确认。但TCP和GBN也有区别，因为TCP会缓存那些失序接收的报文。甚至当假设第n个报文段还没有确认时，但收到了n+1报文段的确认，这样也会默认第n个报文段正确接收。并且TCP会选择确认那些失序报文段，SR会跳过那些被选择确认的报文段，不会去重传这些被选择确认的报文段。

##### 流量控制

流量控制服务是为了消除发送方使得接收方缓存溢出的可能。拥塞控制则是发送方因为IP网络的拥塞被遏制的情况。

**接收窗口**：**发送方**维持一个接收窗口的变量来提供流量限制，提示发送方接收方还有多少缓存空间rwnd。发送方的**未被确认的报文段数量**不能多于该接收窗口的大小

* 接收方计算接收窗口的大小：LastByteRead - LastByteRcvd
* 发送方计算未被确认的报文段数量：LastByteSent - LastByteAcked<=rwnd

小问题：当接收方的缓存满时，rwnd=0,发送方不会再向接收方发送数据，接收方也不会产生响应，当接收方缓存清空时，发送方夜不能得知该消息，所以发送方一直处于堵塞状态。处于该问题的考虑，我们提出**当接收方缓存空间为0时，发送方依然会发送只有一个字节数据的报文段，接收方也会对其发送确认报文，当缓存清空时，rwnd会通过确认报文及时更新让发送方知道**。


##### 三次握手建立连接

1. 客户端TCP向服务器端发送一个特殊的TCP报文段，该报文段中**不包含应用层数据，SYN标志位置为1**，该特殊报文段会**随机选择一个初始序号**client_isn,放在序号字段中。
2. 服务器端获取了该报文段后，**分配了缓存和变量**，并向客户端发送了允许连接的报文段。该报文段也**不包含应用层数据，SYN位置为1，报文段首部的确认字段设为client_isn＋1**。同样也会为自己设置一个初始序号**server_isn填在序号字段**。表示同意接收连接。该报文段也称为**SYNACK报文段**
3. 当客户端接收到SYNACK报文段后，客户端要为该连接**分配缓存和变量**，同时向服务器发送另一个报文段，并将**确认字段设置为server_isn+1**,因为连接已经建立，所以**SYN比特设为0**，且该报文段**可以携带应用层数据**

![TCP3_Shake](/img/TCP3_Shake.png)

正确的TCP建立过程的客户端状态变化：

![TCP_CLIENT_STATE](/img/TCP_CLIENT_STATE.png)

正确的TCP建立过程的服务器端状态变化：

![TCP_SERVER_STATE](/img/TCP_SERVER_STATE.png)



##### 拥塞控制原理

端到端的拥塞控制：在该拥塞控制方法中，网络层没有为运输层拥塞控制提供显式支持，即使网络中出现拥塞，我们只能通过TCP返回的信息来推断，IP层是不会给出反馈信息的

网络辅助的拥塞控制：网络层构件，如路由器会显式地向发送方提供拥塞控制的反馈信息，有两种方式：1. 路由器显式的向发送方发送分组提示拥塞。2.通过标记发送方发送给接收方分组中的标记，然后接收方发送分组给发送方提示拥塞。

ATM ABR拥塞控制框架：ATM表示从源主机到目的机路径上每个节点的状态都会被记录，ABR则是会在发生拥塞时通过抑制传输速率。并且ABR提供了三种机制来提示拥塞信息：

* EFCI比特：设置该比特位提示拥塞
* CI,NI比特:比特CI表示拥塞，NI表示畅通
* ER（两字节）：显式速率，设置该两字节显式调整发送方的速率

##### TCP拥塞控制

**拥塞窗口**：TCP跟踪一个额外的变量，拥塞窗口cwnd，在客户端中已发送但未确认的报文段数量必须要少于拥塞窗口和接收窗口之间的较小值。

TCP如何感知拥塞：1.超时   2.三个冗余ACK

**自计时**：当TCP报文段被正常接收并且确认时，我们会通过**确认的延时或速率**来自适应的提高发送速率，如果说确认速率慢，则**拥塞窗口**会缓慢增加，如果确认速度快，拥塞窗口则迅速增加。

TCP如何确认发送速率应该未多少：1.丢包后降低速率   2.顺利确认，提高速率   3. 探测速率，通过不断增加速率直到丢包发生后才降低速率，然后继续探测

##### TCP拥塞控制算法，慢启动，拥塞避免，快速恢复

###### 慢启动










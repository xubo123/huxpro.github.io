---
layout:     post
title:      "计算机网络基础"
subtitle:   "计算机网络基础－自顶向下"
date:       2018-03-14 15:00:00
author:     "Xu"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - 计算机网络基础
---
# 计算机网络

<!-- GFM-TOC -->
* [一、计算机网络和因特网](#一计算机网络和因特网)
    * [分组交换](#分组交换)
    * [协议层](#协议层)
    * [网络攻击](#网络攻击)
* [二、应用层](#应用层)
    * [超文本传输协议http（80端口）](#超文本传输协议http（80端口）)
    * [文本传输协议FTP（21端口）](#文本传输协议FTP（21端口）)
    * [电子邮件SMTP（25端口）](#电子邮件SMTP（25端口）)
    * [DNS（53端口）](#DNS（53端口）)
* [三、传输层](#传输层)
    * [UDP－无连接运输](#UDP－无连接运输)
    * [可靠数据传输](#可靠数据传输)
    * [TCP－面向连接的运输](#TCP－面向连接的运输)
* [四、网络层](#网络层)
    * [虚电路和数据报网络](#虚电路和数据报网络)
    * [路由器](#路由器)
    * [网际协议](#网际协议)
    * [路由选择算法](#路由选择算法)
    * [因特网的路由选择](#因特网的路由选择)
* [五、链路层](#链路层)
    * [差错检测](#差错检测)
    * [多路访问链路和协议](#多路访问链路和协议)
    * [链路层编址](#链路层编址)
    * [以太网](#以太网)
    * [交换机](#交换机)
* [六、Web页面请求过程](#Web页面请求过程)
<!-- GFM-TOC -->

## 计算机网络和因特网

### 分组交换

**分组交换**：为了从源端系统向端系统发送一个报文，源将长报文划分成较小的数据块，称之为分组。每个分组通过通信链路和分组交换机（交换机主要有两类：路由器和链路交换机）传送。

**存储转发机制**：多数分组交换机在链路的输入端使用存储转发传输机制，存储转发机制是指在发送该分组的第一个比特之前必须先接收到整个分组

正是由于分组转发机制，所以**端到端的时延**为:  **d = N(L/R);**L为要发送的数据包的比特数，R为端到端的每条链路的传输速率，N为端到端经过路径上的交换机的个数。

**输出缓存**（输出队列）：交换机会存储那些将要发送到链路上的分组，这就会造成**排队延时**，因为缓存的空间是有限的，一个到达的分组可能发现缓存已满，这就会出现**分组丢失（丢包）**的情况

**转发表**：每台路由器都具有一个转发表，用于将目的地址映射为输出链路。**路由选择协议**会自动的设置这些转发表。

**电路交换**：在通信之前需要建立一条专用的端到端连接

电路交换中的复用：**频分复用**和**时分复用**

分组交换中的时延：总时延＝ **结点处理时延**（处理分组首部和决定分组导向等） ＋ **排队时延** ＋ **传输时延**（路由器的发送速度） ＋ **传播时延**（链路上的传播速度，基于媒介）

排队时延和**流量强度**密切相关：流量强度衡量了一个结点分组到达队列的速率La和该节点路由器发送分组速率R之比  －－ La/R.

* 明显流量强度>1，排队队列越来越长，时延也就越来越长
* 当流量强度≤1时，则排队延时在于流量的性质，如果分组是以**突发**形式(每N秒同时到达N组分组)到达，而不是周期形式则会有很大排队延时。

**吞吐量**：表示实际情况下确实发生数据传输的时候，主机接受数据速率的情况，而不是理想情况，有可能发送端的速率小于接受端的理想速率，实际情况下吞吐量即为发送端的速率。

* 瞬时吞吐量：主机在某一时刻接受数据的速率
* 平均吞吐量：主机在某一段时间T内接收到F比特数据的平均速率(F/T)

### 协议层

五层因特网协议栈和七层ISO OSI参考模型：

![protocol_stack](/img/protocol_stack.png)

**应用层**(应用相关的数据，更贴近应用，业务)：网络应用程序及其应用层协议存留的地方，例如HTTP,SMTP和FTP，DNS，我们把这种位于应用层的协议信息分组称为**报文**

**运输层**（保证数据的传输，以及控制）：应用程序端点之间要确保应用层**报文**成功传输且进行流量控制和拥塞控制的协议，如TCP,UDP协议.这些用于运输层协议的分组我们称为**报文段**

**网络层**（获取传输数据的目的地址IP）：负责将**数据报**的网络层分组从一台主机移动到另一台主机。传输层会向网络层传递运输层的报文段及目的地址。然后网络层根据目的地址和**IP协议**来确定该数据报的传输方向。网络层还包含**路由选择协议**，来生成网络层的转发表，确定发送地址。

**链路层**(传输数据的形式)：网络层通过网络层的分析确定了要发送的目的IP地址，然后将数据报交由链路层实现**具体的数据传输**。链路层包括**以太网，WIFI,和电缆接入网协议**等，我们把链路层的分组称之为**帧**

**物理层**（传输数据的物理实现）：链路层实现了数据帧在网络上的移动，物理层的任务就是实现**如何一个一个比特从一个节点移动到下一个节点**，结合具体的传输媒介：双绞铜线，光纤等。

国际标准化组织ISO提出计算机网络组织为7层，多加了两层：

**表示层**：使应用程序能够解释交换数据的含义，如一些**数据压缩和加密的协议**，一种对应用数据的解释机制
**会话层**：提供了数据交换定界和同步功能，包含了检查点和恢复方案，一种对应用数据的**保障机制**

#### 封装

五个协议层通过层层的协议封装，添加相应层的协议头部信息由上到下构成报文，报文段，数据报，帧然后发送，发送到目的端后，帧会经过链路层，网络层，运输层以及应用层的层层解析分别得到数据报，报文段，报文和应用数据
![stack_ex](/img/stack_ex.png)

### 网络攻击
拒绝服务攻击（Dos）：
1. 弱点攻击：攻击易受到攻击的应用程序和操作系统
2. 带宽洪泛：想目标主机发送大量分组，导致拥塞，从而使合法分组无法到达服务器
3. 连接洪泛：在目标主机中创建大量的半开或全开TCP连接，主机因这些伪造的连接而陷入困境，停止接受合法的协议

分布式Dos(DDos)：攻击源控制多个源向目标猛烈发送流量，导致其拒绝服务。

分组嗅探器：可以生成网络中某个分组的副本，从而离线分析造成商业数据被盗

IP哄骗（IP spoofing）:我们可以自己生成任意源地址，分组内容和目的地址的分组，从而让主机执行我们想要的命令。

## 应用层

进程：一个进程可以被认为是运行在端系统中的一个程序，相对于任务而言的概念，而线程是相对于操作系统而言，是一个操作系统调度资源的最小单位

运输层为应用程序提供的服务分为四个部分：可靠数据传输，吞吐量，定时，安全性

* 可靠数据传输：如果一个协议提供了可以确保数据交付的服务，就认为提供了可靠数据传输
* 吞吐量：具有吞吐量要求的应用应用程序被称为带宽敏感应用
* 定时：保证一定时间内传输数据
* 安全性：安全性协议，保证数据传输安全

TCP服务：面向连接的服务和可靠的数据传送服务
UDP服务：无连接的轻量级运输协议

五个重要的应用：Web,文件传输，电子邮件，目录服务，和P2P

### 超文本传输协议http（80端口）

HTTP是利用TCP作为支撑运输协议。HTTP客户首先发起一个与服务器的TCP连接，HTTP服务器并不保存客户的任何信息，所以我们说HTTP是一个无状态协议

**非持续连接和持续连接**：非持续连接是所有请求都经过单独的TCP连接发送，持续连接则是通过同一个TCP连接发送， HTTP默认使用持续连接，但也可以配置成非持续连接

RTT(Round-Trip Time)：往返时间的定义，这个时间是指一个短分组从客户端到服务器然后返回客户端所花的时间

#### HTTP 报文格式：请求报文和响应报文
* 请求报文

```
	Get   /somedir/page.html HTTP/1.1
	Host: www.someschool
	Connection:close
	User-Agent:Mozilla/5.0
	Accept-language:fr
```
第一行为请求行：方法字段   URL字段   HTTP版本字段

后继行为首部行：Host指明对象所在主机，Connection指明服务器发送完请求后就关闭这条连接 User-Agent指明用户代理，Accept-language指明对象语言版本。首部行是非必须的

一个HTTP请求报文通用格式：
![http_request](/img/http_request.png)

* HTTP响应报文（三个部分：初始状态行，首部行，实体体）
```
HTTP/1.1  200  OK
Connection:close
Date: Tue,09 Aug 2011 15:44:04 GMT
Server:Apache/2.2.3
Last-Modified:Tue,09 Aug 2011 15:11:03 GMT
Content-Length:6821
Content-Type:text/html
...(实体体)

```
![http_response](/img/http_response.png)

一些常用的状态码：

* 200:请求成功
* 301:Moved Permanently 请求的对象已经被永久转移了，新的URL会定义在首部行中的Location字段
* 400:通用差错代码，表示该请求不能被服务器理解
* 404:Not Found,被请求的文档不在服务器上
* 505:HTTP Version Not Suported: 服务器不支持请求报文使用的HTPP版本

#### 用户与服务器的交互cookie

因为HTTP是无状态的，没有记录用户的信息，有的情况下一个Web站点想要希望能够识别用户，希望把内容与用户身份联系起来，为此HTTP使用cookie

四个组件：

* HTTP响应报文中的一个cookie首部行
* HTTP请求报文中的一个cookie首部行
* 在用户端系统保留一个cookie文件并由浏览器进行管理
* 位于Web站点的一个后端数据库

cookies通信流程：浏览器第一次访问服务器，服务器会生出一个识别码，并将该识别码通过set-cookies字段发送给浏览器，浏览器根据该识别码在特定的cookies文件中添加一行，随后就用该识别码cookie字段去访问服务器，服务器根据该识别码确认用户身份，于是建立一个用户会话层

#### Web缓存器

Web缓存起也叫代理服务器，会缓存一些请求过程中的对象加快访问速度。Web缓存器相当于一个中间件，既是客户端也是服务器。它可以大大减少对客户请求的响应时间，特别是当客户与初始服务器之间的带宽远低于客户与WEB缓存器的带宽，效果更明显。

由于Web缓存器中的副本内容可能过时，我们可以通过条件GET来确定该内容是否被修改了

**条件GET**:请求报文使用GET方法，并且请求报文中包含一个"If-Modified-Since"字段

### 文本传输协议FTP（21端口）
用户首先提供一个用户标识和口令，确认身份后即可通过一个FTP用户代理与FTP进行交互传输文件到相应文件系统中去，同样FTP也是通过TCP连接来传输数据

FTP和HTTP有很多共同点也有一些重要的区别，其中最显著的就是FTP使用来两个TCP连接来传输文件：

* **控制连接**:用于传输控制信息，如用户标识，口令，改变远程目录以及存放盒获取文件的命令
* **数据连接**:实际发送一个文本数据

因为FTP又一个单独的控制连接，所以也叫做**带外**传送的

FTP的数据传输是非连续的，因为在一个会话中的每个文件传输都是要建立一个新的数据连接

FTP一些常见命令

* USER username:传送用户标识
* PASS password:传送口令
* LIST:请求当前远程目录中的所有文件列表
* RETR filename:用于在远程主机检索（get）该文件
* STOR filename:远程主机存放该文件

FTP一些常用回答响应

* 331 Username OK,Password required  (用户名OK,需要口令)
* 125 Data connection already open;transfer starting(数据连接已经打开，开始传送文件)
* 425 Can't open data connection (无法打开数据连接)
* 452 Error writing file(写文件差错) 

### 电子邮件SMTP（25端口）
电子邮件系统包括：用户代理，邮件服务器，简单邮件传输协议（SMTP）

SMTP使用TCP可靠数据传输服务，使用一些命令用于通信HELO,MAIL FROM,RECPT TO,DATA,CRLF,QUIT等。且SMTP要求报文使用7比特ASCLL码格式，并且把所有报文对象都放倒一个报文中

邮件服务器将邮件发送到接受方的协议:POP3(第三版邮局协议),IMAP(因特网邮局访问协议)

### DNS（53端口）

一种主机名到IP地址转换的目录服务，域名系统，一台用户主机运行着DNS应用的客户端，将主机名经由客户端发送给DNS服务器，服务器会反悔该主机名对应的IP地址，然后用户主机和该IP地址80端口建立TCP连接

DNS服务器分为

* 根服务器（13个根服务器，标号从A到M）
* 顶级域服务器:国家级，com,org,net,edu等
* 权威DNS服务器

DNS缓存和DNS报文不做具体描述见P93

### P2P网络和TCP，UDP套接字编程见书

## 运输层

网络层提供的是两个主机之间的逻辑通信（邮政服务，邮车），运输层则是提供两个主机之间进程的逻辑通信（发送和接收并确认，相当于发件人和收件人发信和收信，并相互确认），运输层主要负责将从网络层接收到的报文段交付给应用程序进程

**套接字**：网络向进程传递数据和从进程向网络传递数据的门户，套接字位于**应用层和运输层之间**，用于两层的数据交互。所以运输层将从网络层获取到的报文段解析获取报文通过套接字传递给应用层

* 多路分解：将运输层的报文段中的数据交付到正确的套接字称为多路分解
* 多路复用：将多个套接字中的数据封装到首部信息生出报文段，然后将报文段传递给网络层叫多路复用

多路复用和分解的要求：

1. 套接字有唯一标示符
2. 报文段有特殊字段如源端口号字段，目的端口号字段来指示该报文段所要交付的套接字。

端口号：16bit，0～65535之间

* 0～1023: 为周知端口号，受限制的端口，只被诸如HTTP,FTP等周知应用层协议使用
* 其他的端口可以人为使用

### UDP－无连接运输
DNS是一个通常使用UDP的例子，来发送一个DNS查询报文

UDP无需建立连接，没有连接状态，分组首部开销小

UDP报文段结构：源端口号＋目的端口号＋长度＋检验和＋应用数据（应用层报文）

**UDP检验和**：将应用数据中的所有字的16bit相加，通过回卷及**反码运算**获取检验和，所以这些应用数据和检验和（反码）全部加到一起，如果没有bit出错的话，则得到的和应该全为**111111111111111**，只要有一个bit为0说明出现了差错。这可以发现差错，但不能恢复差错

### 可靠数据传输
可靠数据传输不仅仅会在运输层出现，也会出现在应用层和链路层，也许可靠数据传输的下层协议是不可靠的，所以这是一件相当困难的任务，比如TCP就是建立在不可靠的IP端到端网络层之上实现的可靠数据传输协议。

一层可靠数据传输协议需要在这一层实现四个接口：

* rdt_send():从上层接收要发送的数据
* udt_send():上层接收到的数据经过可靠数据传输协议处理检验交付给下层
* rdt_rcv():接收方从下层接收数据（下层协议可能是不可靠的数据传输，我们需要这一层的协议保障数据传输的可靠性）
* deliver_data():下层数据经过可靠数据传输协议处理检验后交付给接受方上层

![reliable_data_transfer](/img/reliable_data_transfer.png)

构造可靠信道传输协议

1.假设底层信道完全可靠，rdt1.0版本传输协议

2.底层信道可能出现差错，比特受损，当出现差错时，要自动请求重传(ARQ协议)，rdt2.0版本协议

* * 差错检测
* * 接收方反馈：肯定反馈(ACK),否认确定(NAK)
* * 重传

由于当反馈ACK,NAK出现差错时，我们无法知道接受方是否正确的接收到了数据。我们可以通过在数据分组中添加一个字段，然发送方对数据分组进行编号，接收方只需要检察序号即可确定分组是否是一次重传。

3.底层信道可能出现丢包，rdt3.0版本
发送一个分组后，启动一个定时器，等待一定时间RTT，如果没有接收到ACK响应，则重传。有可能是因为网络的状况导致分组没有及时到达接收方，或ACK没有及时到达发送方。这样就会出现**冗余的数据分组**


由于这个版本属于停等协议，即当分组发送后，必须要等到接收到ACK反馈才能发送下一个分组，这样就会严重降低发送方的数据发送效率，所以我们提出一种**流水线**的可靠数据传输协议，即不需要等待ACK反馈就可以连续发送多个分组，要求：

* 必须增加序号范围
* 协议的接收方和发送方也许能缓存多个分组，发送方最低限度应当缓存那些发送了但没有确认的分组
* 处理丢失损坏及延时过大的分组的两种基本方法：回退N步和选择重传。

#### 回退N步（滑动窗口协议）

发送方维持一个N个分组的窗口，该窗口维护的分组为那些已经发送但是没有接收到确认的分组，当该分组满时，不能再向接受方发送分组，需要等待响应ACK。否则可以发送分组。

接收方当接收到一个序号为n的分组时，如果是按序接收，即前面接收的分组序号为n-1则为分组n发送一个ACK，否则发送最近接收到分组序号的ACK，比如最近接收到的分组是n-2,当收到n分组时，发送一个序列号为n-2的ACK。

窗口会为最早发送的分组启动一个计时器，发现超时后会将窗口维持的所有分组重传。而当接收到最早发送的ACK时，则会为下一个分组重启该定时器，窗口向前滑动一格。

![GBN](/img/GBN.png)

回退N步当分组很大时会出现信道利用率低的问题，因为可能因为分组的差错导致重传大量的分组。这就需要用到下面的选择重传

#### 选择重传 
区别：

**发送方**：发送方维持的窗口中不仅仅包含的数据分组不全是未确认的，可能有部分分组已经确认正确发送。并且每个未确认的分组都有一个逻辑定时器，当出现超时时，则重传那些未确认的分组，而不需要将分组中的数据全部重传。并且当接收到ACK，且该ACK对应该窗口的最早发送的分组，则窗口向前移动，移动到最近没有确认的分组。

**接收方**:接收方同样维持一个窗口，该窗口维持的是没有按序交付的分组，窗口的第一个分组肯定是还没有正确接收的序号，而窗口中也可能缓存了那些失序但正确接收的分组。并且当接收方接收到一个序号为n的分组（在窗口内）都会对该序号为n的分组进行响应并缓存，而不是对最近未接收的分组响应。

![SR](/img/SR.png)

接收方的窗口大小必须小于或等于序号空间的一半，否则会出现序号n的分组还没正确接收到时，下一个序列回滚已经发送新的序列同样为n的分组，这样接收方无法判断该分组是重传的分组还是新的分组。

### TCP－面向连接的运输

TCP提供的连接不是真实的链路连接，TCP所有的连接状态都保存在两个**端系统**中，之前我们类比过，TCP这类运输层协议，只能让**发信人和收信人**确认信息发送的一套机制，或者说是一套端到端的暗语，来确保对方已经收到了信的内容。

TCP建立连接的通信过程：

1. 三次握手，端到端来回发送三次特殊TCP报文段来确认连接建立。
2. 建立连接后，客户端通过套接字发送数据到运输层，这里开始由TCP协议接管，TCP首先将这些数据引导到发送缓存里，接下来TCP将不定时的从缓存中取出数据并放入到报文段（添加TCP首部）发送
3. 报文段的大小（**MSS,最大报文段长度**）受限于**最大链路层帧长度(MTU,最大传输单元)**，即报文段大小MSS加上**TCP/IP协议首部长度(通常40)**要小于最大传输单元MTU

所以涉及到TCP连接的部分包括端和端的:缓存，变量和套接字

#### TCP报文段结构

![TCPSegment](/img/TCPSegment.png)

**序号和确认号**：实现全双工

* **序号**（用于发送数据）：TCP的序号是建立在字节编号的基础上，而不是报文段序列的基础，TCP会默认为数据流中的每一个字节进行编号，然后报文段中的序号是根据数据中的一个字节编号来确定的。
* **确认号**（用于接收数据）：因为TCP是全双工的，所以在主机A给B发送数据的同时也可能接收到B发送来的数据，确认号就是用于告诉B主机期望下一个接收的字节编号
* TCP并没有为接收到失序报文段时规定处理过程，而是将这一结果交给编程人员实现，可以选择丢弃，或缓存失序报文段。为节约带宽一般采取后者

**超时/重传机制**：

* 由于TCP是采取的超时/重传机制，所以如何定义超时是我们需要解决的问题
* 自然我们需要估计往返时间(RTT),我们只对**传输一次**就成功的报文取样往返时间**SampleRTT**,根据指数加权移动平均来估计往返时间:EstimatedRTT = 0.875\*EstimatedRTT + 0.125\*SampleRTT。
* DevRTT用于衡量EstimatedRTT波动的程度
* 超时间隔：TimeoutInterval = EstimatedRTT+4\*DevRTT,当出现超时后，**一般会将超时间隔加倍**

* 快速重传：当接收方接收到一个失序的报文段时，会重复发送按序接受的最后一个报文段的响应ACK，这样发送方就会接受到冗余的ACK，当发送方一旦收到**三个**冗余ACK，TCP就会执行快速重传
* TCP是回退N步GBN和选择重传SR的混合体，为什么是GBN?因为TCP才有累积确认的方式，当收到一个失序的报文段时，只会对正确接收的有序报文段的最后一个做重复确认。但TCP和GBN也有区别，因为TCP会缓存那些失序接收的报文。甚至当假设第n个报文段还没有确认时，但收到了n+1报文段的确认，这样也会默认第n个报文段正确接收。并且TCP会选择确认那些失序报文段，SR会跳过那些被选择确认的报文段，不会去重传这些被选择确认的报文段。

#### 流量控制(SCTP)

流量控制服务是为了消除发送方使得接收方缓存溢出的可能。拥塞控制则是发送方因为IP网络的拥塞被遏制的情况。

**接收窗口**：**发送方**维持一个接收窗口的变量来提供流量限制，提示发送方接收方还有多少缓存空间rwnd。发送方的**未被确认的报文段数量**不能多于该接收窗口的大小

* 接收方计算接收窗口的大小：LastByteRead - LastByteRcvd
* 发送方计算未被确认的报文段数量：LastByteSent - LastByteAcked<=rwnd

小问题：当接收方的缓存满时，rwnd=0,发送方不会再向接收方发送数据，接收方也不会产生响应，当接收方缓存清空时，发送方夜不能得知该消息，所以发送方一直处于堵塞状态。处于该问题的考虑，我们提出**当接收方缓存空间为0时，发送方依然会发送只有一个字节数据的报文段，接收方也会对其发送确认报文，当缓存清空时，rwnd会通过确认报文及时更新让发送方知道**。


#### 三次握手建立连接

1. 客户端TCP向服务器端发送一个特殊的TCP报文段，该报文段中**不包含应用层数据，SYN标志位置为1**，该特殊报文段会**随机选择一个初始序号**client_isn,放在序号字段中。
2. 服务器端获取了该报文段后，**分配了缓存和变量**，并向客户端发送了允许连接的报文段。该报文段也**不包含应用层数据，SYN位置为1，报文段首部的确认字段设为client_isn＋1**。同样也会为自己设置一个初始序号**server_isn填在序号字段**。表示同意接收连接。该报文段也称为**SYNACK报文段**
3. 当客户端接收到SYNACK报文段后，客户端要为该连接**分配缓存和变量**，同时向服务器发送另一个报文段，并将**确认字段设置为server_isn+1**,因为连接已经建立，所以**SYN比特设为0**，且该报文段**可以携带应用层数据**

![tcp_three_shake](/img/tcp_three_shake.png)

正确的TCP建立过程的客户端状态变化：

![TCP_CLIENT_STATE](/img/TCP_CLIENT_STATE.png)

正确的TCP建立过程的服务器端状态变化：

![TCP_SERVER_STATE](/img/TCP_SERVER_STATE.png)

> 需要3次握手的原因在于信道不可靠，如果信道可靠一方都能确保另外一方收到数据；
> * 为什么不是2次握手？ 如果只用2次握手，服务器收到客户端的请求后，因为服务器并不需要等待客户端的确认(第3次握手)，所以一个连接已经建立。1）在第2次握手时，如果报文段丢失，超时会引起客户端重新发起连接请求，此时服务器会认为这是客户端建立的另一个连接，因此又建立起一个连接，从而造成服务器为同一客户端维护了大量连接资源，造成浪费；2）如果客户端第一次握手超时，但是这个报文段并未丢失，直到一次正常的通信结束后才到达服务器。由于一次正常的通信后连接已经关闭，但是服务器认为这是客户端一次新的连接请求，因此建立起一个连接，但是客户端并不会对此进行响应，也造成了资源浪费；
> * 为什么不是4次握手？


#### 4次挥手

TCP连接的两个进程中任意一个都能终止该连接，连接关闭需要4步。假设客户端发起一个关闭请求：

![tcp_four_shake](/img/tcp_four_shake.png)

1. **客户端发送一个FIN报文**（首部中的FIN比特被置位）
2. **服务器返回一个对FIN报文的确认报文**
3. **服务器发送一个FIN报文**（首部中的FIN比特被置位）
4. **客户端返回一个对FIN报文的确认报文**




#### 拥塞控制原理

端到端的拥塞控制：在该拥塞控制方法中，网络层没有为运输层拥塞控制提供显式支持，即使网络中出现拥塞，我们只能通过TCP返回的信息来推断，IP层是不会给出反馈信息的

网络辅助的拥塞控制：网络层构件，如路由器会显式地向发送方提供拥塞控制的反馈信息，有两种方式：1. 路由器显式的向发送方发送分组提示拥塞。2.通过标记发送方发送给接收方分组中的标记，然后接收方发送分组给发送方提示拥塞。

ATM ABR拥塞控制框架：ATM表示从源主机到目的机路径上每个节点的状态都会被记录，ABR则是会在发生拥塞时通过抑制传输速率。并且ABR提供了三种机制来提示拥塞信息：

* EFCI比特：设置该比特位提示拥塞
* CI,NI比特:比特CI表示拥塞，NI表示畅通
* ER（两字节）：显式速率，设置该两字节显式调整发送方的速率

#### TCP拥塞控制（DCCP）

**拥塞窗口**：TCP跟踪一个额外的变量，拥塞窗口cwnd，在客户端中已发送但未确认的报文段数量必须要少于拥塞窗口和接收窗口之间的较小值。

TCP如何感知拥塞：1.超时   2.三个冗余ACK

**自计时**：当TCP报文段被正常接收并且确认时，我们会通过**确认的延时或速率**来自适应的提高发送速率，如果说确认速率慢，则**拥塞窗口**会缓慢增加，如果确认速度快，拥塞窗口则迅速增加。

TCP如何确认发送速率应该未多少：1.丢包后降低速率   2.顺利确认，提高速率   3. 探测速率，通过不断增加速率直到丢包发生后才降低速率，然后继续探测

#### TCP拥塞控制算法，慢启动，拥塞避免，快速恢复

##### 慢启动

什么叫慢启动，其实就是将拥塞窗口开始时设置为一个较小值MSS，然后每接收一个ACK确认，以2^n指数增长。但这种指数增长的速度到最后会恐怖，所以我们提出三个方式（这三个方式不是独立的，而是一整套方案）来限制慢启动的增长：

1. 当接收到一个**超时**指示的丢包事件时，我们将拥塞窗口设置为1，重新启动慢启动过程，并将慢启动阈值ssthresh设置为之前拥塞窗口大小的一半cwnd/2。
2. 当检测到拥塞窗口达到阈值ssthresh时，会结束慢启动方式进入到拥塞避免的状态，拥塞避免模式会更加谨慎的增长cwnd(MSS/RTT)
3. 当检测到3个冗余ACK（确认发生了丢包，但相对不严重，因为毕竟回来的确认报文段可以传送过来），执行快速重传进入快速恢复状态(MSS/ACK)

##### 拥塞避免

当拥塞窗口到达慢启动阈值ssthresh,就会进入该拥塞避免状态，是为了预防拥塞的发生，因为达到了阈值我们需要更加**谨慎的增加拥塞窗口的大小**。这时拥塞窗口的增长以MSS/RTT的速度线性增长。

但是一直保持这种线性增长的话，且带宽足够的话，会不能充分利用资源，所以我们何时结束这种线性增长呢？这就涉及到第三个部分了：检测到**3个冗余ACK**提示的拥塞（相对不严重），**将ssthresh降为拥塞窗口cwnd的一半**，并进入快速恢复状态。

##### 快速恢复

当接收到**三个冗余ACK**(无论是慢启动还是拥塞避免的状态只要发生三个冗余ACK就会触发快速恢复)时提示的拥塞，说明拥塞情况不那么严重，于是进入到快速恢复状态，首先将拥塞窗口减为一半并加3（因为已经收到三个冗余ack），然后和拥塞避免不同的是，拥塞避免的拥塞窗口增长速度为**MSS/RTT**,而快速恢复过程中窗口增长的速度为**每接收一个ACK则增加一个MSS**所以相对来说增长的速度会快些

但接收到由**超时**引起的拥塞，同样需要重新进入**慢启动状态**，即将**ssthresh设为引起拥塞的窗口大小cwnd的一半，然后将拥塞窗口设为1进入慢启动状态**


* TahoeTCP（传统的）:不区分两种提示的拥塞，遇到拥塞将阈值ssthresh = cwnd/2,cwnd设为1重新慢启动
* RenoTCP（结合快速恢复）:对冗余ACK会很敏感，当遇到三个冗余ACK时,ssthresh = cwnd/2,cwnd = ssthresh＋3*MSS（因为已经接收到了三个冗余ack）;然后**进入快速恢复状态，此时与ssthresh没有什么关系，因为没有进入慢启动状态，快速恢复的过程中拥塞窗口也不会下降到ssthresh以下**
* 加法式增加，乘法式减少。所以一般呈现锯齿状。

整个拥塞控制的状态变化图如下：

![cwnd_FSM](/img/cwnd_FSM.png)


## 网络层

网络层两大核心功能：

* 转发：根据目的地址确定发送链路接口，即方向
* 路由选择:在整个网络范围内作出的路径规划

网络层两大服务：

* 虚电路: 面向连接的服务网络，运输层中的连接服务是在**端**上实现的，网络层的连接服务除了端系统，还有网络核心的**路由器**来实现的
* 数据报网络：提供无连接服务的计算机网络

### 虚电路和数据报网络

#### 虚电路

VC号：VC号代表是一条虚电路中每一段链路的编号，一条链路在不同虚电路中有着不同的VC号，也正是这些VC号成功构建起了虚电路。这些信息都记录在转发表中，每创建一条新的虚电路，转发表就新增一项，每终止一条虚电路，转发表就相应删除一项。


|入接口  |   入VC号   |     出接口  |    出VC号   |
| 1     |     12    |     2      |     22     |
| 2     |     63    |     3      |     18     | 
| 2     |     7     |     2      |     17     |  

(每一条记录维持当前路由器中一条虚电路的节点转发信息，由此确定一条虚电路)

虚电路的三个阶段:

1. 虚电路的建立（信令报文）：当传输层将数据传送到网络层，根据接收方地址决定一条发送路径，并沿着这条路径的所有路由器都更新转发表项，确定虚电路中每条链路的VC号
2. 数据传送
3. 虚电路拆除：更新路径上的每个路由器上的转发表项，删除对应的VC纪录。

#### 数据报网络(因特网)

**数据报网络**：不同于虚电路网络，数据报网络发送分组前不用建立虚电路，每台路由器都会目的地址映射到链路接口的转发表，这些转发表根据**IP地址的范围**对应一个接口，有的是根据IP地址前缀（**最长匹配规则**）去对应一个接口。这些转发表信息的更新一般是通过**路由选择协议**来修改，通常1～5min更新一次。

### 路由器

四个组成部分：

1. **输入端口**：接收链路数据，并将数据根据协议解析，拆封，然后根据转发表进行**前缀匹配查找**（查找过程相对复杂）到输出端口，可能需要**排队**发送。还有可能有**防火墙**，定义了IP匹配规则，导致部分IP的分组将被阻止转发
2. **交换结构**：输入端口到输出端口的连接部分,三种交换结构:**经内存交换**（内存块）,**经总线交换**（总线bus）,**经互联网络交换**（电路构造）
3. **输出端口**：将到输出端口的分组进行**排队缓存管理**，然后进行**协议封装**，最后发送到链路
4. **路由选择处理器**：计算和更新路由转发表

#### 输出端口排队
路由器排队问题：当路由器的交换结构的转换速率Rs>N(为输入端口数量)*Rl(端口接收和发送分组的速率)。输入端口不会出现排队，而输出端口由于速度跟不上交换结构的转换速度，而使得排队现象越来越严重。

分组调度程序：当输出端口出现排队现象时，在这些排队结构中选择哪个分组进行发送，则涉及到分组调度程序，类似的，当输出端口缓存满时，接下来到来的分组是采用**丢弃，还是删除队列中已存在的分组来腾出空间**。

**主动队列管理(AQM)**：在某些情况下，当缓存接近满时，**通过丢弃一个分组**，或首部添加标记来**提示发送方拥塞**信号等等。

最广泛的一种AQM算法**RED(随机早检测)**:为输出队列都维护着加权平均值

1. 如果平均加权队列长度**小于最小阈值min**，则来一个分组接收一个分组
2. 如果平均加权队列长度**大于最大阈值max**，则当分组到达时会被标记或丢弃。
3. 当队列长度**位于［min，max］之间**时则以一定概率被标记和丢弃,这个概率是一个和平均队列长度，min，max的有某种函数关系

#### 输入端口排队
当输入速率大于交换速率时，输入端口部分也会出现排队现象，，但只要输出端口不同，多个分组可以并行发送，但当输出端口为同一个端口时，就会出现阻塞情况，这种发生在输入端口的排队现象**即线路前部阻塞（HOL）**

### 网际协议

#### 数据报格式

数据报是网络层的分组，这里先介绍IPv4数据报的格式：

![IPv4](/img/IPv4.png)

IP数据报分片：链路层协议的MTU(**最大传输单元限制着IP数据报的长度**)。多数IP数据报在链路层的MTU的限制下需要分片传输，在到达目的地运输层以前需要重新组装，重新组装的工作如果放到路由器中会增加复杂性，并影响路由器的性能，所以一般将**IP数据报分片重组的操作放在端系统**

**标识号**:在IPv4数据报的结构中，我们看到一个标识号的结构，发送方将为一个数据报添加一个标识号，并递增标识号，用它就可以区分**哪些分片来自于同一个标识号**。

**标志**：用于区分一个数据报的分片中**哪个是最后一个分片**，最后一个分片标志位为0，其他为1。

**偏移地址**：用于标示该分片位于该**数据报中的哪个位置**，偏移量，用于重组。

A,B,C类网络的子网标识长度为8,16,24比特.IP广播地址：255.255.255.255

#### DHCP动态主机配置协议

**DHCP(动态主机配置协议)**：使得给定主机在某个子网内与网络连接时动态分配得到一个IP，可能是相同的，也可能是临时的。也叫即插即用协议，该协议分为如下**四个步骤**：

1. DHCP服务器发现：客户端使用一个**DHCP发现报文**，利用**源地址0.0.0.0向广播地址255.255.255.255**发送该报文。
2. DHCP服务器提供：DHCP接收到该发现报文时，用一个**DHCP提供报文**向客户作出响应。仍然使用IP广播地址255.255.255.255。并且该报文包含：发现**报文的事务ID，向客户推荐的IP地址，网络掩码以及IP地址租用期**。
3. 客户接收到来自多个DHCP服务器的响应报文后，选择一个**最优的进行响应**，响应的报文为**DHCP请求报文**，回显配置参数。
4. DHCP服务接收到该请求报文后，使用**DHCP ACK报文**对客户端进行响应，证实所要求的参数。客户一旦接收到该ACK报文后，交互便完成了，在该**租用期**内，客户将一直使用该IP地址。
#### NAT 网络地址转换

**网络地址转换(NAT)**：地址空间10.0.0.0／8是保留的3部分IP地址空间之一，这些地址用于专用地址，只在给定的网络范围内有效。当来自这个给定网络的主机想要和外部的网络通信时，就不能使用该网络中的专用地址这时就需要利用NAT网络地址转换，转换成一个IP地址如138.76.29.7来和外部网络进行交互。NAT路由器相对于网络网络来说就是一个具有单一IP地址的单一设备。

**NAT转换表**:当从外部广域网想要访问该给定网络内部的某个主机时，因为访问的IP都是同一个IP，如何区分内部网络的主机就需要借用NAT转换表。转换表中包含着NAT路由器的IP地址（同一个IP）和端口映射着内部网络的某个主机的IP地址和端口。

NAT会妨碍到P2P应用程序：在P2P中任何主机都要能充当服务器，当服务器位于NAT路由器背后，则不能和外部的网络发起一条TCP连接。详见P235

#### ICMP 因特网控制报文协议

ICMP:用来被主机和路由器用来彼此沟通网络层的信息，最典型的用途就是用于**差错报告**（目的网络不可达等）。ICMP报文是被承载在IP分组中的。ICMP具有一个**类型字段**和一个**编码字段**，并且包含引起该ICMP报文首次生成的**IP数据报的首部和前八字节内容**（以便发送方能确定引发该错误的数据报是哪个）

**ping**程序就是发送一个ICMP**类型8编码0**的报文（用于**回显请求**）到指定主机，目的主机会发回一个**类型0编码0**的ICMP**回显回答**。其他具体类型见P236

还有一个有趣的ICMP报文（类型4，编号0）为**源抑制报文**，拥塞的路由器向一台主机发送一个ICMP源抑制报文强制该主机减少发送速率。

#### IPv6

详见P238,32bit->128bit。

![IPv6.png](/img/IPv6.png)

IPv6引入了称为**任播地址**的新地址，这种地址可以使一个数据报能交付给一组主机中的任意一个

定长的40字节首部允许更快的处理IP数据报

* **版本号**：IPv6将该字段值设置为6
* **流量类型**：与IPv4中的”服务类型“字段含义相同，区分不同类型数据报（实时/非实时）
* **有效载荷**：数据部分的字节数
* **下一个首部**：应该交付给运输层的哪个协议
* **跳限制**：同TTL

**IPv6不允许在中间路由器上进行分片与重新组装，这种操作只能在源于目的地上进行**。如果一台路由器收到的IPv6数据报因太大而不能转发到出链路上，则只需丢掉该数据报，并返回一个”分组太大“的ICMP差错报文。因此IPv6中没有IPv4用于分片相关的3个字段

IPv6的关注快速处理分组，由于运输层提供了差错检测，IP设计者可能觉得没必要再在网络层进行差错检测，所以去掉了首部校验和字段

IPv4中的选项字段并没有作为IPv6的首部字段出现，但其并未消失，而是可能出现在可能出现在首部中由”下一个首部“指出的位置上

### 路由选择算法

路由选择算法的分类：

1. 全局式路由选择算法:拥有全局网络的状态信息－－链路状态算法LS
2. 分散式路由选择算法:只拥有局部链路信息便可以开始工作－－DV算法

---
1. 静态路由选择算法：随着时间流逝，路由的变化非常缓慢
2. 动态路由选择算法：能够根据网络负载和拓扑发生变化时动态改变路由选择路径

---
1. 负载敏感算法：链路的费用（权值）会动态变化来反映链路的拥塞状况。从而路由的路径选择也会发生相应变化
2. 负载迟钝算法：链路的费用不能反映链路的拥塞情况

#### LS全局路由选择算法
**LS全局式算法**：Dijkstra算法，该算法为在图中找到一条最短的路径的算法，具体可以见算法章节关于图的讨论。还有一个算法为Prim与之密切相关。

#### DV分布式路由选择算法
距离向量路由**分布式算法(DV)**:异步的，迭代的，我们针对一个节点来看它的算法过程

1. 初始化：该节点更新它和邻居节点的距离c(x,w)并记录路由向量Dx(y)，其他不是邻居节点的**记录记为∞**。
2. 该节点记录所有邻居节点w到其他所有点y的向量距离Dw(y)，刚**开始均为∞**。
3. 给所有邻居节点**发送本节点的路由向量**Dx(y)。
4. 当其他路由节点**发送路由更新信息到本节点**时，更新本节点的路由向量**Dx(y) = minw{c(x,w)+Dw(y)};**//一个节点x到另一个节点y的最短路径一定等于（x到所有邻居节点w中的距离c(x,w)与该邻居节点w到目的节点y的最短路径Dw(y)之和）的最小值。**如果本地节点和其他节点的最短向量路径发生变化，也会通知他的邻居节点**

**异步的**：所有网络中的节点都会**异步执行以上四个步骤**，只要当邻居节点发送来路由更新时都会根据Dx(y) = minw{c(x,w)+Dw(y)};来**更新本地的路由信息表项**。

**路由选择环路**：

![routing_loop](/img/routing_loop.png)

x,y之间的距离从4更新为60

在没更新前：Dx(y) = 4, Dx(z) = 1, Dz(x) = 1,Dz(y) = 5;

更新后：

* Dx(y) = min{60,c(x,z) + Dz(y)} = 6;//按顺序更新
* Dz(y) = min{50,c(z,x) + Dx(y)} = 7;//...这样一直反复44次循环震荡,导致路由距离向量更新极慢

**毒性逆转**：当z需要**通过x**计算到y的距离向量Dz(y) = 5;此时z将向x**通告Dz(y) = ∞**。但这个方法针对涉及到更多节点时无效，因为z只能通告直接连接的邻居节点。

LS和DV两种算法在实际的网络环境中使用有点过于简单化，因为当规模逐渐变大，路由器的个数成亿计数，这将导致LS为了更新路由信息而产生的报文数据直接挤满链路容量，从而无法传输任何其他数据。所以我们提出一种管理自治的系统AS。

自治系统AS:内部采用自己的**AS内部路由选择协议（RIP）**，通过**网关路由器**和外部网络相连，如何将内部的数据转发到指定外部网络则是利用**AS间路由选择协议（BGP）**。

### 因特网的路由选择

#### AS内部路由选择
##### 自治系统内部的路由选择：RIP（也被称为内部网关协议）

自治系统内部的路由选择协议有两个经典的协议：路由选择信息协议(RIP)和开放最短路优先协议(OSPF).

RIP:类似一种**理想化的DV**分布式路由选择协议，但RIP版本是使用**跳数**作为费用测量，即每条链路的费用均为1，没有权值，且邻居路由器之间通过**RIP响应报文**每30s互换一次信息，更新路由信息。

RIP表：路由信息的维护是通过一张称为路由选择表的RIP表维护的，第一列为目的子网，第二列为沿着最短路径到下一个路由器的标识，第三列为沿着最短路径到目的子网的跳数。

目的子网  | 下一跳路由器 | 到目的子网的跳数 |
   w     |     A      |      2        |
   y     |     B      |      2        |
   z     |     B      |      7        |
   
RIP规定当一个路由器**180s**没有接收到另一个邻居路由器的更新报文时，则将认为该邻居节点中断不可达，并将该信息**通告给可以到达的邻居节点**。RIP所使用的信息交互报文为**UDP报文(520端口)**，所以RIP是一个运行在UDP上的**应用层协议**。

##### 自治系统内部的路由选择：OSPF

OSPF：该协议的核心就是使用**洪泛链路状态**信息的链路状态协议和一个**Dijkstra**最低费用路径算法，每个路由器都拥有整个自治系统的**完整拓扑图**。路由器每隔**30分钟**向其他所有路由器**广播**路由选择信息。OSPF报文由**IP承载**对OSPF其上层协议值为**89**。

优点：

* 安全
* 多条相同费用路径分流
* 对单播和多播支持
* 支持层次结构：一个OSPF可以配置成多个区域，每个区域运行着自己的OSPF链路状态选择算法。区域由区域边界路由器来隔离，每个OSPF只有一个主干区域为其他区域之间提供路由选择。

#### AS间路由选择：BGP

边界网关协议BGP：主要有以下工作手段

1. 从邻居AS处获得子网可达性信息
2. 向本AS内部所有路由器广播这些可达性信息
3. 基于可达性信息和AS策略，决定到达子网的好"路由"

BGP分为：

* iBGP(内部BGP会话)：在一个AS内部发送BGP报文的两台路由器之间的会话
* eBGP(外部BGP会话)：在两个AS之间发送BGP报文的两台路由器之间的会话

BGP协议通告BGP协议报文时，一般通告的是**CDIR化的前缀**，可以通过子网聚合操作，然后向邻居AS路由器通告该**子网聚合后的前缀**信息。

BGP报文通告一个前缀时通常包含一些BGP属性信息，其中最重要的两个信息为：

* AS-PATH: 该报文从源路由器到当前路由器的路径上所**经过的AS**
* NEXT-HOP:下一跳，**源路由器**到该**通告的子网AS区域**中的**最短路径**的**下一跳路由器**对象。


## 链路层

链路层提供的服务：

* 成帧：用链路层帧将网络层中的数据报封装成链路帧
* 链路接入：媒体访问控制协议(Medium Access Control,MAC)协议规定帧在链路上的传输的规则，这个协议规则就是无论何时链路空闲，发送方都能够发送帧
* 可靠交付：保证将数据无差错传送到目的，但链路层的这个服务有点多余不必要
* 差错检测和纠正：检测链路中bit传输的差错。

链路层实现的主体部分是在**网络适配器**(network adapter,也就是一种将**网络层数据适配各种类型的网络如wifi，电缆等生成相应帧**的设备)。常常称为**网路接口卡**（NIC）,该设备**硬件实现**很多链路层的服务，如成帧，链路接入，差错检测等

### 差错检测

差错检测不一定可以完全检测出已经出现的比特差错，尽可能让差错出现的概率变小。目前检测差错的技术主要有三种： 奇偶校验，检验和方法，循环冗余检测

#### 奇偶校验

奇偶校验：提供奇偶校验位，发送的信息为d比特，则设置该奇偶校验位使得该d+1个比特的个数为奇数（奇校验）或偶数（偶校验）。

二维奇偶校验：将发送的信息d个比特划分成i行j列。每行每列都计算奇偶值。通过出现差错的行或列的索引来识别发生的差错并可以直接纠正它。

前向纠错：接收方检测和纠正差错的能力叫做前向纠错。

#### 检验和方法

之前有过描述，同上

#### 循环冗余检测CRC

当发送一个d比特长度的数据时，我们首先和接收方约定一个r+1比特模式多项式G，然后给发送的d比特数据附加一个r比特CRC校验位（**我们总能通过设置合适的r比特冗余码使得该d+r比特模式多项式整除该r+1比特模式多项式**），使得该d+r比特模式的多项式可以整除约定的r+1比特模式多项式G。若接收方可以整除，则说明数据正确，否则错误

### 多路访问链路和协议

有两种网络链路：点对点网络、广播链路。

点对点网络就是由单个发送方和单个接收方组成。广播链路就是多个发送方和多个接收方均连接到相同的，单一的，共享的**广播信道**上去。如何协调多个发送方和多个接收方在该信道上发送数据并接收数据还不出现差错这就是这一小节我们要讨论的问题,即**多路访问协议**,主要分为三类：**信道划分协议，随机接入协议，轮流协议**。

**信道划分协议**：

1. 时分多路复用（TDM）:将时间划分成时间片分别分给不同的发送方和接收方（不同时间）
2. 频3分多路复用(FDM):将信道划分成不同的频段，分给不同的发送方和接收方（不同空间）
3. 码分复用(CDMA):每个节点分配不同的编码，只有对应接收方才能识别该编码（不同语言）

**随机接入协议**:当发送方发送的数据和其他发送方发送的数据发生碰撞时，在重发该帧之前要等待一个**随机时延**。

* * 时隙ALOHA:时间会被划分成**时隙**，当发送碰撞时，在下个**时隙开始**时以**概率p**重发该帧，所有节点的时隙都是同步的，这种协议的实际数据发送最大效率为**0.37Rbps**(R为该信道的传输速率)
* * 纯ALOHA:**不会划分时隙**，当数据发送碰撞时将**立即以概率p**重发该帧。这种效率更低，最大效率仅为时隙**ALOHA最大效率的一半**
* * CSMA(载波监听多路访问)：在发送帧之前进行**信道检测**，如果信道忙则不发送，**信道空闲**则发送帧。由于信道时延，即使检测到信道空闲也会**发生碰撞**，而CSMA**没有碰撞检测**，发生碰撞时依然会发送完该帧。
* * CSMA/CD:这是**带有碰撞检测**的载波监听，即在发送帧的过程中也会**监视**信道是否有来自其它适配器的能量信号，有则发生了碰撞，只要发生碰撞就会**立刻终止传输**，并**随机**等待一个时间量后传输。

轮流协议：

* * 轮询协议：信道中的节点指定一个节点为**主节点**然后**循环检测**其它节点是否有数据发送，该协议消除了随机接入的**空时隙和碰撞**情况，提高了效率，但也会**引入轮询时延**，当**只有单个节点**发送数据时，必须要忍受一个轮询时延才能发送。另一个问题是**主节点故障**时，整个信道都不可操作。
* * 令牌传递协议：无需指定一个主节点，而是通过节点之间**传递一个令牌帧**，来传递数据发送权限。这样**一个节点故障也容易引起信道崩溃**，比如当一个节点**忘记传递令牌**时，则必须要调用某个恢复程序才能进入正常轮询状态。

### 链路层编址

在一个局域网内部，有多台服务器和交换机连接的路由器，**交换机是在链路层**的，所以它们交换链路层的帧（而不是网络数据报），不识别网络地址，它们使用的是链路层地址。所以我们这一小节学习**链路层寻址和以太网**。

网络层和链路层都具有地址，**地址解析协议(ARP)**就是提供了将IP地址转换为链路层地址的机制。

#### MAC地址（LAN地址，物理地址）

事实上不是主机或路由器具有MAC地址，而是**网络适配器（网络接口，网卡）具有MAC地址**。所以一个主机或路由器具有多个网卡，就具有多个MAC地址。

这些**主机一个接口对应一个相关联的MAC地址**，但交换机的接口不同，**交换机的接口不具有链路层地址**，它只是一个链路层帧一个承载传输节点，它可以**透明的**将该帧传输到指定的MAC地址接口。所以主机**不必指明帧传输到指定之间的交换机**，交换机对于主机来说是**透明**的。

MAC地址长度为6字节，可以有2^48个可能的MAC地址，没有任何两个适配器具有相同的MAC地址，一个MAC地址**唯一标示一个网络适配器**。IEEE负责管理MAC地址的分配。MAC地址在任何国家任何地区使用都是一样的，**扁平结构**，不同于IP的层次结构。

**MAC广播地址**:FF-FF-FF-FF-FF-FF

#### ARP地址解析协议（跨越链路层和网络层的协议）

每个主机和路由器在内存中都会有一个ARP表，这张表包含了**IP地址到MAC地址的映射关系，以及TTL**（寿命值），表示该表项将被删除的时间，一般一个表项的过期时间为20分钟。

![ARP](/img/ARP.png)

查询MAC地址：当内存中不存在对应的IP地址到MAC地址的映射关系
1. 发送方会构造一个**ARP分组**，这个分组有几个字段：**发送和接收的IP地址及MAC地址**（查询分组一般是**广播地址**）。ARP的查询分组和响应分组具有相同的格式。
2. 查询分组将询问子网上所有其它的主机和路由器来确定IP地址对应的MAC地址。**匹配该IP地址**的主机或路由器将会返回**响应分组**
3. 接收到响应分组后，发送方就可以**更新ARP表**。

ARP只为在**同一个子网**上的主机和路由器解析IP地址。当一个路由器或主机要向**其它子网**发送数据时
1. 首先要先找到自己**所在子网的路由器接口**（网关路由器）的MAC地址，发送到该路由器
2. 然后由**该路由器的ARP表**找到其它子网的**网关路由器MAC地址**，并发送给它，数据进入到该子网

### 以太网

以太网是目前最流行的有线局域网技术，以太网帧结构：

![ethernet](/img/ethernet.png)

* **数据字段**：承载了IP数据报。以太网的最大传输单元(MTU)为1500字节
* **目的地址和源地址**（12字节）：分别为6字节的MAC地址
* **类型字段**（2字节）：标示该数据报属于哪种网络层协议
* **CRC**（4字节）:冗余校验字段
* **前同步码**（8字节）：前七字节为10101010,最后一个字节为10101011,前七个字节用于唤醒接收适配器，并将它们的时钟与发送方同步。

以太网提供的是**无连接服务**，和**不可靠服务**，虽然有CRC校验码，但是**匹配成功和失败都不会发回响应**，并且匹配失败也只是丢弃该帧，不会返回响应，所以发送方并不知道接收方是否成功接收该帧，所以可靠性服务取决于运输层协议是UDP还是TCP。

### 交换机

##### 交换机转发和过滤

* 过滤:交换机决定一个帧应该转发到某个接口还是应该被丢弃
* 转发：决定一个帧应该被导向哪个接口
* 过滤和转发的功能是借助交换机表完成，交换机表中包含：1. MAC地址 2. 通向该MAC地址的交换机接口 3. 表项放置在表中的时间

![ex_table](/img/ex_table.png)

实现：当交换机接口x来了一个发送至MAC_A 的帧

*  如果交换机表中没有MAC_A表项，则向交换机所有接口广播该帧
*  如果交换机表中有MAC_A表项对应接口依然为x（该帧到来的接口），则丢弃该帧
*  如果交换机表中有MAC_A表项对应接口y≠x，则转发该帧到y接口

#### 自学习

交换机中的表是自动、动态和自治地建立的。建立过程如下（自学习）：

1. 交换机表初始为空
2. 对每个接口接收到一个帧，包含该帧的源MAC地址，到达接口号，到达时间，即可记录为一个表项。
3. 如果在一段时间（老化期）过后，交换机没有接收到该地址作为源地址的帧，就在表中删除这个地址。

交换机属于即插即用设备

#### 交换机和路由器设备对比

**交换机**：使用MAC地址通信，**接口没有MAC地址**，属于第二层**链路层**

- **优点**：
        + 即插即拔设备
        +  分组过滤，转发速率相对较高

- **缺点**：
        + 交换网络的活跃拓扑限制为一棵生成树,不能构成闭环，防止广播帧的无限循环
        + 对广播风暴不提供任何保护措施(当交换机一个节点出现故障，无限发送广播，交换机中的节点都会广播，导致整个系统崩溃)

**路由器**：使用**网络地址**通信，网络接口（网络适配器，网卡）具有MAC地址,属于第三层**网络层**。

- **优点**
        + 分组不会被限制在一棵生成树上，从而能用各种拓扑结构来构建因特网
        + 对广播风暴提供了防火墙保护
- **缺点**
        + 不是即插即用（需要人为配置IP地址）
        + 对分组的处理时间更长（必须处理高达第3层的字段）

>通常，由几百台主机组成的小网络通常有几个LAN网段，对于这些小网络，交换机就足够了，因为它们不要求IP地址的任何配置就能使流量局部化并增加总吞吐量。但是在由几千台主机组成的更大网络中，通常在网络中还包括路由器。路由器提供了更健壮的流量隔离方式和对**广播风暴**的控制，并在网络的主机之间使用更“智能的”路由



## Web页面请求过程

### 1. DHCP 配置主机信息

1. 假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。

2. 主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。

3. 该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。

4. 该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。

5. 连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。

8. 该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。

9. 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。

### 2. ARP 解析 MAC 地址

1. 主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。

2. 主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。

3. 该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。

4. 该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。

5. DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。

6. 主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。

7. 网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。

### 3. DNS 解析域名

1. 知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。

2. 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。

3. 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。

4. 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。

5. 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。

### 4. HTTP 请求页面

1. 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。

2. 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。

3. HTTP 服务器收到该报文段之后，生成 TCP SYNACK 报文段，发回给主机。

4. 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。

5. HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。

6. 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。

## 常用端口

| 应用层协议 | 端口号 | 运输层协议 |
| -- | -- | -- |
| DNS | 53 | UDP |
| FTP | 控制连接 21，数据连接 20 | TCP |
| TELNET | 23 | TCP |
| DHCP | 67 68 | UDP |
| HTTP | 80 | TCP |
| SMTP | 25 | TCP |
| POP3 | 110 | TCP |
| IMAP | 143 | TCP |




































